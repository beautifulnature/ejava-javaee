Java EE Exercise 

Part A: Create Project Shell

* Objectives

    * Create and deploy an EAR with a bare bones EJB.

        * {{{Create_the_root_Maven_project}
            Create the root Maven project
            }}

        * {{{Create_the_EJB_Maven_project}
            Create the EJB Maven project
            }}

        * {{{Create_the_EAR_Maven_project}
            Create the EAR Maven project
            }}

    * Create and run an RMI Test that will locate the JNDI tree,
    lookup the EJBs remote interface, and invoke a simple method.

        * {{{Create_the_RMI_Test_Maven_project}
            Create the RMI Test Maven project
            }}

        * {{{Start_JBoss_Application_Server}
            Start JBoss Application Server
            }}

        * {{{Deploy_the_Application}
            Deploy the Application
            }}

        * {{{Setup_JNDI_access_to_Remote_interface}
            Setup JNDI access to @Remote interface
            }}

        * {{{Invoke_EJB_method_through_Remote_interface}
            Invoke EJB method through @Remote interface
            }}

        * {{{Add_a_few_finishing_touches}
            Add a few finishing touches
            }}


* {Create the root Maven project}

    Each component of the Java EE application will be developed as 
    as a separate Maven module. Each module will be placed in a 
    flat structure under a common parent project. This parent project
    will be used to coordinate goals involved of the entire application.
    The order in which it builds things can be influenced by the 
    configuration you supply, however, it will analyze dependencies
    at build time are either honor the dependency ordering or fail
    if you have expressed a circular dependency.

    [[1]] Create a root directory for the exercise. This will host
    the root project and sub-projects for the Impl, EJB, WAR, EAR,
    and RMI Test modules.

---
$pwd
/cygdrive/c/proj
$ mkdir javaeeEx
---

    [[1]] Create a root project pom.xml file. This project will 
    will not have an associated artifact and is termed a "reactor"
    project. It uses a special packaging type called "pom".

    [Note:] It is very important that you realize that the packaging
    type is "pom" in this case. If you leave out this specification,
    Maven will default to packaging=jar type and attempt to build a
    Java-based artifact and ignore its responsibility in this 
    project to be the root project to delegate to the child 
    projects that build artifacts.

    []

---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeEx</artifactId>
    <packaging>pom</packaging>
    <name>Java EE Exercise</name>
    <version>1.0-SNAPSHOT</version>
    <description>
        This project is the root project for the example Java EE
        Application.
    </description>
    <modules>
    </modules>

    <profiles>
    </profiles>
</project>
---

    [[1]] Test your root project by building it at this time.

---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise
[INFO]    task-segment: [clean, install]
[INFO] ------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] [site:attach-descriptor]
[INFO] [install:install]
[INFO] Installing c:\proj\javaeeEx\pom.xml to c:\proj\repository.test\myorg\javaee\
javaeeEx\1.0-SNAPSHOT\javaeeEx-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Sun Mar 15 21:36:08 EDT 2009
[INFO] Final Memory: 7M/14M
[INFO] ------------------------------------------------------------------------
---

* {Create the EJB Maven project}

    The EJB project will be used to develop one of the EJB components. The
    term "EJB" gets a little overloaded at times.  There are EJB classes,
    EJB components, and EJB tiers.  EJB classes break out into the
    @Remote and @Local interfaces, the EJB implementation class (either
    @Stateless, @Stateful, or @MessageDriven), and support classes. It
    is common to think of each cohesive pairing of @Remote, @Local,
    and implementation class as "an EJB".  You can have many EJBs
    (the sets of classes) within an EJB component. An EJB component is
    a materialized as a .jar and there can be many EJB components within
    your EJB tier. For this exercise we will have only one EJB component
    and start out with only one EJB.  A second EJB will be added to the
    single EJB component in a later excercise to help support testing.
    A single Maven project can build a single EJB component.


    [[1]] Add an EJB project directory to your project tree.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir javaeeExEJB
---

    [[1]] Add the outer shell of the EJB module's pom.xml. 

    [Note:] It is important to note that the packaging type is "ejb" in this
    case. If you leave out the packaging type, Maven will default to "jar"
    and not handle your module appropriately within the context of a Java EE
    application.

    []

---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <parent>
        <artifactId>javaeeEx</artifactId>
        <groupId>myorg.javaee</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeExEJB</artifactId>
    <packaging>ejb</packaging>
    <name>Java EE Exercise EJB</name>
    <description>
        This project provides example usages of an EJB tier.
    </description>

    <dependencies>
    </dependencies>

    <build>
        <plugins>
        </plugins>
    </build>
</project>
---

    [[1]] Add in the Java SE 1.5 plugin specification to make sure JDK
    1.5 is used.

---
    <build>
        <plugins>
              <!-- make sure we are building java5 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                </configuration>
            </plugin>
    ...
---

    [[1]] Add in the maven-ejb-plugin specification to configure it
    for EJB Version 3.0. Otherwise, it will default to a pre-3.0
    version that does not handle JPA. We will also add a few more 
    details.
    
        * tell it to add all dependencies with scope=compile 
        to the Class-Path in the META-INF/MANIFEST.MF

        * tell it to create a ejb-client.jar file for remote clients.
        This will be populated using a set of include and exclude 
        paths. In this case, we are telling it not to include any
        of our deployment descriptors in the META-INF directory as
        well as leaving out our EJB implemenation class.

---
          <!-- tell the EJB plugin we are using EJB3  and configure client-jar -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-ejb-plugin</artifactId>
            <version>2.3</version>
            <configuration>
                <ejbVersion>3.0</ejbVersion>
                <archive>
                    <manifest>
                        <addClasspath>true</addClasspath>
                    </manifest>
                </archive>
                <generateClient>true</generateClient>
                <clientExcludes>
                    <clientExclude>**/META-INF/*.xml</clientExclude>
                    <clientExclude>**/ejb/*EJB.class</clientExclude>
                </clientExcludes>
            </configuration>
        </plugin>
    </plugins>
</build>
---

    [[1]] Add several dependencies to account for use of logging, 
    annotations, and EJB constructs. Use the artifacts out of the
    JBoss-maintained maven repository since javaee.jar is not as
    easy to locate.

---
    <!-- this repositories holds many of the javaee5 jar files -->
    <repositories>
        <repository>
            <id>jboss-repo</id>
            <name>JBoss Maven Repository</name>
            <url>http://repository.jboss.org/maven2</url>
        </repository>
    </repositories>

    <dependencies>
        <!-- core dependencies -->
        <dependency>
          <groupId>javax.annotation</groupId>
          <artifactId>jsr250-api</artifactId>
          <version>1.0</version>
          <scope>provided</scope>
        </dependency>
        <dependency>
          <groupId>javax.ejb</groupId>
          <artifactId>ejb-api</artifactId>
          <version>3.0</version>
          <scope>provided</scope>
        </dependency>
        <dependency>
          <groupId>commons-logging</groupId>
          <artifactId>commons-logging</artifactId>
          <version>1.0.4</version>
          <scope>provided</scope>
        </dependency>
---

    [[1]] Create the src tree for the EJB.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir -p javaeeExEJB/src/main/java/myorg/javaeeex/ejb/
---


    [[1]] Add the beginning @Remote and @Local interfaces. Please 
    a simple ping() method in the @Remote interface for use as an
    end-to-end sanity check at the end of this exercise.

---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarRemote.java
package myorg.javaeeex.ejb;

import javax.ejb.Remote;

@Remote
public interface RegistrarRemote {
    void ping();
}
---
---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarLocal.java
package myorg.javaeeex.ejb;

import javax.ejb.Local;

@Local
public interface RegistrarLocal {
}
---

    [[1]] Add the beginning of a @Stateless EJB that will implement
    the provided @Remote and @Local interfaces. Implement @PostConstruct
    @PreDestroy callbacks to intercept EJB lifecycle events. Add a 
    logger and log statements to the methods so we can observe activity
    within the EJB during the test at the end of this exercise.

---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarEJB.java
package myorg.javaeeex.ejb;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.ejb.Stateless;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


@Stateless
public class RegistrarEJB implements RegistrarLocal, RegistrarRemote {
    private static Log log = LogFactory.getLog(RegistrarEJB.class);


    @PostConstruct
    public void init() {
        log.debug("**** init ****");
    }

    @PreDestroy
    public void close() {
        log.debug("*** close() ***");
    }

    public void ping() {
        log.debug("ping called");
    }
---


    [[1]] The EJB should build at this time. You will notice the following
    in the output.

        * Our 3 Java files (@Remote, @Local, and @Stateless) were compiled

        * EJB 3 processing was performed on the target. This largely 
        consisted only of MANIFEST Class-Path processing and the construction
        of an ejb-client.jar file at this point.


---
$ (cd javaeeExEJB/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise EJB
[INFO]    task-segment: [clean, install]
[INFO] ------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 3 source files to c:\proj\javaeeEx\javaeeExEJB\target\classes
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] No sources to compile
[INFO] [surefire:test]
[INFO] No tests to run.
[INFO] [ejb:ejb]
[INFO] Building ejb javaeeExEJB-1.0-SNAPSHOT with ejbVersion 3.0
[INFO] Building jar: c:\proj\javaeeEx\javaeeExEJB\target\javaeeExEJB-1.0-SNAPSHOT.jar
[INFO] Building ejb client javaeeExEJB-1.0-SNAPSHOT-client
[INFO] Building jar: c:\proj\javaeeEx\javaeeExEJB\target\javaeeExEJB-1.0-SNAPSHOT-client.jar
[INFO] [install:install]
[INFO] Installing c:\proj\javaeeEx\javaeeExEJB\target\javaeeExEJB-1.0-SNAPSHOT.jar to c:\proj\repository.test\myorg\java
ee\javaeeExEJB\1.0-SNAPSHOT\javaeeExEJB-1.0-SNAPSHOT.jar
[INFO] Installing c:\proj\javaeeEx\javaeeExEJB\target\javaeeExEJB-1.0-SNAPSHOT-client.jar to c:\proj\repository.test\myo
rg\javaee\javaeeExEJB\1.0-SNAPSHOT\javaeeExEJB-1.0-SNAPSHOT-client.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Sun Mar 15 22:34:52 EDT 2009
[INFO] Final Memory: 7M/14M
[INFO] ------------------------------------------------------------------------
---

    [[1]] Add the EJB module to the root pom.xml.

---
    <modules>
        <module>javaeeExEJB</module>
    </modules>
---

    [[1]] Retest the build from the root.

---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] Reactor build order:
[INFO]   Java EE Exercise
[INFO]   Java EE Exercise EJB
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise

...

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] Java EE Exercise ...................................... SUCCESS [2.469s]
[INFO] Java EE Exercise EJB .................................. SUCCESS [1.531s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 4 seconds
[INFO] Finished at: Sun Mar 15 22:42:29 EDT 2009
[INFO] Final Memory: 11M/19M
[INFO] ------------------------------------------------------------------------
---

    [[1]] Verify this is what you have so far.

---
javaeeEx/
|-- javaeeExEJB
|   |-- pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- myorg
|                   `-- javaeeex
|                       `-- ejb
|                           |-- RegistrarEJB.java
|                           |-- RegistrarLocal.java
|                           `-- RegistrarRemote.java
`-- pom.xml
---

* {Create the EAR Maven project}

    EARs are Java archives that are used to house the overall application,
    with all of its components. The EAR can contain many EJB and WAR
    components as well as their dependencies (and a little-used Java EE
    Client type).  A single Maven project can house the development of
    a single EAR. The bulk of the project is solely within the pom.xml
    as nearly all of its contents are brought in through dependencies.

    [[1]] Create the sub-project directory for the EAR.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir javaeeExEAR
---

    [[1]] Add the initial entries for the EAR pom.xml.

    [Note:] It is important to note that the packaging type is "ear"
    in this case. If you leave this out, Maven will default to a 
    standard "jar" packaging type and not build the EAR correctly.

    []

---
$ cat javaeeExEAR/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <parent>
        <artifactId>javaeeEx</artifactId>
        <groupId>myorg.javaee</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeExEAR</artifactId>
    <packaging>ear</packaging>
    <name>Java EE Exercise EAR</name>
    <description>
        This project provides a sample EAR for the Java EE components
        associated with the overall project.
    </description>

    <dependencies>
    </dependencies>
</project>
---

    [[1]] Add the EJB dependency to the EAR. Use exclusions to keep
    any unwanted 3rd party .jars from being brought along.

---
    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>javaeeExEJB</artifactId>
            <version>${project.version}</version>
            <type>ejb</type>
            <exclusions>
                <!-- jboss doesn't want to see already provided jars -->
                <exclusion>
                    <groupId>commons-logging</groupId>
                    <artifactId>commons-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    ...
---

    [[1]] Verify the EAR builds.

---
$ (cd javaeeExEAR/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise EAR
[INFO]    task-segment: [clean, install]
[INFO] ------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] Deleting directory c:\proj\javaeeEx\javaeeExEAR\target
[INFO] [ear:generate-application-xml]
[INFO] Generating application.xml
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [ear:ear]
[INFO] Copying artifact[ejb:myorg.javaee:javaeeExEJB:1.0-SNAPSHOT] to[javaeeExEJB-1.0-SNAPSHOT.jar]
[INFO] Could not find manifest file: c:\proj\javaeeEx\javaeeExEAR\src\main\application\META-INF\MANIFEST.MF - Generating
 one
[INFO] Building jar: c:\proj\javaeeEx\javaeeExEAR\target\javaeeExEAR-1.0-SNAPSHOT.ear
[INFO] [install:install]
[INFO] Installing c:\proj\javaeeEx\javaeeExEAR\target\javaeeExEAR-1.0-SNAPSHOT.ear to c:\proj\repository.test\myorg\java
ee\javaeeExEAR\1.0-SNAPSHOT\javaeeExEAR-1.0-SNAPSHOT.ear
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Sun Mar 15 22:54:48 EDT 2009
[INFO] Final Memory: 5M/10M
[INFO] ------------------------------------------------------------------------
---

    [[1]] Verify the contents of the EAR has what you expect. EARs are required to
    have a META-INF/application.xml file that describes deployment details of
    the housed components. The Maven ear plugin will automatically generate this
    for you.

---
$ jar tf javaeeExEAR/target/javaeeExEAR-1.0-SNAPSHOT.ear
META-INF/
META-INF/MANIFEST.MF
javaeeExEJB-1.0-SNAPSHOT.jar
META-INF/application.xml
...
---
---
$ cat javaeeExEAR/target/application.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE application PUBLIC
        "-//Sun Microsystems, Inc.//DTD J2EE Application 1.3//EN"
        "http://java.sun.com/dtd/application_1_3.dtd">
<application>
  <display-name>javaeeExEAR</display-name>
  <description>This project provides a sample EAR for the Java EE components
        associated with the overall project.</description>
  <module>
    <ejb>javaeeExEJB-1.0-SNAPSHOT.jar</ejb>
  </module>
</application>
---

    [[1]] Add the EAR to the root level project and verify everything builds 
    from the root.

---
    <modules>
        <module>javaeeExEJB</module>
        <module>javaeeExEAR</module>
    </modules>
---
---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] Reactor build order:
[INFO]   Java EE Exercise
[INFO]   Java EE Exercise EJB
[INFO]   Java EE Exercise EAR
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise

...

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] Java EE Exercise ...................................... SUCCESS [2.391s]
[INFO] Java EE Exercise EJB .................................. SUCCESS [1.328s]
[INFO] Java EE Exercise EAR .................................. SUCCESS [0.406s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 4 seconds
[INFO] Finished at: Sun Mar 15 22:58:37 EDT 2009
[INFO] Final Memory: 12M/21M
[INFO] ------------------------------------------------------------------------
---

    [[1]] This is what our project looks like so far.

---
javaeeEx/
|-- javaeeExEAR
|   `-- pom.xml
|-- javaeeExEJB
|   |-- pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- myorg
|                   `-- javaeeex
|                       `-- ejb
|                           |-- RegistrarEJB.java
|                           |-- RegistrarLocal.java
|                           `-- RegistrarRemote.java
`-- pom.xml
---

* {Create the RMI Test Maven project}

    Any test we would have created within the EJB would have needed to
    test the EJB locally as if it were POJO business logic because it 
    is not until the EJB is deployed to the application server that
    it can be accessed and tested in its intended runtime environment.
    Therefore, we add an additional Maven project with a JUnit test and
    configurations to deploy and test the EJB from its RMI interface.
    The project will have no target artifact that we care about. One 
    could do some tweeking of the pom.xml to keep that from being 
    generated, but I have found that to only confuse Eclipse so we'll
    just live with and empty, unused RMI Test.jar.

    [[1]] Create the sub-project directory for the RMI Test.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir javaeeExTest
---

    [[1]] Create the pom.xml for the RMI Test module.

---
$ cat javaeeExTest/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <parent>
        <artifactId>javaeeEx</artifactId>
        <groupId>myorg.javaee</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeExTest</artifactId>
    <packaging>jar</packaging>
    <name>Java EE Exercise Remote Test</name>
    <description>
        This project provides an example RMI Test project.
    </description>

    <dependencies>
...
    </dependencies>

    <build>
...
    </build>

    <profiles>
...
    </profiles>
</project>
---

    [[1]] Add the dependencies required to use logging and JUnit.

---
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.0.4</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.6</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.13</version>
            <scope>test</scope>
        </dependency>
---

    [[1]] Configure the compiler plugin to use Java5.

---
    <build>
        <plugins>
              <!-- make sure we are building java5 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                </configuration>
            </plugin>
---

    [[1]] Add the dependencies required to be an RMI client of JBoss. We
    will use a convenient type=pom dependency provided by JBoss to define
    all required client dependencies in a single declaration.  We are
    using a profile in this case to cleary isolate the JBoss-specific
    aspects of this pom.xml file. You could also roll these dependencies
    up to the root level.

---
<profile>
    <id>jboss</id>
    <activation>
        <property>
            <name>!appserver</name>
        </property>
    </activation>
    <properties>
      <!-- more here later -->
    </properties>
    <repositories>
        <repository>
            <id>jboss-repo</id>
            <name>JBoss Maven Repository</name>
            <url>http://repository.jboss.org/maven2</url>
        </repository>
    </repositories>
    <dependencies>
        <dependency>
            <groupId>org.jboss.jbossas</groupId>
            <artifactId>jboss-as-client</artifactId>
            <version>5.1.0.GA</version>            
            <type>pom</type>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <!-- more here later -->
        </plugins>
    </build>
</profile>
---

    [[1]] Create a JNDI configuration for JBoss. Use variable references to 
    the server to better support different configurations.

---
$ mkdir -p javaeeExTest/src/test/resources

...

$ cat javaeeExTest/src/test/resources/jndi.properties
java.naming.factory.initial=${java.naming.factory.initial}
java.naming.provider.url=${java.naming.provider.url}
java.naming.factory.url.pkgs=${java.naming.factory.url.pkgs}
---

    [[1]] Add resource filtering to test resources in the pom.xml. This
    will cause the jndi.properties file to have variables replaces with 
    physical values when copied to the target tree.

---
    <build>
        <!-- filter test/resource files for profile-specific valies -->
        <testResources>
            <testResource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </testResource>
        </testResources>
---

    [[1]] Add definitions for the variables within the jboss profile.

---
<profile>
    <id>jboss</id>
...
    <properties>
          <java.naming.factory.initial>org.jnp.interfaces.NamingContextFactory
          </java.naming.factory.initial>
          <java.naming.provider.url>jnp://localhost:1099
          </java.naming.provider.url>
          <java.naming.factory.url.pkgs>org.jboss.naming:org.jnp.interfaces
          </java.naming.factory.url.pkgs>
    </properties>
    <dependencies>
---

    [[1]] Test the build of your RMI Test project so far. Note the values 
    for the jndi.properties file within the target/test-classes directory.
    If yours still has variable references check your configuration steps.

---
$ (cd javaeeExTest/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test

...

[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3 seconds
[INFO] Finished at: Sun Mar 15 23:27:07 EDT 2009
[INFO] Final Memory: 8M/16M
[INFO] ------------------------------------------------------------------------
---
---
$ cat javaeeExTest/target/test-classes/jndi.properties
java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=jnp://localhost:1099
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces
---

    [[1]] Create the JUnit test that will lookup the EJB and invoke the
    ping method. You will be tempted to directly reuse your business logic
    tests as implementation for the RMI Test. With proper refactoring and
    design, this can be done. However, realize that a remote interface must 
    have special design considerations addressed and may not always (even
    rarely) be the same as a local interface. Remote interfaces pass by value,
    are used in different JVMs with potentially different classpaths, and
    may have clients with different concerns. Technically, Java EE has allowed
    them to be the same, but that ends up biting you in the end.

---
package myorg.javaeeex.ejbclient;

import javax.naming.InitialContext;

import junit.framework.TestCase;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class RegistrarTest extends TestCase {
    Log log = LogFactory.getLog(RegistrarTest.class);
    InitialContext jndi;

    public void setUp() throws Exception {

        log.debug("getting jndi initial context");
        jndi = new InitialContext();
        log.debug("jndi=" + jndi.getEnvironment());
        jndi.lookup("/"); //do a quick comms check of JNDI
    }

    public void testPing() {
    }
---

    [[1]] Put a log4j.xml configuration in place.

---
$ cat javaeeExTest/src/test/resources/log4j.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">

<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/" debug="false">

   <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
         <param name="Target" value="System.out"/>

         <layout class="org.apache.log4j.PatternLayout">
            <!-- The default pattern: Date Priority [Category] Messagen -->
            <!--
            <param name="ConversionPattern" value="%d{ABSOLUTE} %-5p [%c{1}] %m%n"/>
            -->
            <param name="ConversionPattern" value=" -%m%n"/>
         </layout>
   </appender>

   <appender name="logfile" class="org.apache.log4j.RollingFileAppender">
      <param name="File" value="/tmp/log4j-out.txt"/>
      <param name="Append" value="false"/>
      <param name="MaxFileSize" value="100KB"/>
      <param name="MaxBackupIndex" value="1"/>
      <layout class="org.apache.log4j.PatternLayout">
         <param name="ConversionPattern" value="%-5p %d{dd-MM HH:mm:ss,SSS} [%c] (%F:%M:%L)  -%m%n"/>
      </layout>

   </appender>

   <logger name="myorg">
      <level value="debug"/>
   </logger>
   <root>
      <priority value="fatal"/>
      <appender-ref ref="CONSOLE"/>
   </root>

</log4j:configuration>
---

    [[1]] Try building and running the test without the JBoss
    server running.

---
$ (cd javaeeExTest/; mvn clean install)
...

Test set: myorg.javaeeex.ejbclient.RegistrarTest
 -------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 6.187 sec  FAILURE!
testPing(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 6.109 sec  ERROR!
javax.naming.CommunicationException: Could not obtain connection to any of these urls: localhost:1099 and discovery fail
ed with error: javax.naming.CommunicationException: Receive timed out [Root exception is java.net.SocketTimeoutException
: Receive timed out] [Root exception is javax.naming.CommunicationException: Failed to connect to server localhost:1099
[Root exception is javax.naming.ServiceUnavailableException: Failed to connect to server localhost:1099 [Root exception
is java.net.ConnectException: Connection refused: connect]]]
        at org.jnp.interfaces.NamingContext.checkRef(NamingContext.java:1562)
        at org.jnp.interfaces.NamingContext.lookup(NamingContext.java:634)
        at org.jnp.interfaces.NamingContext.lookup(NamingContext.java:627)
        at javax.naming.InitialContext.lookup(InitialContext.java:351)
---

* {Start JBoss Application Server}

    [Note:] JBoss provides several profiles for its application server. It's
    default profile is an optimized starting point. However, it is not 
    fully Java EE-compliant. They provide a standard configuration that is
    suppose to be fully Java EE-compliant. To use the non-default profiles, 
    we need to add a -c (profile-name) switch to the command line.

    []

    The EAR and its contents will be deployed to an application server to 
    provide a container with thread managemement, resource management,
    security, etc. 

    [[1]] Make the following edits to the jboss-log4j.xml file before
    we start the server. These edits will allow debug from our 
    EJB to be logged in the server output.

        * change the Theshold value for the CONSOLE from INFO to
        DEBUG

        * add a logger for org and com, with a level=INFO so that the 
        change to CONSOLE does not cause org.* class output to
        overwhelm the console.

        * add logger entries for myorg and the ejava class examples.

---
$ cat server/standard/conf/jboss-log4j.xml

...
   <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
      <errorHandler class="org.jboss.logging.util.OnlyOnceErrorHandler"/>
      <param name="Target" value="System.out"/>
      <param name="Threshold" value="DEBUG"/>

      <layout class="org.apache.log4j.PatternLayout">
         <!-- The default pattern: Date Priority [Category] Message\n -->
         <param name="ConversionPattern" value="%d{ABSOLUTE} %-5p [%c{1}] %m%n"/>
      </layout>
   </appender>

   <logger name="myorg">
       <level value="debug"/>
   </logger>
   <logger name="ejava">
       <level value="debug"/>
   </logger>
   <logger name="org">
       <level value="info"/>
   </logger>
   <logger name="com">
       <level value="info"/>
   </logger>
---


    [[1]] Start the JBoss server.

---
$ pwd
/cygdrive/c/apps/jboss-5.1.0.GA

$ ./bin/run.sh -c standard
Calling C:\apps\jboss-5.1.0.GA\bin\run.conf.bat
===============================================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: C:\apps\jboss-5.1.0.GA

  JAVA: c:\apps\java\jdk1.5.0_17\bin\java

  JAVA_OPTS: -Dprogram.name=run.bat -Xms128M -Xmx512M -XX:MaxPermSize=256M -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000 -Dorg.jboss.resolver.warning=true -server

  CLASSPATH: C:\apps\jboss-5.1.0.GA\bin\run.jar

===============================================================================

18:10:34,218 INFO  [ServerImpl] Starting JBoss (Microcontainer)...

...

19:29:53,703 INFO  [Http11Protocol] Starting Coyote HTTP/1.1 on http-127.0.0.1-8080
19:29:53,734 INFO  [AjpProtocol] Starting Coyote AJP/1.3 on ajp-127.0.0.1-8009
19:29:53,750 INFO  [ServerImpl] JBoss (Microcontainer) [5.1.0.GA (build: SVNTag=JBoss_5_1_0_GA date=200905221053)] Started in 53s:141ms
---

    [[1]] Re-run the RMI Test again.

---
$ (cd javaeeExTest/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test

...

 T E S T S
 -------------------------------------------------------
Running myorg.javaeeex.ejbclient.RegistrarTest
 -getting jndi initial context
 -jndi={jnp.parsedName=, java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory, java.naming.provider.url=l
ocalhost:1099, java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces}
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.313 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] [jar:jar]
[WARNING] JAR will be empty - no content was marked for inclusion!
[INFO] Building jar: c:\proj\javaeeEx\javaeeExTest\target\javaeeExTest-1.0-SNAPSHOT.jar
[INFO] [install:install]
[INFO] Installing c:\proj\javaeeEx\javaeeExTest\target\javaeeExTest-1.0-SNAPSHOT.jar to c:\proj\repository.test\myorg\ja
vaee\javaeeExTest\1.0-SNAPSHOT\javaeeExTest-1.0-SNAPSHOT.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
...
---

* {Deploy the Application}

    We want tests to run as automated as possible. This allows us to 
    simplify testing as well as leverage continous integration techniques
    (e.g., CruiseControl; i.e., nightly builds/tests). To help automate this
    we are going to leverage the Maven cargo plugin. Cargo, itself, is a
    Java library that is used to manage Java EE containers. The maven
    cargo plugin just makes it callable from within Maven. We will add the
    cargo plugin to the RMI Test project (to deploy the application) since
    the application isn't ready to be deployed until after the EAR is built.

    [[1]] Add the cargo plugin to the RMI Test to deploy the EAR
    to JBoss. This configuration goes in the jboss area of the RMI
    Test's pom.xml.

---
    <build>
        <plugins>

        <plugin>
            <groupId>org.codehaus.cargo</groupId>
            <artifactId>cargo-maven2-plugin</artifactId>
            <version>1.0.2</version>
            <configuration>
                <container>
                    <containerId>jboss5x</containerId>
                    <type>remote</type>
                </container>
            </configuration>
            <executions>
                <execution>
                    <id>deploy-component</id>
                    <!-- jump into a phase before surefire runs tests -->
                    <phase>test-compile</phase>
                    <goals>
                        <goal>undeploy</goal>
                        <goal>deploy</goal>
                    </goals>
                    <configuration>
                        <configuration>
                            <type>runtime</type>
                            <properties>
                            <cargo.remote.username>${jboss.user}</cargo.remote.username>
                            <cargo.remote.password>${jboss.password}</cargo.remote.password>
                            </properties>
                        </configuration>
                        <deployer>
                            <type>remote</type>
                            <deployables>
                                <deployable>
                                    <groupId>${project.groupId}</groupId>
                                    <artifactId>javaeeExEAR</artifactId>
                                    <type>ear</type>
                                </deployable>
                            </deployables>
                        </deployer>
                    </configuration>
                </execution>
            </executions>
        </plugin>
---

    [[1]] You will also need to add a dependency on the EAR from the RMI Test
    to satisfy the above plugin. This goes in the root dependency section.

---
    </description>

    <dependencies>
        <!-- package being deployed must be a 'compile' dependency
            for cargo to be able to deploy it
                -->
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>javaeeExEAR</artifactId>
            <version>${project.version}</version>
            <type>ear</type>
            <scope>compile</scope>
        </dependency>
---

    [[1]] Rebuild the RMI Test and note the deployment of the EAR to the JBoss
    server.

---
$ (cd javaeeExTest/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test

...

[INFO] [cargo:undeploy {execution: deploy-component}]
[INFO] [cargo:deploy {execution: deploy-component}]
...
---
---
//SERVER LOG
00:00:06,906 INFO  [EJBContainer] STARTED EJB: myorg.javaeeex.ejb.RegistrarEJB ejbName: RegistrarEJB
00:00:06,953 INFO  [EJB3Deployer] Deployed: file:/C:/apps/jboss-4.2.3.GA/server/default/tmp/deploy/tmp767856868280374431
3javaeeExEAR-1.0-SNAPSHOT.ear-contents/javaeeExEJB-1.0-SNAPSHOT.jar
00:00:06,984 INFO  [EARDeployer] Started J2EE application: file:/C:/proj/repository.test/myorg/javaee/javaeeExEAR/1.0-SN
APSHOT/javaeeExEAR-1.0-SNAPSHOT.ear
---

* {Setup JNDI access to Remote interface}

    Each EJB interface will have an entry in the JNDI tree. Clients will use
    the JNDI tree to locate the interface object they need based on 
    a hierarchical name.

    [[1]] Look for the JNDI name of the EJB in the jmx-console.

        * Navigate to http://localhost:8080/jmx-console/ in your browser

        * Click on service=JNDIView

        * Click on Invoke under list()

        * Note the JNDI names for the RegistrarEJB under the Global
        JNDI Namespace. 

---
Global JNDI Namespace

  +- javaeeExEAR-1.0-SNAPSHOT (class: org.jnp.interfaces.NamingContext)
  |   +- RegistrarEJB (class: org.jnp.interfaces.NamingContext)
  |   |   +- local (proxy: $Proxy69 implements interface myorg.javaeeex.ejb.RegistrarLocal,interface org.jboss.ejb3.JBossProxy)
  |   |   +- remote (proxy: $Proxy67 implements interface myorg.javaeeex.ejb.RegistrarRemote,interface org.jboss.ejb3.JBossProxy)
---

    [[1]] Add the above JNDI name for the @Remote interface in the 
    RMI Test surefire configuration.

---
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <argLine>${surefire.argLine}</argLine>
                    <systemProperties>
                        <property>
                          <name>jndi.name.registrar</name>
                          <value>
                              javaeeExEAR-1.0-SNAPSHOT/RegistrarEJB/remote
                          </value>
                        </property>
                    </systemProperties>
                </configuration>
            </plugin>
---

    [[1]] Add the dependency on the ejb-client.jar to the RMI Test.
    This will go in the root dependency area.

---
        <!-- contains remote interfaces
        -->
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>javaeeExEJB</artifactId>
            <version>${project.version}</version>
            <type>ejb-client</type>
            <scope>test</scope>
        </dependency>
---

    [[1]] Add the handling of the JNDI name property and the testing
    of the lookup to the JUnit test.

---
...
import myorg.javaeeex.ejb.RegistrarRemote;
...

public class RegistrarTest extends TestCase {
...
    String registrarJNDI = System.getProperty("jndi.name.registrar");
    RegistrarRemote registrar;

    public void setUp() throws Exception {
        assertNotNull("jndi.name.registrar not supplied", registrarJNDI);

        ...

        log.debug("jndi name:" + registrarJNDI);
        registrar = (RegistrarRemote)jndi.lookup(registrarJNDI);
    }
---

    [[1]] Rebuild the RMI Test and note the attempt and staus of 
    the JNDI lookup of the EJB. 

---
$ (cd javaeeExTest/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test

...

 T E S T S
 -------------------------------------------------------
Running myorg.javaeeex.ejbclient.RegistrarTest
 -getting jndi initial context
 -jndi={jnp.parsedName=, java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory, java.naming.provider.url=l
ocalhost:1099, java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces}
 -jndi name:javaeeExEAR-1.0-SNAPSHOT/RegistrarEJB/remote
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.297 sec

...
---

* {Invoke EJB method through Remote interface}

    [[1]] Enhance the testPing() method to invoke the ping() method
    of the EJB.

---
    public void testPing() {
        log.info("*** testPing ***");
        registrar.ping();
    }
---

    [[1]] Rebuild the RMI Test. Note the processing and status of the 
    testPing() method as well as the output from the server-side EJB.

---
$ (cd javaeeExTest/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test

...

 -*** testPing ***
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.468 sec
...
---
---
//SERVER LOG
00:17:52,750 DEBUG [RegistrarEJB] **** init ****
00:17:52,765 DEBUG [RegistrarEJB] ping called
---

* {Add a few finishing touches}

    There are two semi-related things we need to do; add the RMI Test to 
    the root project and provide a clean-only undeploy of the EAR. 
    
    When we add the RMI Test to the root project, we do so with some caution.
    This module only has tests and requires JBoss to be running. There
    are times when we want the application built without running tests
    and may do so by using -Dmaven.test.skip=true. We can leverage this
    common technique by placing the RMI Test within a profile that gets 
    deactivated when not testing the application.

    The other aspect we'd like to add is the ability to undeploy an EAR
    during the clean goal. This is helpful when deploying and testing
    multiple applications at a set. It is impossible to undeploy, build,
    and re-deploy an application if sibling applications depend on 
    classes it provides when using the default JBoss common classloader
    (i.e., all EARs are sharing the same class loader).


    [[1]] Add the RMI Test to the parent pom.xml configuration. However,
    add it within a profile to keep it from running if we ever invoke
    the build with maven.test.skip=true.

---
    </modules>

    <profiles>
        <profile>
            <id>functional-tests</id>
            <activation>
                <property>
                    <name>!maven.test.skip</name>
                </property>
            </activation>
            <modules>
                <module>javaeeExTest</module>
            </modules>
        </profile>
    </profiles>
---

    [[1]] Re-run the build from the root project. If you have deployed the EAR
    from within the RMI Test directory above without restaring JBoss, you will
    encounter an error shown in the later output below. This is because the 
    application we deployed under the same name using a different relative
    path. You can either restart JBoss or re-issue the build 3 times. The 
    3rd time fully clears and works. This error only occurs when you switch 
    directories. If you always build from the root, it will remain constant.

    [Note:] I have noticed that JBoss 5 is not as forgiving as earlier versions
    and the 3-time rule may not apply. Run "mvn clean -Pundeploy" before changing
    directories.

    []

---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] Reactor build order:
[INFO]   Java EE Exercise
[INFO]   Java EE Exercise EJB
[INFO]   Java EE Exercise EAR
[INFO]   Java EE Exercise Remote Test
[INFO] ------------------------------------------------------------------------

...

[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] Java EE Exercise ...................................... SUCCESS [2.516s]
[INFO] Java EE Exercise EJB .................................. SUCCESS [1.437s]
[INFO] Java EE Exercise EAR .................................. SUCCESS [0.422s]
[INFO] Java EE Exercise Remote Test .......................... SUCCESS [4.031s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 8 seconds
---

---
[INFO] Trace
org.codehaus.cargo.container.ContainerException: Failed to deploy to [http://localhost:8080/jmx-console/HtmlAdaptor?acti
on=invokeOpByName&name=jboss.system:service%3DMainDeployer&methodName=deploy&argType=java.net.URL&arg0=file:C%3A%5Cproj%
5CjavaeeEx%5CjavaeeExEAR%5Ctarget%5CjavaeeExEAR-1.0-SNAPSHOT.ear]


//SERVER LOG
00:35:03,078 ERROR [[HtmlAdaptor]] Servlet.service() for servlet HtmlAdaptor threw exception
javax.management.InstanceAlreadyExistsException: jboss.j2ee:service=EARDeployment,url='javaeeExEAR-1.0-SNAPSHOT.ear' alr
eady registered.
---

    [[1]] Lets make one more enhancement to the project shell to allow the option to undeploy an EAR from
    the application server as a part of the clean goal. This is useful when you have multiple
    EARs and want all uninstalled during the clean and then have them rebuilt and re-installed
    as a part of a later install. If we left it the way we have it, we would get a series
    of clean+install (for EAR 1), clean+install (from EAR 2), etc. instead of clean (for EAR 1), clean
    (from EAR 2), install (for EAR 1), and install (for EAR 2). To allow for this, add the following 
    plugin definition to the EAR/pom.xml.

---
    </dependencies>

    <profiles>
        <!-- this profiles allow the EAR to be undeployed before it is deleted
            during the clean target. This behavior requires the EAR to be
            present, so it cannot be part of the default behavior. It is
            only activated when -Dundeploy or -Pundeploy is present so that
            normal cleans do not fail.  -->
    <profile>
        <id>undeploy</id>
        <activation>
            <property>
                <name>undeploy</name>
                <value>true</value>
            </property>
        </activation>
        <build>
            <plugins>
            <plugin>
                <groupId>org.codehaus.cargo</groupId>
                <artifactId>cargo-maven2-plugin</artifactId>
                <version>1.0.2</version>
                <configuration>
                    <container>
                        <containerId>jboss5x</containerId>
                        <type>remote</type>
                    </container>
                </configuration>
                <executions>
                    <execution>
                        <id>undeploy-ear</id>
                        <phase>pre-clean</phase>
                        <goals>
                            <goal>undeploy</goal>
                        </goals>
                        <configuration>
                            <configuration>
                                <type>runtime</type>
                                <properties>
                                <cargo.remote.username>${jboss.user}</cargo.remote.username>
                                <cargo.remote.password>${jboss.password}</cargo.remote.password>
                                </properties>
                            </configuration>
                            <deployer>
                                <type>remote</type>
                                <deployables>
                                    <deployable>
                                        <groupId>${project.groupId}</groupId>
                                        <artifactId>${project.artifactId}</artifactId>
                                        <type>ear</type>
                                    </deployable>
                                </deployables>
                            </deployer>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            </plugins>
        </build>
    </profile>
        </profiles>
</project>
---

    [[1]] Run the clean target and activate the new plugin configuration.

---
StaffordJ@takedown /cygdrive/c/proj/ejava-javaee/working/solutions/javaeeEx/partA
$ mvn clean -Pundeploy
[INFO] Scanning for projects...
[INFO] Reactor build order:
[INFO]   Java EE Exercise
[INFO]   Java EE Exercise EJB
[INFO]   Java EE Exercise EAR
[INFO]   Java EE Exercise Remote Test

...

[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise EAR
[INFO]    task-segment: [clean]
[INFO] ------------------------------------------------------------------------
[INFO] [cargo:undeploy {execution: undeploy-ear}]
[INFO] [clean:clean]
[INFO] ------------------------------------------------------------------------

...

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] Java EE Exercise ...................................... SUCCESS [0.547s]
[INFO] Java EE Exercise EJB .................................. SUCCESS [0.157s]
[INFO] Java EE Exercise EAR .................................. SUCCESS [1.953s]
[INFO] Java EE Exercise Remote Test .......................... SUCCESS [0.093s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3 seconds
[INFO] Finished at: Tue Mar 17 22:26:35 EDT 2009
[INFO] Final Memory: 6M/12M
[INFO] ------------------------------------------------------------------------
---

---
//SERVER LOG

19:39:23,015 INFO  [SessionSpecContainer] Starting jboss.j2ee:ear=javaeeExEAR-1.0-SNAPSHOT.ear,jar=javaeeExEJB-1.0-SNAPSHOT.jar,name=RegistrarEJB,service=EJB3
19:39:23,015 INFO  [EJBContainer] STARTED EJB: myorg.javaeeex.ejb.RegistrarEJB ejbName: RegistrarEJB
19:39:23,046 INFO  [JndiSessionRegistrarBase] Binding the following Entries in Global JNDI:

        javaeeExEAR-1.0-SNAPSHOT/RegistrarEJB/remote - EJB3.x Default Remote Business Interface
        javaeeExEAR-1.0-SNAPSHOT/RegistrarEJB/remote-myorg.javaeeex.ejb.RegistrarRemote - EJB3.x Remote Business Interface
        javaeeExEAR-1.0-SNAPSHOT/RegistrarEJB/local - EJB3.x Default Local Business Interface
        javaeeExEAR-1.0-SNAPSHOT/RegistrarEJB/local-myorg.javaeeex.ejb.RegistrarLocal - EJB3.x Local Business Interface

19:39:24,421 WARN  [InterceptorsFactory] EJBTHREE-1246: Do not use InterceptorsFactory with a ManagedObjectAdvisor, InterceptorRegistry should be used via the bean container
19:39:24,421 WARN  [InterceptorsFactory] EJBTHREE-1246: Do not use InterceptorsFactory with a ManagedObjectAdvisor, InterceptorRegistry should be used via the bean container
---



    [[1]] This is what we ended up with.

---
javaeeEx/
|-- javaeeExEAR
|   `-- pom.xml
|-- javaeeExEJB
|   |-- pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- myorg
|                   `-- javaeeex
|                       `-- ejb
|                           |-- RegistrarEJB.java
|                           |-- RegistrarLocal.java
|                           `-- RegistrarRemote.java
|-- javaeeExTest
|   |-- pom.xml
|   `-- src
|       `-- test
|           |-- java
|           |   `-- myorg
|           |       `-- javaeeex
|           |           `-- ejbclient
|           |               `-- RegistrarTest.java
|           `-- resources
|               |-- jndi.properties
|               `-- log4j.xml
`-- pom.xml
---

    []

* Summary

    * In this exercise, we created a shell of an EJB, EAR, RMI Test, and
    Maven infrastructure that can be used as the basis for adding the 
    details of our application. Some things that we did were

        * created a @Stateless EJB with a @Remote and @Local interface,
        @PostConstruct and @PreDestroy callbacks, and a single ping()
        method.

        * created an EAR to house the EJB.

        * created an RMI Test project to deploy and test the EJB. The
        RMI Test was configured with the cargo plugin for the deployment.
        It contained a jndi.properties file to locate the JBoss JNDI
        tree. It contained a surefire configuration to locate the @Remote
        interface of the EJB in the JNDI tree and ultimately invoked the
        ping() method of the EJB.

