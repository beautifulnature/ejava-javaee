Java EE Exercise 

Part A: Create Project Shell

* Objectives

    * Create and deploy an EAR with a bare bones EJB.

        * {{{Create_the_root_Maven_project}
            Create the root Maven project
            }}

        * {{{Create_the_EJB_Maven_project}
            Create the EJB Maven project
            }}

        * {{{Create_the_EAR_Maven_project}
            Create the EAR Maven project
            }}

    * Create and run an RMI Test that will locate the JNDI tree,
    lookup the EJBs remote interface, and invoke a simple method.

        * {{{Create_the_RMI_Test_Maven_project}
            Create the RMI Test Maven project
            }}

        * {{{Start_JBoss_Application_Server}
            Start JBoss Application Server
            }}

        * {{{Deploy_the_Application}
            Deploy the Application
            }}

        * {{{Setup_JNDI_access_to_Remote_interface}
            Setup JNDI access to @Remote interface
            }}

        * {{{Invoke_EJB_method_through_Remote_interface}
            Invoke EJB method through @Remote interface
            }}

        * {{{Add_a_few_finishing_touches}
            Add a few finishing touches
            }}


* {Create the root Maven project}

    Each component of the Java EE application will be developed as 
    as a separate Maven module. Each module will be placed in a 
    flat structure under a common parent project. This parent project
    will be used to coordinate goals involved of the entire application.
    The order in which it builds things can be influenced by the 
    configuration you supply, however, maven will analyze dependencies
    at build time and either honor the actual dependency ordering or fail
    if you have expressed a circular dependency.

    [[1]] Create a root directory for the exercise. This will host
    the root project and sub-projects for the Impl, EJB, WAR, EAR,
    and RMI Test modules.

---
$pwd
/cygdrive/c/proj
$ mkdir javaeeEx
---

    [[1]] Create a root project pom.xml file. This project will 
    will not have an associated artifact and is termed a "reactor"
    project. It uses a special packaging type called "pom".

    [Note:] It is very important that you realize that the packaging
    type is "pom" in this case. If you leave out this specification,
    Maven will default to packaging=jar type and attempt to build a
    Java-based artifact and ignore its responsibility in this 
    project to be the root project to delegate to the child 
    projects that build artifacts.

    []

---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeEx</artifactId>
    <packaging>pom</packaging>
    <name>Java EE Exercise</name>
    <version>1.0-SNAPSHOT</version>
    <description>
        This project is the root project for the example Java EE
        Application.
    </description>
    <modules>
    </modules>

    <profiles>
    </profiles>
</project>
---

    [[1]] Test your root project by building it at this time.

---
$ mvn clean install
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ javaeeEx ---
[INFO] 
[INFO] --- maven-install-plugin:2.3.1:install (default-install) @ javaeeEx ---
[INFO] Installing /home/jcstaff/solutions/javaeeEx/pom.xml to /home/jcstaff/.m2/repository3/myorg/javaee/javaeeEx/1.0-SNAPSHOT/javaeeEx-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.807s
[INFO] Finished at: Mon Feb 28 20:43:32 EST 2011
[INFO] Final Memory: 2M/57M
[INFO] ------------------------------------------------------------------------

---

* {Create the EJB Maven project}

    The EJB project will be used to develop one of the EJB components. The
    term "EJB" gets a little overloaded at times.  There are EJB
    classes, EJB components, and an EJB tier.  EJB classes break out
    into the business-remote (aka @Remote) and business-local (aka
    @Local) interfaces, the EJB implementation class (either @Stateless,
    @Stateful, or @MessageDriven), and support classes. It is common to
    think of each cohesive pairing of @Remote, @Local, and implementation
    class as "an EJB".  You can have many EJBs (the sets of classes)
    within an EJB component. An EJB component is a materialized as a .jar
    and there can be many EJB components within your EJB tier. For this
    exercise we will have only one EJB component and start out with only
    one EJB.  A second EJB will be added to the single EJB component in
    a later excercise to help support testing.  A single Maven project
    can build a single EJB component.


    [[1]] Add an EJB project directory to your project tree.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir javaeeExEJB
---

    [[1]] Add the outer shell of the EJB module's pom.xml. 

    [Note:] It is important to note that the packaging type is "ejb" in this
    case. If you leave out the packaging type, Maven will default to "jar"
    and not handle your module appropriately within the context of a Java EE
    application.

    []

---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <parent>
        <artifactId>javaeeEx</artifactId>
        <groupId>myorg.javaee</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeExEJB</artifactId>
    <packaging>ejb</packaging>
    <name>Java EE Exercise EJB</name>
    <description>
        This project provides example usages of an EJB tier.
    </description>

    <dependencies>
    </dependencies>

    <build>
        <plugins>
        </plugins>
    </build>
</project>
---

    [[1]] Add in the maven-compiler-plugin specification to make sure JDK
    1.5 or 1.6 is used.

---
    <build>
        <plugins>
              <!-- make sure we are building jdk5 or jdk6 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
    ...
---

    [[1]] Add in the maven-ejb-plugin specification to configure it
    for EJB Version 3.0.  We will also add a few more details.

        * tell is explicitly to use EJB 3.0 versus the legacy EJB 2.1
        approach. There are many changes between the two approaches
        so we need to make sure we are set correctly. 
    
        * tell it to add all dependencies with scope=compile 
        to the Class-Path in the META-INF/MANIFEST.MF. This is a 
        pure Java construct that JavaEE takes advantage of in 
        order to resolve dependencies on the server. 

        * tell it to create a ejb-client.jar file for remote clients.
        This will be populated using a set of include and exclude 
        paths. In this case, we are telling it not to include any
        of our deployment descriptors in the META-INF directory as
        well as leaving out our EJB implemenation class.

---
          <!-- tell the EJB plugin we are using EJB3  and configure client-jar -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-ejb-plugin</artifactId>
            <version>2.3</version>
            <configuration>
                <ejbVersion>3.0</ejbVersion>
                <archive>
                    <manifest>
                        <addClasspath>true</addClasspath>
                    </manifest>
                </archive>
                <generateClient>true</generateClient>
                <clientExcludes>
                    <clientExclude>**/META-INF/*.xml</clientExclude>
                    <clientExclude>**/ejb/*EJB.class</clientExclude>
                </clientExcludes>
            </configuration>
        </plugin>
    </plugins>
</build>
---

    [[1]] Add several dependencies to account for use of logging, 
    annotations, and EJB constructs. Since we will be instantiating
    this code only on the server and not in a 2-tier approach,
    the pure JavaEE API from Sun/Oracle will do fine. Otherwise we
    should use the dependencies from Hibernate/JBoss.

    [Note:] You should always declare a scope=provided dependency
    on the JavaEE API artifacts so that downstream clients of the
    module are free to supply their own version/provider of the 
    API.

    []

---
    <!-- this repository holds many of the javaee jar files -->
    <repositories>
        <repository>
            <id>java.net-repo</id>
            <name>Java.net Maven Repository</name>
            <url>http://download.java.net/maven/2</url>
        </repository>
    </repositories>

    <dependencies>
        <!-- core dependencies -->
        <dependency>
            <groupId>javax</groupId>
            <artifactId>javaee-api</artifactId>
            <version>6.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
          <groupId>commons-logging</groupId>
          <artifactId>commons-logging</artifactId>
          <version>1.0.4</version>
          <scope>provided</scope>
        </dependency>
---

    [[1]] Create the src tree for the EJB.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir -p javaeeExEJB/src/main/java/myorg/javaeeex/ejb/
---


    [[1]] Add the beginning @Remote and @Local interfaces. Please 
    a simple ping() method in the @Remote interface for use as an
    end-to-end sanity check at the end of this exercise.

---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarRemote.java
package myorg.javaeeex.ejb;

import javax.ejb.Remote;

@Remote
public interface RegistrarRemote {
    void ping();
}
---
---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarLocal.java
package myorg.javaeeex.ejb;

import javax.ejb.Local;

@Local
public interface RegistrarLocal {
}
---

    [[1]] Add the beginning of a @Stateless EJB that will implement
    the provided @Remote and @Local interfaces. Implement @PostConstruct
    @PreDestroy callbacks to intercept EJB lifecycle events. Add a 
    logger and log statements to the methods so we can observe activity
    within the EJB during the test at the end of this exercise.

---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarEJB.java
package myorg.javaeeex.ejb;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.ejb.Stateless;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


@Stateless
public class RegistrarEJB implements RegistrarLocal, RegistrarRemote {
    private static Log log = LogFactory.getLog(RegistrarEJB.class);


    @PostConstruct
    public void init() {
        log.debug("**** init ****");
    }

    @PreDestroy
    public void close() {
        log.debug("*** close() ***");
    }

    public void ping() {
        log.debug("ping called");
    }
}
---


    [[1]] The EJB can be built at this time. You will notice the following
    in the output.

        * Our 3 Java files (@Remote, @Local, and @Stateless) were compiled

        * EJB 3 processing was performed on the target. This largely 
        consisted only of MANIFEST Class-Path processing and the construction
        of an ejb-client.jar file at this point.


---
$ (cd javaeeExEJB/; mvn clean install)
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise EJB 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
...
There are no tests to run.

Results :

Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

[INFO] 
[INFO] --- maven-ejb-plugin:2.3:ejb (default-ejb) @ javaeeExEJB ---
[INFO] Building EJB javaeeExEJB-1.0-SNAPSHOT with EJB version 3.0
[INFO] Building jar: /home/jcstaff/solutions/javaeeEx/javaeeExEJB/target/javaeeExEJB-1.0-SNAPSHOT.jar
[INFO] Building EJB client javaeeExEJB-1.0-SNAPSHOT-client
[INFO] Building jar: /home/jcstaff/solutions/javaeeEx/javaeeExEJB/target/javaeeExEJB-1.0-SNAPSHOT-client.jar
[INFO] 
[INFO] --- maven-install-plugin:2.3.1:install (default-install) @ javaeeExEJB ---
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExEJB/target/javaeeExEJB-1.0-SNAPSHOT.jar to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExEJB/1.0-SNAPSHOT/javaeeExEJB-1.0-SNAPSHOT.jar
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExEJB/pom.xml to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExEJB/1.0-SNAPSHOT/javaeeExEJB-1.0-SNAPSHOT.pom
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExEJB/target/javaeeExEJB-1.0-SNAPSHOT-client.jar to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExEJB/1.0-SNAPSHOT/javaeeExEJB-1.0-SNAPSHOT-client.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 10.853s
[INFO] Finished at: Mon Feb 28 21:30:35 EST 2011
[INFO] Final Memory: 8M/128M
[INFO] ------------------------------------------------------------------------
---

    [[1]] Add the EJB module to the root pom.xml.

---
    <modules>
        <module>javaeeExEJB</module>
    </modules>
---

    [[1]] Retest the build from the root.

---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO] 
[INFO] Java EE Exercise
[INFO] Java EE Exercise EJB
...
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise .................................. SUCCESS [1.405s]
[INFO] Java EE Exercise EJB .............................. SUCCESS [9.130s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 10.898s
[INFO] Finished at: Mon Feb 28 21:34:41 EST 2011
[INFO] Final Memory: 8M/128M
---

    [[1]] Verify this is what you have so far.

---
javaeeEx/
|-- javaeeExEJB
|   |-- pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- myorg
|                   `-- javaeeex
|                       `-- ejb
|                           |-- RegistrarEJB.java
|                           |-- RegistrarLocal.java
|                           `-- RegistrarRemote.java
`-- pom.xml
---

* {Create the EAR Maven project}

    EARs are Java archives that are used to house the overall application,
    with all of its components. The EAR can contain many EJB and WAR
    components as well as their dependencies (and a little-used Java EE
    Client type).  A single Maven project can house the development of
    a single EAR. The bulk of the project is solely within the pom.xml
    as nearly all of its contents are brought in through dependencies.

    [[1]] Create the sub-project directory for the EAR.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir javaeeExEAR
---

    [[1]] Add the initial entries for the EAR pom.xml.

    [Note:] It is important to note that the packaging type is "ear"
    in this case. If you leave this out, Maven will default to a 
    standard "jar" packaging type and not build the EAR correctly.

    []

---
$ cat javaeeExEAR/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <parent>
        <artifactId>javaeeEx</artifactId>
        <groupId>myorg.javaee</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeExEAR</artifactId>
    <packaging>ear</packaging>
    <name>Java EE Exercise EAR</name>
    <description>
        This project provides a sample EAR for the Java EE components
        associated with the overall project.
    </description>

    <dependencies>
    </dependencies>
</project>
---

    [[1]] Add the EJB dependency to the EAR. Use exclusions to keep
    any unwanted 3rd party .jars from being brought along.

---
    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>javaeeExEJB</artifactId>
            <version>${project.version}</version>
            <type>ejb</type>
            <exclusions>
                <!-- jboss doesn't want to see already provided jars -->
                <exclusion>
                    <groupId>commons-logging</groupId>
                    <artifactId>commons-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    ...
---

    [[1]] Verify the EAR builds.

---
$ (cd javaeeExEAR/; mvn clean install)
[INFO] Scanning for projects...                                                                                                  
[INFO]                                                                                                                           
[INFO] ------------------------------------------------------------------------                                                  
[INFO] Building Java EE Exercise EAR 1.0-SNAPSHOT                                                                                
[INFO] ------------------------------------------------------------------------                                                  
Downloading: http://download.java.net/maven/2/myorg/javaee/javaeeEx/1.0-SNAPSHOT/maven-metadata.xml                              
[INFO]                                                                                                                           
[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ javaeeExEAR ---                                                      
[INFO] Deleting /home/jcstaff/solutions/javaeeEx/javaeeExEAR/target                                                              
[INFO]                                                                                                                           
[INFO] --- maven-ear-plugin:2.4.2:generate-application-xml (default-generate-application-xml) @ javaeeExEAR ---                  
[INFO] Generating application.xml                                                                                                
[INFO]                                                                                                                           
[INFO] --- maven-resources-plugin:2.4.3:resources (default-resources) @ javaeeExEAR ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /home/jcstaff/solutions/javaeeEx/javaeeExEAR/src/main/resources
[INFO] 
[INFO] --- maven-ear-plugin:2.4.2:ear (default-ear) @ javaeeExEAR ---
[INFO] Copying artifact[ejb:myorg.javaee:javaeeExEJB:1.0-SNAPSHOT] to[javaeeExEJB-1.0-SNAPSHOT.jar]
[INFO] Could not find manifest file: /home/jcstaff/solutions/javaeeEx/javaeeExEAR/target/javaeeExEAR-1.0-SNAPSHOT/META-INF/MANIFEST.MF - Generating one
[INFO] Building jar: /home/jcstaff/solutions/javaeeEx/javaeeExEAR/target/javaeeExEAR-1.0-SNAPSHOT.ear
[INFO] 
[INFO] --- maven-install-plugin:2.3.1:install (default-install) @ javaeeExEAR ---
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExEAR/target/javaeeExEAR-1.0-SNAPSHOT.ear to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExEAR/1.0-SNAPSHOT/javaeeExEAR-1.0-SNAPSHOT.ear
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExEAR/pom.xml to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExEAR/1.0-SNAPSHOT/javaeeExEAR-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.413s
[INFO] Finished at: Tue Mar 01 22:33:15 EST 2011
[INFO] Final Memory: 4M/82M
[INFO] ------------------------------------------------------------------------
---

    [[1]] Verify the contents of the EAR has what you expect. EARs are required to
    have a META-INF/application.xml file that describes deployment details of
    the housed components. The Maven ear plugin will automatically generate this
    for you.

---
$ jar tf javaeeExEAR/target/javaeeExEAR-1.0-SNAPSHOT.ear 
...
META-INF/application.xml
javaeeExEJB-1.0-SNAPSHOT.jar
...
---
---
$ cat javaeeExEAR/target/application.xml 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE application PUBLIC
        "-//Sun Microsystems, Inc.//DTD J2EE Application 1.3//EN"
        "http://java.sun.com/dtd/application_1_3.dtd">
<application>
  <display-name>javaeeExEAR</display-name>
  <description>This project provides a sample EAR for the Java EE components
        associated with the overall project.</description>
  <module>
    <ejb>javaeeExEJB-1.0-SNAPSHOT.jar</ejb>
  </module>
---

    [[1]] Add the EAR to the root level project and verify everything builds 
    from the root.

---
    <modules>
        <module>javaeeExEJB</module>
        <module>javaeeExEAR</module>
    </modules>
---
---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO] 
[INFO] Java EE Exercise
[INFO] Java EE Exercise EJB
[INFO] Java EE Exercise EAR
[INFO]                                                                         

...
...

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise .................................. SUCCESS [0.644s]
[INFO] Java EE Exercise EJB .............................. SUCCESS [4.099s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [0.661s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.597s
[INFO] Finished at: Tue Mar 01 22:37:59 EST 2011
[INFO] Final Memory: 8M/128M
[INFO] ------------------------------------------------------------------------
---

    [[1]] This is what our project looks like so far.

---
javaeeEx/
|-- javaeeExEAR
|   `-- pom.xml
|-- javaeeExEJB
|   |-- pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- myorg
|                   `-- javaeeex
|                       `-- ejb
|                           |-- RegistrarEJB.java
|                           |-- RegistrarLocal.java
|                           `-- RegistrarRemote.java
`-- pom.xml
---

* {Create the RMI Test Maven project}

    Any tests we implement within the EJB module itself would likely
    be a POJO-level unit test. EJB 3.1 does provide a means to create
    a lightweight EJB container to be used as a test hardness, but 
    that does not substitue for honest end-to-end testing using a 
    server deployment of the EJB/EAR and external test clients.
    We will create an additional module to deploy the EAR, locate
    the server and EJB remote interface, and test the EJB through
    that interface. We can reuse tests from lower levels, but
    that will not be shown as a part of this exercise.
    This module will have no target artifact that we care about. One 
    could do some tweeking of the pom.xml to keep that from being 
    generated, but I have found that to only confuse Eclipse so we'll
    just live with and empty, unused RMI Test.jar.

    [[1]] Create the sub-project directory for the RMI Test.

---
$ pwd
/cygdrive/c/proj/javaeeEx

$ mkdir javaeeExTest
---

    [[1]] Create the pom.xml for the RMI Test module.

---
$ cat javaeeExTest/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <parent>
        <artifactId>javaeeEx</artifactId>
        <groupId>myorg.javaee</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.javaee</groupId>
    <artifactId>javaeeExTest</artifactId>
    <packaging>jar</packaging>
    <name>Java EE Exercise Remote Test</name>
    <description>
        This project provides an example RMI Test project.
    </description>

    <dependencies>

    </dependencies>

    <build>
        <plugins>

        </plugins>
    </build>

    <profiles>

    </profiles>
</project>
---

    [[1]] Add the dependencies required to use logging and JUnit.

---
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.0.4</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.7</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.13</version>
            <scope>test</scope>
        </dependency>
---

    [[1]] Configure the compiler plugin to use JDK 5 or 6.

---
    <build>
        <plugins>
              <!-- make sure we are building java5 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
---

    [[1]] Add the dependencies required to be an RMI client of JBoss. We
    will use a convenient type=pom dependency provided by JBoss to define
    all required client dependencies in a single declaration.  We are
    using a profile in this case to cleary isolate the JBoss-specific
    aspects of this pom.xml file. You could also roll these dependencies
    up to the root level. 

    [Note:] One negative I have noticed in using the jboss-as-client.pom
    dependency is that it is a catch-all and will add 100+ jar files
    to your classpath. That does not present a functional proble, but it
    will cause your dependency classpath to be 10s of MB in size for 
    even the simplest clients.

    []

---
<profile>
    <id>jboss</id>
    <activation>
        <property> <!-- activate this unless -Dserver present -->
            <name>!server</name>
        </property>
    </activation>
    <properties>
      <!-- more here later -->
    </properties>

    <repositories>
        <repository>
            <id>jboss-nexus</id>
            <name>JBoss Nexus Repository</name>
            <url>https://repository.jboss.org/nexus/content/groups/public-jboss/</url>
        </repository>
    </repositories>
    <pluginRepositories>
        <pluginRepository>
            <id>jboss-nexus</id>
            <name>JBoss Nexus Repository</name>
            <url>https://repository.jboss.org/nexus/content/groups/public-jboss/</url>
        </pluginRepository>
    </pluginRepositories>
    <dependencies>
        <dependency>
            <groupId>org.jboss.jbossas</groupId>
            <artifactId>jboss-as-client</artifactId>
            <version>6.1.0.Final</version>            
            <type>pom</type>
            <scope>test</scope>
            <exclusions>
                <exclusion> <!-- gets in the way with JBoss6 and M2 -->
                    <groupId>org.jboss.security</groupId>
                    <artifactId>jbosssx-client</artifactId>
                </exclusion>
                <exclusion> <!-- troubles finding this artifact -->
                    <groupId>com.sun.istack</groupId>
                    <artifactId>istack-commons-runtime</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.5.6</version>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <!-- more here later -->
        </plugins>
    </build>
</profile>
---

    [[1]] Create a JNDI configuration for JBoss. Use variable references to 
    the server to better support different configurations.

---
$ mkdir -p javaeeExTest/src/test/resources

...

$ cat javaeeExTest/src/test/resources/jndi.properties
java.naming.factory.initial=${java.naming.factory.initial}
java.naming.provider.url=${java.naming.provider.url}
java.naming.factory.url.pkgs=${java.naming.factory.url.pkgs}
---

    [[1]] Add resource filtering to test resources in the pom.xml. This
    will cause the jndi.properties file to have variables replaces with 
    physical values when copied to the target tree.

---
    <build>
        <!-- filter test/resource files for profile-specific valies -->
        <testResources>
            <testResource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </testResource>
        </testResources>
---

    [[1]] Add definitions for the variables within the jboss profile.

---
<profile>
    <id>jboss</id>
...
    <properties>
          <java.naming.factory.initial>org.jnp.interfaces.NamingContextFactory
          </java.naming.factory.initial>
          <java.naming.provider.url>jnp://${jboss.host}:1099
          </java.naming.provider.url>
          <java.naming.factory.url.pkgs>org.jboss.naming:org.jnp.interfaces
          </java.naming.factory.url.pkgs>
    </properties>
    <dependencies>
---

    [[1]] Test the build of your RMI Test project so far. Note the values 
    for the jndi.properties file within the target/test-classes directory.
    If yours still has variable references check your configuration steps.

---
$ (cd javaeeExTest/; mvn clean install)
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[WARNING] The POM for woodstox:wstx-asl:jar:3.2.1 is missing, no dependency information available
[WARNING] The POM for ws-commons:policy:jar:1.0 is missing, no dependency information available

...

 -------------------------------------------------------
 T E S T S
 -------------------------------------------------------
There are no tests to run.

Results :

Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

...

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 12.913s
[INFO] Finished at: Tue Mar 01 23:08:33 EST 2011
[INFO] Final Memory: 25M/269M
[INFO] ------------------------------------------------------------------------
---
---
$ cat javaeeExTest/target/test-classes/jndi.properties
java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=jnp://localhost:1099
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces
---

    [[1]] Create the JUnit test that will lookup the EJB and invoke the
    ping method. You will be tempted to directly reuse your business logic
    tests as implementation for the RMI Test. With proper refactoring and
    design, this can be done. However, realize that a remote interface must 
    have special design considerations addressed and may not always (even
    rarely) be the same as a local interface. Remote interfaces pass by value,
    are used in different JVMs with potentially different classpaths, and
    may have clients with different concerns. Technically, Java EE has allowed
    them to be the same, but that ends up biting you in the end.

---
$ cat javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java
package myorg.javaeeex.ejbclient;

import javax.naming.InitialContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;

public class RegistrarTest {
    Log log = LogFactory.getLog(RegistrarTest.class);
    InitialContext jndi;

    @Before
    public void setUp() throws Exception {

        log.debug("getting jndi initial context");
        jndi = new InitialContext();
        log.debug("jndi=" + jndi.getEnvironment());
        jndi.lookup("/"); //do a quick comms check of JNDI
    }

    @Test
    public void testPing() {
    }
}
---

    [[1]] Put a log4j.xml configuration in place.

---
$ cat javaeeExTest/src/test/resources/log4j.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">

<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/" debug="false">

   <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
         <param name="Target" value="System.out"/>

         <layout class="org.apache.log4j.PatternLayout">
            <!-- The default pattern: Date Priority [Category] Messagen -->
            <!--
            <param name="ConversionPattern" value="%d{ABSOLUTE} %-5p [%c{1}] %m%n"/>
            -->
            <param name="ConversionPattern" value=" -%m%n"/>
         </layout>
   </appender>

   <appender name="logfile" class="org.apache.log4j.RollingFileAppender">
      <param name="File" value="target/log4j-out.txt"/>
      <param name="Append" value="false"/>
      <param name="MaxFileSize" value="100KB"/>
      <param name="MaxBackupIndex" value="1"/>
      <layout class="org.apache.log4j.PatternLayout">
         <param name="ConversionPattern" value="%-5p %d{dd-MM HH:mm:ss,SSS} [%c] (%F:%M:%L)  -%m%n"/>
      </layout>

   </appender>

   <logger name="myorg">
      <level value="debug"/>
   </logger>
   <root>
      <priority value="fatal"/>
      <appender-ref ref="CONSOLE"/>
   </root>

</log4j:configuration>
---

    [[1]] Try building and running the test without the JBoss
    server running.

---
$ (cd javaeeExTest/; mvn clean install)
...

Test set: myorg.javaeeex.ejbclient.RegistrarTest
 -------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 6.187 sec  FAILURE!
testPing(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 6.109 sec  ERROR!
javax.naming.CommunicationException: Could not obtain connection to any of these urls: localhost:1099 and discovery fail
ed with error: javax.naming.CommunicationException: Receive timed out [Root exception is java.net.SocketTimeoutException
: Receive timed out] [Root exception is javax.naming.CommunicationException: Failed to connect to server localhost:1099
[Root exception is javax.naming.ServiceUnavailableException: Failed to connect to server localhost:1099 [Root exception
is java.net.ConnectException: Connection refused: connect]]]
        at org.jnp.interfaces.NamingContext.checkRef(NamingContext.java:1562)
        at org.jnp.interfaces.NamingContext.lookup(NamingContext.java:634)
        at org.jnp.interfaces.NamingContext.lookup(NamingContext.java:627)
        at javax.naming.InitialContext.lookup(InitialContext.java:351)


$ (cd javaeeExTest/; mvn clean install -Pjboss6)
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------

...

Running myorg.javaeeex.ejbclient.RegistrarTest
 -getting jndi initial context
 -jndi={jnp.parsedName=, java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory, java.naming.provider.url=127.0.0.4:1099, java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces}
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 5.433 sec <<< FAILURE!

Results :

Tests in error: 
  testPing(myorg.javaeeex.ejbclient.RegistrarTest)

Tests run: 1, Failures: 0, Errors: 1, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 19.910s
[INFO] Finished at: Tue Mar 01 23:23:19 EST 2011
[INFO] Final Memory: 36M/270M
[INFO] ------------------------------------------------------------------------
[WARNING] The requested profile "hsql" could not be activated because it does not exist.
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.1:test (default-test) on project javaeeExTest: There are test failures.
[ERROR] 
[ERROR] Please refer to /home/jcstaff/solutions/javaeeEx/javaeeExTest/target/surefire-reports for the individual test results.
---
---
$ more javaeeExTest/target/surefire-reports/myorg.javaeeex.ejbclient.RegistrarTest.txt 
 -------------------------------------------------------------------------------
Test set: myorg.javaeeex.ejbclient.RegistrarTest
 -------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 5.432 sec <<< FAILURE!
testPing(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 5.388 sec  <<< ERROR!
javax.naming.CommunicationException: Could not obtain connection to any of these urls: 127.0.0.4:1099 and discovery failed with e
rror: javax.naming.CommunicationException: Receive timed out [Root exception is java.net.SocketTimeoutException: Receive timed ou
t]
        at org.jnp.interfaces.NamingContext.discoverServer(NamingContext.java:1690)
        at org.jnp.interfaces.NamingContext.checkRef(NamingContext.java:1761)
        at org.jnp.interfaces.NamingContext.lookup(NamingContext.java:695)
        at org.jnp.interfaces.NamingContext.lookup(NamingContext.java:688)
        at javax.naming.InitialContext.lookup(InitialContext.java:409)
        at myorg.javaeeex.ejbclient.RegistrarTest.setUp(RegistrarTest.java:22)
...
---

* {Start JBoss Application Server}

    [Note:] JBoss provides several profiles for its application
    server. It's default profile is an optimized starting point. However,
    it is not fully Java EE-compliant. They provide a standard
    configuration that is is meant to be fully Java EE-compliant. The
    profile you created the first week of class is a copy of the standard
    profile with minor resource edits.  To use a non-default profile,
    we need to add a -c (profile-name) switch to the command line.

    []

    The EAR and its contents will be deployed to an application server to 
    provide a container with thread managemement, resource management,
    security, etc. 

    [[1]] Make the following edits to the jboss-log4j.xml file before
    we start the server. These edits will allow debug from our 
    EJB to be logged in the server output.

        * verify the CONSOLE logger does not have a Threshold set 
        to restrict DEBUG

        * add a logger for org and com, with a level=INFO so that the 
        change to CONSOLE does not cause org.* class output to
        overwhelm the console.

        * add logger entries for myorg and the ejava class examples.
        Search the file before adding. They may already be defined.

---
$ cat $JBOSS_HOME/server/ejava-jboss6/deploy/jboss-logging.xml
---
---
   <console-handler name="CONSOLE" autoflush="true" target="System.out">
      <error-manager>
         <only-once/>
      </error-manager>

<!--
      <level name="INFO"/>
      -->
...
---
---
...
   <logger category="myorg">
      <level name="DEBUG"/>
   </logger>
   <logger category="ejava">
      <level name="DEBUG"/>
   </logger>
---


    [[1]] Start the JBoss server.

---
$ /opt/jboss-6.x.x.Final/bin/run.sh -c ejava-jboss6 
=========================================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: /opt/jboss-6.x.x.Final

  JAVA: /usr/lib/jvm/java-6-openjdk/bin/java

  JAVA_OPTS: -server -Xms128m -Xmx512m -XX:MaxPermSize=256m -Dorg.jboss.resolver.warning=true -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=n -Djava.net.preferIPv4Stack=true -Dprogram.name=run.sh -Djava.library.path=/opt/jboss-6.x.x.Final/bin/native/lib

  CLASSPATH: /opt/jboss-6.x.x.Final/bin/run.jar:/usr/lib/jvm/java-6-openjdk/lib/tools.jar

=========================================================================

23:36:43,714 INFO  [AbstractJBossASServerBase] Server Configuration:

        JBOSS_HOME URL: file:/opt/jboss-6.x.x.Final/
        Bootstrap: $JBOSS_HOME/server/ejava-jboss6/conf/bootstrap.xml
        Common Base: $JBOSS_HOME/common/
        Common Library: $JBOSS_HOME/common/lib/
        Server Name: ejava-jboss6
        Server Base: $JBOSS_HOME/server/
        Server Library: $JBOSS_HOME/server/ejava-jboss6/lib/
        Server Config: $JBOSS_HOME/server/ejava-jboss6/conf/
        Server Home: $JBOSS_HOME/server/ejava-jboss6/
        Server Data: $JBOSS_HOME/server/ejava-jboss6/data/
        Server Log: $JBOSS_HOME/server/ejava-jboss6/log/
        Server Temp: $JBOSS_HOME/server/ejava-jboss6/tmp/

23:36:43,720 INFO  [AbstractServer] Starting: JBossAS [6.x.x.Final "Neo"]
23:36:46,025 INFO  [ServerInfo] Java version: 1.6.0_20,Sun Microsystems Inc.
23:36:46,025 INFO  [ServerInfo] Java Runtime: OpenJDK Runtime Environment (build 1.6.0_20-b20)
23:36:46,025 INFO  [ServerInfo] Java VM: OpenJDK Server VM 19.0-b09,Sun Microsystems Inc.
23:36:46,025 INFO  [ServerInfo] OS-System: Linux 2.6.32-28-generic,i386
23:36:46,026 INFO  [ServerInfo] VM arguments: -Xms128m -Xmx512m -XX:MaxPermSize=256m -Dorg.jboss.resolver.warning=true -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000 -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=n -Djava.net.preferIPv4Stack=true -Dprogram.name=run.sh -Djava.library.path=/opt/jboss-6.x.x.Final/bin/native/lib -Djava.endorsed.dirs=/opt/jboss-6.x.x.Final/lib/endorsed 

...
23:37:10,044 INFO  [STDOUT] [Server@1d2c810]: Initiating startup sequence...
23:37:10,049 INFO  [STDOUT] [Server@1d2c810]: Server socket opened successfully in 2 ms.
23:37:10,075 INFO  [ConnectionFactoryBindingService] Bound ConnectionManager 'jboss.jca:service=DataSourceBinding,name=ejavaDS' to JNDI name 'java:ejavaDS'
23:37:10,377 INFO  [STDOUT] [Server@1d2c810]: Database [index=0, id=0, db=file:/opt/jboss-6.x.x.Final/server/ejava-jboss6/data/hypersonic/ejava, alias=] opened sucessfully in 325 ms.
23:37:10,377 INFO  [STDOUT] [Server@1d2c810]: Startup sequence completed in 330 ms.
23:37:10,382 INFO  [STDOUT] [Server@1d2c810]: 2011-03-01 23:37:10.382 HSQLDB server 1.8.0 is online
23:37:10,383 INFO  [STDOUT] [Server@1d2c810]: To close normally, connect and execute SHUTDOWN SQL
23:37:10,383 INFO  [STDOUT] [Server@1d2c810]: From command line, use [Ctrl]+[C] to abort abruptly
...

23:37:12,201 INFO  [org.apache.coyote.http11.Http11Protocol] Starting Coyote HTTP/1.1 on http-127.0.0.1-8080
23:37:12,206 INFO  [org.apache.coyote.ajp.AjpProtocol] Starting Coyote AJP/1.3 on ajp-127.0.0.1-8009
23:37:12,206 INFO  [org.jboss.bootstrap.impl.base.server.AbstractServer] JBossAS [6.x.x.Final "Neo"] Started in 28s:479ms
---

    [[1]] Re-run the RMI Test again.

---
$ (cd javaeeExTest/; mvn clean install)
...

 -------------------------------------------------------
 T E S T S
 -------------------------------------------------------
Running myorg.javaeeex.ejbclient.RegistrarTest
 -getting jndi initial context
 -jndi={jnp.parsedName=, java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory, java.naming.provider.url=localhost:1099, java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces}
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.641 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

...

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 14.668s
[INFO] Finished at: Tue Mar 01 23:45:35 EST 2011
[INFO] Final Memory: 36M/270M
[INFO] ------------------------------------------------------------------------
---

* {Deploy the Application}

    We want tests to run as automated as possible. This allows us to
    simplify testing as well as leverage continous integration techniques
    (e.g., CruiseControl, Hudson; i.e., nightly builds/tests). To
    help automate this we are going to leverage the Maven cargo
    plugin. Cargo, itself, is a Java library that is used to manage Java
    EE containers. The maven cargo plugin just makes it callable from
    within Maven. We will add the cargo plugin to the RMI Test project
    (to deploy the application) since the application isn't ready to be
    deployed until after the EAR is built.

    [[1]] Add the cargo plugin to the RMI Test to deploy the EAR
    to JBoss. This configuration goes in the jboss area of the RMI
    Test's pom.xml.

---
    <build>
        <plugins>

            <plugin>
                <groupId>org.codehaus.cargo</groupId>
                <artifactId>cargo-maven2-plugin</artifactId>
                <version>1.0.4</version>
                <dependencies>
                    <dependency>
                        <groupId>org.codehaus.cargo</groupId>
                        <artifactId>cargo-core-tools-jboss-deployer-5.1-and-onwards</artifactId>
                        <version>1.0.4</version>
                    </dependency>
                    <dependency>
                        <groupId>org.jboss.jbossas</groupId>
                        <artifactId>jboss-as-profileservice-client</artifactId>
                        <version>6.1.0.Final</version>
                        <type>pom</type>
                    </dependency>
                </dependencies>
                <configuration>
                    <container>
                        <containerId>jboss6x</containerId>
                        <type>remote</type>
                    </container>
                    <configuration>
                        <type>runtime</type>
                        <properties>
                            <cargo.hostname>${jboss.host}</cargo.hostname>
                            <cargo.remote.username>${jboss.user}</cargo.remote.username>
                            <cargo.remote.password>${jboss.password}</cargo.remote.password>
                        </properties>
                    </configuration>
                    <deployer>
                        <type>remote</type>
                        <deployables>
                            <deployable>
                                <groupId>${project.groupId}</groupId>
                                <artifactId>javaeeExEAR</artifactId>
                                <type>ear</type>
                            </deployable>
                        </deployables>
                    </deployer>
                </configuration>
                <executions>
                    <execution>
                        <id>deploy-component</id>
                        <phase>test-compile</phase>
                        <goals>
                            <goal>deploy</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
---

    [Note] When adding the cargo plugin and importing the project
    within Eclipse, you may need to inform Eclipse to ignore this
    plugin to avoid a meaningless error to be shown against the RMI Test
    pom.xml. Optionally add the following to a profiles section of your
    root pom.xml.

---
        <!--  tell Eclipse what to do with some of the plugins -->
        <profile>
          <id>m2e</id>
          <activation>
            <property>
              <name>m2e.version</name>
            </property>
          </activation>
          <build>
            <pluginManagement>
                <plugins>
                    <plugin>
                      <groupId>org.eclipse.m2e</groupId>
                      <artifactId>lifecycle-mapping</artifactId>
                      <version>1.0.0</version>
                      <configuration>
                        <lifecycleMappingMetadata>
                          <pluginExecutions>

                            <pluginExecution>
                              <pluginExecutionFilter>
                                <groupId>org.codehaus.cargo</groupId>
                                <artifactId>cargo-maven2-plugin</artifactId>
                                <versionRange>[1.0.4,)</versionRange>
                                <goals>
                                  <goal>deploy</goal>
                                  <goal>undeploy</goal>
                                </goals>
                              </pluginExecutionFilter>
                              <action>
                                <ignore/>
                              </action>
                            </pluginExecution>

                          </pluginExecutions>
                        </lifecycleMappingMetadata>
                      </configuration>
                    </plugin>
                
                </plugins>
            </pluginManagement>
           </build>
        </profile>
---

    []

    [[1]] You will also need to add a dependency on the EAR from the RMI Test
    to satisfy the above plugin. This goes in the root dependency section.

---
    </description>

    <dependencies>
        <!-- package being deployed must be a 'compile' dependency
            for cargo to be able to deploy it
                -->
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>javaeeExEAR</artifactId>
            <version>${project.version}</version>
            <type>ear</type>
            <scope>compile</scope>
        </dependency>
---

    [[1]] Rebuild the RMI Test and note the deployment of the EAR to the JBoss
    server.

---
$ (cd javaeeExTest/; mvn clean install)
...

 -------------------------------------------------------
 T E S T S
 -------------------------------------------------------
Running myorg.javaeeex.ejbclient.RegistrarTest
 -getting jndi initial context
 -jndi={jnp.parsedName=, java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory, java.naming.provider.url=localhost:1099, java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces}
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.845 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] 
[INFO] --- maven-jar-plugin:2.3.1:jar (default-jar) @ javaeeExTest ---
[WARNING] JAR will be empty - no content was marked for inclusion!
[INFO] Building jar: /home/jcstaff/solutions/javaeeEx/javaeeExTest/target/javaeeExTest-1.0-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-install-plugin:2.3.1:install (default-install) @ javaeeExTest ---
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExTest/target/javaeeExTest-1.0-SNAPSHOT.jar to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExTest/1.0-SNAPSHOT/javaeeExTest-1.0-SNAPSHOT.jar
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExTest/pom.xml to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExTest/1.0-SNAPSHOT/javaeeExTest-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 24.223s
[INFO] Finished at: Tue Mar 01 23:56:58 EST 2011
[INFO] Final Memory: 38M/269M
[INFO] ------------------------------------------------------------------------
---

    [Note] If you receive an error trying to Access denied to:
    http://repository.jboss.org/maven2, try adding the following
    repository and plugin repository defintions to the root pom.xml in
    an attempt to avoid that deprecated repository.

---
    <repositories>
        <repository> <!--  this is needed to keep the build from trying to 
                resolve artifacts from the deprecated repository.jboss.org repo -->
            <id>maven-nuxeo</id>
            <name>Maven Nuxeo Repository</name>
            <url>https://maven.nuxeo.org/nexus/content/groups/public/</url>
            <layout>default</layout>
            <releases>
                <enabled>true</enabled>
                <updatePolicy>never</updatePolicy>
            </releases>
            <snapshots>
                <enabled>true</enabled>
                <updatePolicy>never</updatePolicy>
            </snapshots>
        </repository>
    </repositories>
    <pluginRepositories>
        <pluginRepository> <!--  this is needed to keep the build from trying to 
                resolve artifacts from the deprecated repository.jboss.org repo -->
            <id>maven-nuxeo</id>
            <name>Maven Nuxeo Repository</name>
            <url>https://maven.nuxeo.org/nexus/content/groups/public/</url>
            <layout>default</layout>
            <releases>
                <enabled>true</enabled>
                <updatePolicy>never</updatePolicy>
            </releases>
            <snapshots>
                <enabled>true</enabled>
                <updatePolicy>never</updatePolicy>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>
---

* {Setup JNDI access to Remote interface}

    Each EJB interface will have an entry in the JNDI tree. Clients will use
    the JNDI tree to locate the interface object they need based on 
    a hierarchical name.

    [[1]] Look for the JNDI name of the EJB in the jmx-console.

        * Navigate to http://localhost:8080/jmx-console/ in your browser

        * Click on service=JNDIView

        * Click on Invoke under list()

        [Note:] the JNDI names for the RegistrarEJB under the Global
        JNDI Namespace. 

        [Note:] selecting "True" for parameter 1 before clicking
        Invoke will result in a cleaner JNDI output, absent of
        class information. 

        []

---
Global JNDI Namespace

  +- javaeeExEAR-1.0-SNAPSHOT
  |   +- javaeeExEJB-1.0-SNAPSHOT.jar
  |   |   +- RegistrarEJB!myorg.javaeeex.ejb.RegistrarLocal
  |   |   +- RegistrarEJB!myorg.javaeeex.ejb.RegistrarRemote
  |   |   +- RegistrarEJB!local
  |   |   +- RegistrarEJB!remote
---

    [[1]] Add the above JNDI name for the @Remote interface in the 
    RMI Test surefire configuration.

---
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.5</version>
                <configuration>
                    <argLine>${surefire.argLine}</argLine>
                    <systemPropertyVariables>
                        <jndi.name.registrar>javaeeExEAR-${project.version}/javaeeExEJB-${project.version}.jar/RegistrarEJB!remote</jndi.name.registrar>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
---

    [[1]] Add the dependency on the ejb-client.jar to the RMI Test.
    This will go in the root dependency area.

---
        <!-- contains remote interfaces
        -->
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>javaeeExEJB</artifactId>
            <version>${project.version}</version>
            <type>ejb-client</type>
            <scope>test</scope>
        </dependency>
---

    [[1]] Add the handling of the JNDI name property and the testing
    of the lookup to the JUnit test.

---
cat ./javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java

...
import myorg.javaeeex.ejb.RegistrarRemote;
...

public class RegistrarTest {
...
    String registrarJNDI = System.getProperty("jndi.name.registrar");
    RegistrarRemote registrar;

    @Before
    public void setUp() throws Exception {
        assertNotNull("jndi.name.registrar not supplied", registrarJNDI);

        log.debug("getting jndi initial context");
        jndi = new InitialContext();
        log.debug("jndi=" + jndi.getEnvironment());
        jndi.lookup("/"); //do a quick comms check of JNDI

        log.debug("jndi name:" + registrarJNDI);
        registrar = (RegistrarRemote)jndi.lookup(registrarJNDI);
    }
---

    [[1]] Rebuild the RMI Test and note the attempt and staus of 
    the JNDI lookup of the EJB. 

---
$ (cd javaeeExTest/; mvn clean install)
...
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running myorg.javaeeex.ejbclient.RegistrarTest
 -getting jndi initial context
 -jndi={jnp.parsedName=, java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory, java.naming.provider.url=localhost:1099, java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces}
 -jndi name:javaeeExEAR-1.0-SNAPSHOT/javaeeExEJB-1.0-SNAPSHOT.jar/RegistrarEJB!remote
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.607 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] 
[INFO] --- maven-jar-plugin:2.3.1:jar (default-jar) @ javaeeExTest ---
[WARNING] JAR will be empty - no content was marked for inclusion!
[INFO] Building jar: /home/jcstaff/solutions/javaeeEx/javaeeExTest/target/javaeeExTest-1.0-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-install-plugin:2.3.1:install (default-install) @ javaeeExTest ---
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExTest/target/javaeeExTest-1.0-SNAPSHOT.jar to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExTest/1.0-SNAPSHOT/javaeeExTest-1.0-SNAPSHOT.jar
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExTest/pom.xml to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExTest/1.0-SNAPSHOT/javaeeExTest-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 20.490s
[INFO] Finished at: Wed Mar 02 00:18:14 EST 2011
[INFO] Final Memory: 37M/270M
---

* {Invoke EJB method through Remote interface}

    [[1]] Enhance the testPing() method to invoke the ping() method
    of the EJB.

---
    @Test
    public void testPing() {
        log.info("*** testPing ***");
        registrar.ping();
    }
---

    [[1]] Rebuild the RMI Test. Note the processing and status of the 
    testPing() method as well as the output from the server-side EJB.

---
$ (cd javaeeExTest/; mvn clean install)
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise Remote Test

...

 -*** testPing ***
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.876 sec
...
---
---
//SERVER LOG
00:20:27,883 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] **** init ****
00:20:27,927 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] ping called
---

* {Add a few finishing touches}

    There are two semi-related things we need to do; add the RMI Test to 
    the root project and provide a clean-only undeploy of the EAR. 
    
    When we add the RMI Test to the root project, we do so with some caution.
    This module only has tests and requires JBoss to be running. There
    are times when we want the application built without running tests
    and may do so by using -Dmaven.test.skip=true. We can leverage this
    common technique by placing the RMI Test within a profile that gets 
    deactivated when not testing the application.

    The other aspect we'd like to add is the ability to undeploy an EAR
    during the clean goal. This is helpful when deploying and testing
    multiple applications at a set. It is impossible to undeploy, build,
    and re-deploy an application if sibling applications depend on 
    classes it provides when using the default JBoss common classloader
    (i.e., all EARs are sharing the same class loader).


    [[1]] Add the RMI Test to the parent pom.xml configuration. However,
    add it within a profile to keep it from running if we ever invoke
    the build with maven.test.skip=true.

---
    </modules>

    <profiles>
        <profile>
            <id>functional-tests</id>
            <activation>
                <property>
                    <name>!maven.test.skip</name>
                </property>
            </activation>
            <modules>
                <module>javaeeExTest</module>
            </modules>
        </profile>
    </profiles>
---

    [[1]] Re-run the build from the root project. If you have deployed the EAR
    from within the RMI Test directory above without restaring JBoss, you will
    encounter an error shown in the later output below. This is because the 
    application we deployed under the same name using a different relative
    path. You can either restart JBoss or re-issue the build 3 times. The 
    3rd time fully clears and works. This error only occurs when you switch 
    directories. If you always build from the root, it will remain constant.

---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO] 
[INFO] Java EE Exercise
[INFO] Java EE Exercise EJB
[INFO] Java EE Exercise EAR
[INFO] Java EE Exercise Remote Test

...

[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise .................................. SUCCESS [0.733s]
[INFO] Java EE Exercise EJB .............................. SUCCESS [3.595s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [0.781s]
[INFO] Java EE Exercise Remote Test ...................... SUCCESS [19.215s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 24.543s
[INFO] Finished at: Wed Mar 02 00:23:25 EST 2011
[INFO] Final Memory: 42M/272M
[INFO] ------------------------------------------------------------------------
---

    [Note:] If you run into issues where the server will not accept the same
    EAR built from a different level of the hierarchy, you will need to manually
    delete the copy that exists in the JBOSS_HOME/server/ejava-jboss6 directory
    and possibly restart the server.

    []

---
[INFO] Trace
org.codehaus.cargo.container.ContainerException: Failed to deploy to [http://localhost:8080/jmx-console/HtmlAdaptor?acti
on=invokeOpByName&name=jboss.system:service%3DMainDeployer&methodName=deploy&argType=java.net.URL&arg0=file:C%3A%5Cproj%
5CjavaeeEx%5CjavaeeExEAR%5Ctarget%5CjavaeeExEAR-1.0-SNAPSHOT.ear]


//SERVER LOG
00:35:03,078 ERROR [[HtmlAdaptor]] Servlet.service() for servlet HtmlAdaptor threw exception
javax.management.InstanceAlreadyExistsException: jboss.j2ee:service=EARDeployment,url='javaeeExEAR-1.0-SNAPSHOT.ear' alr
eady registered.
---

[[1]] Lets make one more enhancement to the project shell to allow the option to undeploy an EAR from
the application server as a part of the clean goal. This is useful when you have multiple EARs and want all uninstalled during the clean and then have them rebuilt and re-installed
    as a part of a later install. If we left it the way we have it, we would get a series
    of clean+install (for EAR 1), clean+install (from EAR 2), etc. instead of clean (for EAR 1), clean
    (from EAR 2), install (for EAR 1), and install (for EAR 2). To allow for this, add the following 
    plugin definition to the EAR/pom.xml.

---
    </dependencies>

    <profiles>
    <!-- this profiles allow the EAR to be undeployed before it is deleted
        during the clean target. This behavior requires the EAR to be
        present, so it cannot be part of the default behavior. It is
        only activated when -Dundeploy or -Pundeploy is present so that
        normal cleans do not fail.  -->
<profile>
    <id>undeploy</id>
    <activation>
        <property>
            <name>undeploy</name>
            <value>true</value>
        </property>
    </activation>
    <build>
        <plugins>
            <plugin>
                <groupId>org.codehaus.cargo</groupId>
                <artifactId>cargo-maven2-plugin</artifactId>
                <version>1.0.4</version>
                <dependencies>
                    <dependency>
                        <groupId>org.codehaus.cargo</groupId>
                        <artifactId>cargo-core-tools-jboss-deployer-5.1-and-onwards</artifactId>
                        <version>1.0.4</version>
                    </dependency>
                    <dependency>
                        <groupId>org.jboss.jbossas</groupId>
                        <artifactId>jboss-as-client</artifactId>
                        <version>6.1.0.Final</version>
                        <type>pom</type>
                        <exclusions>
                            <exclusion> <!-- gets in the way with JBoss6 and M2 -->
                                <groupId>org.jboss.security</groupId>
                                <artifactId>jbosssx-client</artifactId>
                            </exclusion>
                            <exclusion> <!-- troubles finding this artifact -->
                                <groupId>com.sun.istack</groupId>
                                <artifactId>istack-commons-runtime</artifactId>
                            </exclusion>
                        </exclusions>
                    </dependency>
                    <dependency>
                        <groupId>org.jboss.jbossas</groupId>
                        <artifactId>jboss-as-profileservice-client</artifactId>
                        <version>6.1.0.Final</version>
                        <type>pom</type>
                    </dependency>
                    <dependency>
                        <groupId>org.slf4j</groupId>
                        <artifactId>slf4j-log4j12</artifactId>
                        <version>1.5.6</version>
                    </dependency>
                </dependencies>
                <configuration>
                    <container>
                        <containerId>jboss6x</containerId>
                        <type>remote</type>
                    </container>
                    <configuration>
                        <type>runtime</type>
                        <properties>
                            <cargo.hostname>${jboss.host}</cargo.hostname>
                            <cargo.remote.username>${jboss.user}</cargo.remote.username>
                            <cargo.remote.password>${jboss.password}</cargo.remote.password>
                        </properties>
                    </configuration>
                    <deployer>
                        <type>remote</type>
                        <deployables>
                            <deployable>
                                <groupId>${project.groupId}</groupId>
                                <artifactId>${project.artifactId}</artifactId>
                                <type>ear</type>
                            </deployable>
                        </deployables>
                    </deployer>
                </configuration>
                <executions>
                    <execution>
                        <id>undeploy-ear</id>
                        <phase>pre-clean</phase>
                        <goals>
                            <goal>undeploy</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
    </profiles>
</project>
---

    [[1]] Run the clean target and activate the new plugin configuration.

---
$ mvn clean -Pundeploy
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO] 
[INFO] Java EE Exercise
[INFO] Java EE Exercise EJB
[INFO] Java EE Exercise EAR
[INFO] Java EE Exercise Remote Test

...

[INFO] Building Java EE Exercise EAR 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- cargo-maven2-plugin:1.0.4:undeploy (undeploy-ear) @ javaeeExEAR ---
[INFO] 
[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ javaeeExEAR ---
[INFO] Deleting /home/jcstaff/solutions/javaeeEx/javaeeExEAR/target
[INFO] ------------------------------------------------------------------------

...

[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise .................................. SUCCESS [0.370s]
[INFO] Java EE Exercise EJB .............................. SUCCESS [0.065s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [12.077s]
[INFO] Java EE Exercise Remote Test ...................... SUCCESS [0.130s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 12.942s
[INFO] Finished at: Wed Mar 02 00:37:49 EST 2011
[INFO] Final Memory: 27M/269M
[INFO] ------------------------------------------------------------------------
---

---
//SERVER LOG

00:37:48,305 INFO  [org.jboss.ejb3.session.SessionSpecContainer] Stopping jboss.j2ee:ear=javaeeExEAR-1.0-SNAPSHOT.ear,jar=javaeeExEJB-1.0-SNAPSHOT.jar,name=RegistrarEJB,service=EJB3
00:37:48,310 INFO  [org.jboss.ejb3.EJBContainer] STOPPED EJB: myorg.javaeeex.ejb.RegistrarEJB ejbName: RegistrarEJB
00:37:48,324 INFO  [org.jboss.ejb3.instantiator.deployer.BeanInstantiatorDeployerBase] Uninstalled org.jboss.ejb3.instantiator.impl.Ejb31SpecBeanInstantiator@23bd85 from MC at org.jboss.ejb.bean.instantiator/javaeeExEAR-1.0-SNAPSHOT/javaeeExEJB-1.0-SNAPSHOT/RegistrarEJB

---



    [[1]] This is what we ended up with.

---
javaeeEx/
|-- javaeeExEAR
|   `-- pom.xml
|-- javaeeExEJB
|   |-- pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- myorg
|                   `-- javaeeex
|                       `-- ejb
|                           |-- RegistrarEJB.java
|                           |-- RegistrarLocal.java
|                           `-- RegistrarRemote.java
|-- javaeeExTest
|   |-- pom.xml
|   `-- src
|       `-- test
|           |-- java
|           |   `-- myorg
|           |       `-- javaeeex
|           |           `-- ejbclient
|           |               `-- RegistrarTest.java
|           `-- resources
|               |-- jndi.properties
|               `-- log4j.xml
`-- pom.xml
---

    []

* Summary

    * In this exercise, we created a shell of an EJB, EAR, RMI Test, and
    Maven infrastructure that can be used as the basis for adding the 
    details of our application. Some things that we did were

        * created a @Stateless EJB with a @Remote and @Local interface,
        @PostConstruct and @PreDestroy callbacks, and a single ping()
        method.

        * created an EAR to house the EJB.

        * created an RMI Test project to deploy and test the EJB. The
        RMI Test was configured with the cargo plugin for the deployment.
        It contained a jndi.properties file to locate the JBoss JNDI
        tree. It contained a surefire configuration to locate the @Remote
        interface of the EJB in the JNDI tree and ultimately invoked the
        ping() method of the EJB.

