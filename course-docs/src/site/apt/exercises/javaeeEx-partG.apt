Java EE Exercise 

Part F: Securing the EJB Tier and RMI Interface

    This exercise will step through the setup of security authentication
    and authorization for the EJB Tier and access through an RMI client.
    We will use simple credentials (username and password) and a simple
    credential and role store (property file). Once we have the application
    updated, integrated, and working with the simple approach -- more 
    advance techniques (e.g., PKI certs, RDBMS or LDAP for credential 
    storage) can be added without impacting the core of the application.

* Objectives

    * Lock down the EJB

        * {{{Associate_the_EJB_with_a_Security_Domain}
            Associate the EJB with a Security Domain
        }}

        * {{{Define_Role_Access_Restrictions}
            Define Role Access Restrictions
        }}

    * Enable access from the RMI Client

        * {{{Configure_Client_Login_Module}
            Configure Client Login Module
        }}

        * {{{Implement_Client_Login}
            Implement Client Login
        }}

    * Finish out the application

        * {{{Define Remaining Access Restrictions}
            Define Remaining Access Restrictions
        }}

        

* {Associate the EJB with a Security Domain}

    In order to associate our application with a security domain, we need
    to define an application policy within the server and configure it
    for the users and roles we expect to encounter. Roles are typically
    known up front during the design of the application. Users are
    typically added by an administration task during the lifetime of
    the application.

    To start things out simple, we will leverage a built-in application
    policy within JBoss called "other". The fact that it is built-in
    to the factory JBoss configuration will make our project very
    portable to other development environments. The "other" security
    domain also happens to be the default security domain name with
    JBoss. If you specify no security domain, your application will
    not use security. If you specify "other" or specificy an incorrect
    security domain, "other" will be used.  (i.e., whether you define
    it right or wrong -- you will default to "other")

    The factory definition for the "other" application policy is based
    on a set of property files. This is fine for roles, but will be
    very static for users. The administrative steps for adding a user
    will require a re-deploy of the property files and we will 
    design this exercise to provide the property files within the 
    EAR we deploy to the server. This is not ideal for production,
    but is enough to get beyond the server-specifics and move on
    to the JavaEE aspects of securing the application.

    [[1]] Look at the definition for the "other" security domain within 
    the login-config.xml for your server. Notice the following

        * the users will be authenticated against a property file
        called users.properties
        * roles will be checked against a property file called
        roles.properties
        * there is no unauthenticatedIdentity defined at the 
        application policy level, so we can specify this value as 
        a part of our deployed application.

---
$ cd $JBOSS_HOME/server
$ cat ejava-jboss6/conf/login-config.xml

...
  <!-- The default login configuration used by any security domain that
  does not have a application-policy entry with a matching name
  -->
  <application-policy name="other">
    <!-- A simple server login module, which can be used when the number
    of users is relatively small. It uses two properties files:
    users.properties, which holds users (key) and their password (value).
    roles.properties, which holds users (key) and a comma-separated list of
    their roles (value).
    The unauthenticatedIdentity property defines the name of the principal
    that will be used when a null username and password are presented as is
    the case for an unuathenticated web client or MDB. If you want to
    allow such users to be authenticated add the property, e.g.,
    unauthenticatedIdentity="nobody"
    -->
    <authentication>
      <login-module code="org.jboss.security.auth.spi.UsersRolesLoginModule"
        flag="required"/>
    </authentication>
  </application-policy>
---

    [[1]] Notice at this point the "other" application policy is not in use
    and is not listed in the JNDI tree under "jaas"

        * open {{http://localhost:8080/jmx-console/}} in a browser

        * click on service=JNDIView

        * click on list->Invoke

---
java: Namespace

  +- securityManagement (class: org.jboss.security.integration.JNDIBasedSecurityManagement)
...
  +- ejavaDS (class: org.jboss.resource.adapter.jdbc.WrapperDataSource)
...
  +- DefaultDS (class: org.jboss.resource.adapter.jdbc.WrapperDataSource)
...
  +- jaas (class: javax.naming.Context)
  |   +- hornetq (class: org.jboss.security.plugins.SecurityDomainContext)
...
---

    [[1]] Associate the EJB with the "other" application policy using
    a security-domain element within META-INF/jboss.xml

---
$ cat javaeeExEJB/src/main/resources/META-INF/jboss.xml

ss
    xmlns="http://www.jboss.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation ="http://www.jboss.com/xml/ns/javaee http://www.jboss.org/j2ee/schema/jboss_5_1.xsd"
    version="5.1">

    <security-domain>other</security-domain>

    <enterprise-beans>
        <session>
            <ejb-name>RegistrarEJB</ejb-name>
...
---

    [[1]] Build and deploy your application. The RMI Tests will fail at this
    point because we have enabled security but have not allowed any accessors.

---
$ mvn clean install -rf :javaeeExEJB

...
 tests run: 6, Failures: 0, Errors: 6, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise EJB .............................. SUCCESS [15.752s]
[INFO] Java EE Exercise WAR .............................. SUCCESS [7.492s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [2.363s]
[INFO] Java EE Exercise Remote Test ...................... FAILURE [45.424s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE

...
 ------------------------------------------------------------------------------
Test set: myorg.javaeeex.ejbclient.RegistrarTest
 ------------------------------------------------------------------------------
Tests run: 6, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 6.596 sec <<< FAILURE!                                
testPing(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 2.466 sec  <<< ERROR!                                 
javax.ejb.EJBAccessException: Invalid User
...
        at $Proxy13.invoke(Unknown Source)
        at org.jboss.ejb3.proxy.impl.handler.session.SessionProxyInvocationHandlerBase.invoke(SessionProxyInvocationHa
ndlerBase.java:193)
        at $Proxy12.resetAll(Unknown Source)
        at myorg.javaeeex.ejbclient.RegistrarTest.cleanup(RegistrarTest.java:60)

---

    [[1]] If you Re-Invoke the MBean Operation for the JNDI list
    operation, you should now see the "other" security domain
    showing up under the "jaas" naming context. This helps us know
    that we have specified the security domain and partially tells us
    what is in use.

---
+- jaas (class: javax.naming.Context)
  |   +- HsqlDbRealm (class: org.jboss.security.plugins.SecurityDomainContext)
  |   +- hornetq (class: org.jboss.security.plugins.SecurityDomainContext)
  |   +- other (class: org.jboss.security.plugins.SecurityDomainContext)
---


    [[1]] Lets get back to a working application before we add some
    granularity to the application. The problem with our application at the
    moment is that our EJBs have no client identity to work from. Lets 
    enable anonymous access through the jboss.xml deployment descriptor.

---
$ cat javaeeExEJB/src/main/resources/META-INF/jboss.xml

...
    <security-domain>other</security-domain>
    <unauthenticated-principal>anonymous</unauthenticated-principal>
...
---

    [[1]] Build and deploy the application again. The container should now
    assign the unauthenticated-principal identity to any client that does
    not present a client credential.

---
$ mvn clean install -rf :javaeeExEJB

...
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0

...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise EJB .............................. SUCCESS [11.366s]
[INFO] Java EE Exercise WAR .............................. SUCCESS [6.848s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [2.656s]
[INFO] Java EE Exercise Remote Test ...................... SUCCESS [48.375s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
---

    [[1]] Verify the client identity by adding a query of the caller ID
    within the first EJB invoked -- the TestUtilEJB.

---
$ cat ./javaeeExEJB/src/main/java/myorg/javaeeex/ejb/TestUtilEJB.java

...
import javax.annotation.Resource;

import javax.ejb.SessionContext;
...
@Stateless
public class TestUtilEJB implements TestUtilRemote {
    private static Log log = LogFactory.getLog(TestUtilEJB.class);

    @Resource
    private SessionContext ctx;
    
...
    public void resetAll() throws Exception {
        try {
            log.debug("caller=" + ctx.getCallerPrincipal().getName());
            testUtil.resetAll();
---

    [[1]] Rebuild and redeploy your application. Verify that the 
    server log indicates that the unauthenticated-principal
    value is being used.

---
$ mvn clean install -rf :javaeeExEJB

...
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0

...
[INFO] BUILD SUCCESS
---
---
//SERVER log
13:00:00,455 DEBUG [myorg.javaeeex.ejb.TestUtilEJB] caller=guest
13:00:00,456 DEBUG [myorg.javaeeex.jpa.DBUtil] found 4 statements
13:00:00,456 DEBUG [myorg.javaeeex.jpa.DBUtil] executing:
    alter table JAVAEEEX_ADDRESS 
        drop constraint FKEB70B40A6E18CE38
13:00:00,458 DEBUG [myorg.javaeeex.jpa.DBUtil] executing:

    drop table JAVAEEEX_ADDRESS if exists
---

* {Define Role Access Restrictions}
    
    Lets do some quick work to begin locking down the application.  The
    resetAll() method can now be called by any, anonymous user by design. Lets
    change that design to require the caller to authenticate into the admin
    role. We don't yet have the ability to authenticate users into a role
    but we will start by defining which roles the EJBs and methods require.

    [[1]] Define a RolesAllowed restriction for resetAll().

---
$ cat ./javaeeExEJB/src/main/java/myorg/javaeeex/ejb/TestUtilEJB.java

...
import javax.annotation.security.RolesAllowed;
...

    @RolesAllowed({"admin"})
    public void resetAll() throws Exception {
---
    
    [[1]] Rebuild and re-deploy your application. It should now
    fail again. This time not because of an Invalid User -- but
    an Unauthorized Caller.

---
$ mvn clean install -rf :javaeeExEJB

...
Tests run: 6, Failures: 0, Errors: 6, Skipped: 0

...
[INFO] Java EE Exercise Remote Test ...................... FAILURE [37.762s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE

 -------------------------------------------------------------------------------
Test set: myorg.javaeeex.ejbclient.RegistrarTest
 -------------------------------------------------------------------------------
Tests run: 6, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 6.545 sec <<< FAILURE!
testPing(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 2.559 sec  <<< ERROR!
javax.ejb.EJBAccessException: Caller unauthorized
...
        at $Proxy12.resetAll(Unknown Source)
        at myorg.javaeeex.ejbclient.RegistrarTest.cleanup(RegistrarTest.java:60)
        at myorg.javaeeex.ejbclient.RegistrarTest.setUp(RegistrarTest.java:55)
---

    [[1]] Define a user for this application. Since we are using the simple,
    factory-defined "other" application policy and it is defined to use a set 
    of propery files, we will add a users.properties with the users of our
    system. This needs to be in the classpath of the application server. You
    will find many of these types of files in the config/props directory. We
    will be placing this one at the root level of the EJB so that it can
    be conveniently deployed with our application.

---
$ cat javaeeExEJB/src/main/resources/users.properties

#users.properties
#userId=password

admin1=password
---

    [[1]] Define a mapping of roles to users for this application. Again, since
    we are using the simple, factory-defined "other" application policy and it
    is defined to use a set of property files, we will add a roles.properties 
    with the role mappings for our users. This needs to be in the classpath of 
    our server and could be placed in the config/props directory, but it will
    be easier to manage for a prototype if we use the root directory of our EJB.

---
$ cat javaeeExEJB/src/main/resources/roles.properties

#roles.properties
#user=role1,role2

admin1=admin
---

    Your source tree should look like the following at this point.

---
javaeeExEJB/
|-- pom.xml
`-- src
    `-- main
        |-- java
        |   `-- myorg
        |       `-- javaeeex
        |           |-- dto
        |           |   |-- AddressDTO.java
        |           |   `-- PersonDTO.java
        |           `-- ejb
        |               |-- RegistrarEJB.java
        |               |-- RegistrarLocal.java
        |               |-- RegistrarRemote.java
        |               |-- TestUtilEJB.java
        |               `-- TestUtilRemote.java
        `-- resources
            |-- META-INF
            |   |-- jboss.xml
            |   `-- persistence.xml
            |-- roles.properties
            `-- users.properties
---

    The built EJB .jar file should look like the following, with the 
    users and roles.properties files in the root of the archive.

---
$ jar tf javaeeExEJB/target/javaeeExEJB-1.0-SNAPSHOT.jar 
META-INF/
META-INF/MANIFEST.MF
...
roles.properties
myorg/javaeeex/ejb/RegistrarEJB.class
myorg/javaeeex/ejb/TestUtilRemote.class
myorg/javaeeex/ejb/TestUtilEJB.class
myorg/javaeeex/ejb/RegistrarRemote.class
myorg/javaeeex/ejb/RegistrarLocal.class
myorg/javaeeex/dto/PersonDTO.class
myorg/javaeeex/dto/AddressDTO.class
META-INF/persistence.xml
META-INF/jboss.xml
users.properties
...
---

    [Note:] One important point to bring up by placing the security files
    at the root lovel -- they also end up in your EJB-client.jar file as 
    well with the current configuration.

---
$ cat javaeeExEJB/pom.xml

...
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-ejb-plugin</artifactId>
                <version>2.3</version>
                <configuration>
                    ...
                    <generateClient>true</generateClient>
                    <clientExcludes>
                        <clientExclude>**/META-INF/*.xml</clientExclude>
                        <clientExclude>**/ejb/*EJB.class</clientExclude>
                    </clientExcludes>
                </configuration>
            </plugin>
...
---
---
$ jar tf javaeeExEJB/target/javaeeExEJB-1.0-SNAPSHOT-client.jar 
...
roles.properties
myorg/javaeeex/ejb/TestUtilRemote.class
myorg/javaeeex/ejb/RegistrarRemote.class
myorg/javaeeex/ejb/RegistrarLocal.class
myorg/javaeeex/dto/PersonDTO.class
myorg/javaeeex/dto/AddressDTO.class
users.properties
...
---

    This means that a .jar archive that is meant for your client's 
    to use contains all roles, users, and their credentials. This 
    will end up playing in our favor for the class project when 
    all applications end up deployed to the same server -- so we 
    will leave it that way for simplicity. However,

        * if you were to use the property file approach, one would
        normally place the property files at the server level in 
        config/props and not in the deployed application.

        * if you did want to place the files in the deployed 
        application but not in the client.jar then you can
        change the clientExcludes defined for the ejb-plugin.

    []

    If you rebuild and redeploy at this point, the RMI Client will
    still fail because it is still not authenticating with the 
    server. However, in this last section, we provided a means
    for the client to authenticate with the server and be 
    authorized to access specific resources. In the next section
    we will setup the client side of the authentication.

* {Configure Client Login Module}

    Our server is setup or the clients to use username/password
    authentication so now we will setup the client to do the same.

    [[1]] Configure the SecurityManager for the JVM to use a 
    login module that will provider username and password. This
    can be done either by straight Java code or by a configuration
    file.

    The following shows the creation of a javax.security.auth.login.Configuration
    within the RMI Test Client. The test within @BeforeClass is done just so 
    we can easily switch between the two configuration methods shown.

---
...
import javax.security.auth.login.AppConfigurationEntry;
import javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag;
import javax.security.auth.login.Configuration;
...
    static Log log = LogFactory.getLog(RegistrarTest.class);
...
    @BeforeClass
    public static void setUpClass() throws Exception {
        ...
        if (System.getProperty("java.security.auth.login.config")==null) {
            log.debug("defining security configuration within JVM");
            Configuration.setConfiguration(new SecurityConfig());
        }
        else {
            log.debug("defining security configuration outside JVM");
        }
    }

    public static class SecurityConfig extends Configuration {
        @Override
        public AppConfigurationEntry[] getAppConfigurationEntry(String name) {
            AppConfigurationEntry entry = new AppConfigurationEntry(
                    "org.jboss.security.ClientLoginModule",
                    LoginModuleControlFlag.REQUIRED,
                    new HashMap<String, String>());
            return new AppConfigurationEntry[] { entry };
        }
    }
---

    If you want to setup the Configuration at the JVM level without writing
    code, you can provide a definition file and set a Java system property
    to read that configuration file. 

    The property file is defined within the src/test/resources directory of 
    the RMI Client.

---
$ cat javaeeExTest/src/test/resources/security-config.conf

mySecurityConfig {
    org.jboss.security.ClientLoginModule  required;
};
---

    The system property is defined within the surefire configuration.

---
$ cat javaeeExTest/pom.xml

...
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.5</version>
                <configuration>
                    <argLine>${surefire.argLine}</argLine>
                    <systemPropertyVariables>
                        <jndi.name.registrar>myorg/javaeeEx/RegistrarEJB/remote</jndi.name.registrar>
                        <jndi.name.testUtil>myorg/javaeeEx/TestUtilEJB/remote</jndi.name.testUtil>
                        <java.security.auth.login.config>
                           file://${basedir}/target/test-classes/security-config.conf
                        </java.security.auth.login.config>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
...
---

    [[1]] Define a class that will accept the Java Security Callbacks
    for credential information during login.

---
$ cat javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/BasicCallbackHandler.java

package myorg.javaeeex.ejbclient;

import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.UnsupportedCallbackException;

import org.apache.log4j.Logger;

public class BasicCallbackHandler implements CallbackHandler {
    Logger log = Logger.getLogger(BasicCallbackHandler.class);
    private String name;
    private char[] password;

    public BasicCallbackHandler() {}
    public BasicCallbackHandler(String name, char[] password) {
        setName(name);
        setPassword(password);
    }
    public BasicCallbackHandler(String name, String password) {
        setName(name);
        setPassword(password);
    }
    public void setName(String name) { this.name = name; }
    public void setPassword(String password) {
        this.password = new char[password.length()];
        password.getChars(0,this.password.length, this.password,0);
    }
    public void setPassword(char[] password) {
        this.password = new char[password.length];
        System.arraycopy(password,0,this.password,0,this.password.length);
    }

    public void handle(Callback[] callbacks)
        throws UnsupportedCallbackException {

        for (Callback cb : callbacks) {
            if (cb instanceof NameCallback) {
                log.debug("name callback:" + name);
                ((NameCallback)cb).setName(name);
            }
            else if (cb instanceof PasswordCallback) {
                log.debug("password callback:" + new String(password));
                ((PasswordCallback)cb).setPassword(password);
            }
            else {
                log.debug("unknown callback");
                throw new UnsupportedCallbackException(cb);
            }
        }
    }
}
---

    [[1]] Define the admin user credentials for the project.

---
$ cat javaeeExTest/pom.xml

...
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.5</version>
                <configuration>
                    <argLine>${surefire.argLine}</argLine>
                    <systemPropertyVariables>
                        <jndi.name.registrar>myorg/javaeeEx/RegistrarEJB/remote</jndi.name.registrar>
                        <jndi.name.testUtil>myorg/javaeeEx/TestUtilEJB/remote</jndi.name.testUtil>
                        <java.security.auth.login.config>
                           file://${basedir}/target/test-classes/security-config.conf
                        </java.security.auth.login.config>

                        <admin.user>admin1</admin.user>
                        <admin.password>password</admin.password>

                    </systemPropertyVariables>
                </configuration>
            </plugin>
...
---

    [[1]] Read in the admin user credentials into the client program

---
$ cat javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java

...
public class RegistrarTest {
    
...
    static final String adminUser = System.getProperty("admin.user");
    static final String adminPassword = System.getProperty("admin.password");
...

    @Before
    public void setUp() throws Exception {
...
        assertNotNull("admin.user not supplied", adminUser);
        assertNotNull("admin.password not supplied", adminPassword);
    }
---

    At this point, the client JVM is configured to authenticate. Next we will
    implement the client login.

* {Implement Client Login}

    [[1]] Create a LoginContext within the RMI Test for the admin methods to 
    use. 

---
$ cat javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java

...
import javax.security.auth.login.LoginContext;

...
public class RegistrarTest {
...
    LoginContext adminCtx;
...
    @Before
    public void setUp() throws Exception {
    ...
        adminCtx = new LoginContext("mySecurityConfig", 
                new BasicCallbackHandler(adminUser, adminPassword));

        cleanup();
    }
---
    
    [[1]] Login as the admin prior to calling resetAll().

---
$ cat javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java

...
    protected void cleanup() throws Exception {
        adminCtx.login();
        try {
            log.info("calling testUtil.resetAll()");
            testUtil.resetAll();
            log.info("testUtil.resetAll() complete");
        }
        finally {
            adminCtx.logout();
        }
        
    }
...
---

    [[1]] Rebuild and re-deploy the application. If everything is setup correctly

        * the security configuration should be registered with the JVM

        * the credentials should be passed into the JVM from the surefire configuration

        * the test setup should be taking the credentials and turning them into
        a LoginContext

        * the cleanup() method is logging in as the admin

        * the callback handler is bring queried for the credentials

        * the credentials are being passed to the server

        * the credentials provided by the client match the credentials registered on the
        server an do not reject the user as an unknown user.

        * the authenticated user roles match the restrictions defined for the EJB
        method and allow the resetAll() to be invoked.

---
$ mvn install -rf :javaeeExEJB

...
 -------------------------------------------------------
 T E S T S
 -------------------------------------------------------
Running myorg.javaeeex.ejbclient.RegistrarTest
 -defining security configuration outside JVM
 -getting jndi initial context
 -jndi={jnp.parsedName=, java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory, java.naming.provider.url=127.0.0.4:1099, java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces}
 -jndi name:myorg/javaeeEx/RegistrarEJB/remote
 -jndi name:myorg/javaeeEx/TestUtilEJB/remote
 -name callback:admin1
 -password callback:password
 -calling testUtil.resetAll()
 -testUtil.resetAll() complete
...

Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 7.765 sec

Results :

Tests run: 6, Failures: 0, Errors: 0, Skipped: 0

...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise EJB .............................. SUCCESS [3.779s]
[INFO] Java EE Exercise WAR .............................. SUCCESS [2.112s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [1.042s]
[INFO] Java EE Exercise Remote Test ...................... SUCCESS [24.476s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
---
---
//SERVER CONSOLE
11:32:18,526 INFO  [myorg.javaeeex.ejb.TestUtilEJB]  *** TestUtilEJB:init() ***
11:32:18,527 DEBUG [myorg.javaeeex.ejb.TestUtilEJB] caller=admin1
11:32:18,527 DEBUG [myorg.javaeeex.jpa.DBUtil] found 4 statements
11:32:18,528 DEBUG [myorg.javaeeex.jpa.DBUtil] executing:
    alter table JAVAEEEX_ADDRESS 
        drop constraint FKEB70B40A6E18CE38
---
        
* {Define Remaining Access Restrictions}

    Once you completed the previous steps you have all the mechanics down for
    adding authentication, access control, and authorization to your server
    and application. In this section we will just add breadth to the overall
    implementation.

    [[1]] Define the remaining users used in the application.

---
$ cat javaeeExEJB/src/main/resources/users.properties

#users.properties
#userId=password

admin1=password
admin2=password
user1=password
user2=password
known1=password
---

    [[1]] Define the remaining roles used in the application.

---
$ cat javaeeExEJB/src/main/resources/roles.properties

#roles.properties
#user=role1,role2

admin1=admin
admin2=admin,user
user1=user
user2=user
known1=
---
        
    [[1]] Add a default restriction for all methods in the RegistrarEJB by
    defining a RolesAllowed at the class level.

---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarEJB.java

...
javax.annotation.security.RolesAllowed
...
@Stateless
@RolesAllowed({"user"})
public class RegistrarEJB implements RegistrarLocal, RegistrarRemote {
---

    [[1]] Rebuild and redeploy the application to verify the new restrictions
    are in place. At this point all business methods in the RegistrarEJB 
    should report an Unauthorized User.

---
$ mvn install -rf :javaeeExEJB

Tests run: 6, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 6.672 sec <<< FAILURE!

Results :

Tests in error: 
  testPing(myorg.javaeeex.ejbclient.RegistrarTest)
  testCreatePerson(myorg.javaeeex.ejbclient.RegistrarTest)
  testLazy(myorg.javaeeex.ejbclient.RegistrarTest)
  testPOJO(myorg.javaeeex.ejbclient.RegistrarTest)
  testDTOs(myorg.javaeeex.ejbclient.RegistrarTest)
  testWebUseCase(myorg.javaeeex.ejbclient.RegistrarTest)

Tests run: 6, Failures: 0, Errors: 6, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise .................................. SUCCESS [0.741s]
[INFO] Java EE Exercise Impl ............................. SUCCESS [22.466s]
[INFO] Java EE Exercise EJB .............................. SUCCESS [8.791s]
[INFO] Java EE Exercise WAR .............................. SUCCESS [6.747s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [2.054s]
[INFO] Java EE Exercise Remote Test ...................... FAILURE [1:23.596s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
---
---
./javaeeExTest/target/surefire-reports/myorg.javaeeex.ejbclient.RegistrarTest.txt
::::::::::::::
 -------------------------------------------------------------------------------
Test set: myorg.javaeeex.ejbclient.RegistrarTest
 -------------------------------------------------------------------------------
Tests run: 6, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 6.667 sec <<< FAILURE!
testPing(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 1.427 sec  <<< ERROR!
javax.ejb.EJBAccessException: Caller unauthorized
...
        at myorg.javaeeex.ejbclient.RegistrarTest.testPing(RegistrarTest.java:110)
---

    [[1]] Allow anyone to invoke ping() by assigning PermitAll specifically to the 
    method. This will override the default defined at the class level.

---
$ cat javaeeExEJB/src/main/java/myorg/javaeeex/ejb/RegistrarEJB.java

...
import javax.annotation.security.PermitAll;
import javax.ejb.SessionContext;
...
    @Resource
    protected SessionContext ctx;
...
    @PermitAll
    public void ping() {
        log.debug("ping called");
        log.debug("caller=" + ctx.getCallerPrincipal().getName());
    }
---

    [[1]] Rebuild and redeploy the application to verify the new restrictions
    are in place. At this point the ping() method should allow anonymous clients
    to invoke it.

---
$ mvn install -rf :javaeeExEJB

...
Tests run: 6, Failures: 0, Errors: 5, Skipped: 0, Time elapsed: 6.624 sec <<< FAILURE!

Results :

Tests in error: 
  testCreatePerson(myorg.javaeeex.ejbclient.RegistrarTest)
  testLazy(myorg.javaeeex.ejbclient.RegistrarTest)
  testPOJO(myorg.javaeeex.ejbclient.RegistrarTest)
  testDTOs(myorg.javaeeex.ejbclient.RegistrarTest)
  testWebUseCase(myorg.javaeeex.ejbclient.RegistrarTest)
...
---
---
./javaeeExTest/target/surefire-reports/myorg.javaeeex.ejbclient.RegistrarTest.txt
::::::::::::::
 -------------------------------------------------------------------------------
Test set: myorg.javaeeex.ejbclient.RegistrarTest
 -------------------------------------------------------------------------------
Tests run: 6, Failures: 0, Errors: 5, Skipped: 0, Time elapsed: 6.624 sec <<< FAILURE!
testCreatePerson(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 0.172 sec  <<< ERROR!
javax.ejb.EJBAccessException: Caller unauthorized
...
at myorg.javaeeex.ejbclient.RegistrarTest.testCreatePerson(RegistrarTest.java:128)
...
---
---
//SERVER LOG
19:23:47,328 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] **** init ****
19:23:47,334 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] em=org.jboss.jpa.tx.TransactionScopedEntityManager@1261322
19:23:47,334 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] init complete, registrar=myorg.javaeeex.blimpl.RegistrarImpl@d42ff4
19:23:47,337 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] ping called
19:23:47,342 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] caller=guest
---

    [[1]] Define user credentials in the RMI Test

---
$ cat javaeeExTest/pom.xml
...
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
...
                        <admin.user>admin1</admin.user>
                        <admin.password>password</admin.password>
                        <user.user>user1</user.user>
                        <user.password>password</user.password>
...  
---
---
$ cat javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java

...
    static final String userUser = System.getProperty("user.user");
    static final String userPassword = System.getProperty("user.password");
...
    LoginContext userCtx;
...
    @Before
    public void setUp() throws Exception {
        ...
        userCtx = new LoginContext("mySecurityConfig", 
                new BasicCallbackHandler(userUser, userPassword));
    }
---

    [[1]] Apply the user role credentials across the RMI Test. This
    will allow for a default user and then overrides (logout/login) can 
    be done within specific testMethods.

---
$ cat javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java

...
    @Before
    public void setUp() throws Exception {
        ...
        cleanup();
        userCtx.login();
    }
    
    @After
    public void tearDown() throws LoginException {
        userCtx.logout();
    }
...
---

    [[1]] Rebuild and redeploy the application to verify the new restrictions
    are in place. At this point the user should be able to complete all
    actions within the RMI Test.

---
$ mvn install -rf :javaeeExEJB

...
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 11.247 sec

...

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise EJB .............................. SUCCESS [7.404s]
[INFO] Java EE Exercise WAR .............................. SUCCESS [4.539s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [2.129s]
[INFO] Java EE Exercise Remote Test ...................... SUCCESS [43.413s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
---

    At this point you can experiment with the remaining methods and user identities.
    For example, it may be interesting to use a user with multiple roles to 
    verify they work across roles as well as users with no roles to verify a 
    user with a valid login will be rejected if they do not have the right roles.

* Summary

    In this exercise we secured an EJB according to an application policy and
    enabled access to authorized users. More specifically we ...

        * Defined an application policy that determined how the application server
        should authenticate users and determine roles assigned to users

        * Associated an EJB application with a specific application policy

        * Re-enabled anonymous access to the application

        * Defined roles required to access an EJB method or the entire EJB

        * Defined the users, user credentials, and role assignment to the 
        application policy

        * Defined a login configuration for the remote client.

        * Established login sessions within the remote client. 

    Next steps should be to extend the security implementation to the web tier because
    at this point the web tier will not longer be able to access the EJB's 
    role-constrained methods.    

    The following is an overview of the primary modules accessed during this exercise.

---
|-- javaeeExEJB
|   |-- pom.xml
|   `-- src
|       `-- main
|           |-- java
|           |   `-- myorg
|           |       `-- javaeeex
|           |           |-- dto
|           |           |   |-- AddressDTO.java
|           |           |   `-- PersonDTO.java
|           |           `-- ejb
|           |               |-- RegistrarEJB.java
|           |               |-- RegistrarLocal.java
|           |               |-- RegistrarRemote.java
|           |               |-- TestUtilEJB.java
|           |               `-- TestUtilRemote.java
|           `-- resources
|               |-- META-INF
|               |   |-- jboss.xml
|               |   `-- persistence.xml
|               |-- roles.properties
|               `-- users.properties
...
|-- javaeeExTest
|   |-- pom.xml
|   `-- src
|       `-- test
|           |-- java
|           |   `-- myorg
|           |       `-- javaeeex
|           |           `-- ejbclient
|           |               |-- BasicCallbackHandler.java
|           |               `-- RegistrarTest.java
|           `-- resources
|               |-- jndi.properties
|               |-- log4j.xml
|               `-- security-config.conf
---
