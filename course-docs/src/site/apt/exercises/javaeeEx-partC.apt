Java EE Exercise 

Part C: Integrate Business Logic, Data Access Tier, and the
Persistence Unit within the EJB

* Objectives

    * Bring in a separate module of code within the EJB. We will
    be happy to successfully compile and resolve classes at
    runtime within the EJB. However, we won't be ready to do 
    anything with them just yet. 

        * {{{Integrate_Business_Logic_Classes_into_EJB}
            Integrate Business Logic Classes into EJB
        }}

    * Add the necessary Persistence Unit to be able to fully
    initialize the DAO and begin to make use of the business
    logic and data access tier.

        * {{{Integrate_EntityManager_into_EJB}
            Integrate EntityManager into EJB
        }}

    * Add a few sample business methods and test end-to-end.

        * {{{End_to_End_Test_EJB}
            End to End Test EJB
        }}

* {Integrate Business Logic Classes into EJB}

    No matter how much or little code you place within the EJB,
    sooner or later you will need to use external logic with
    the EJB compoonent. In this part, we will integrate in the 
    classes of the pre-built business logic implementation. 
    We are only concerned with resolving artifacts and classes
    at this point. 

    [[1]] Export the javaeeExImpl solution from the SVN repository.
    You will find a copy within solutions/javaeeEx/partC. 
    
---
$ cd javaeeEx
$ svn export https://ejava.info/repos/class/trunk/ejava-javaee/solutions/javaeeEx/partC/javaeeExImpl
A    javaeeExImpl
A    javaeeExImpl/src
...
---
    
    Your directory will look like the following when you are complete.

---
javaeeEx                                   
|-- javaeeExEAR                         
|   `-- ...
|-- javaeeExEJB                         
|   |-- ...
|-- javaeeExImpl                                    
|   |-- build.xml                                   
|   |-- pom.xml                                     
|   `-- src                                         
|       |-- main                                    
|       |   |-- java                                
|       |   |   `-- myorg                           
|       |   |       `-- javaeeex                    
|       |   |           |-- bl                      
|       |   |           |   |-- Registrar.java      
|       |   |           |   |-- RegistrarException.java
|       |   |           |   `-- TestUtil.java          
|       |   |           |-- blimpl                     
|       |   |           |   |-- RegistrarImpl.java     
|       |   |           |   `-- TestUtilImpl.java      
|       |   |           |-- bo                         
|       |   |           |   |-- Address.java           
|       |   |           |   `-- Person.java            
|       |   |           |-- dao                        
|       |   |           |   |-- PersonDAO.java
|       |   |           |   `-- PersonDAOException.java
|       |   |           `-- jpa
|       |   |               |-- DBUtil.java
|       |   |               `-- JPAPersonDAO.java
|       |   `-- resources
|       |       `-- META-INF
|       |           |-- orm.xml
|       |           `-- persistence.xml
|       `-- test
|           |-- java
|           |   `-- myorg
|           |       `-- javaeeex
|           |           |-- blimpl
|           |           |   |-- RegistrarImplTest.java
|           |           |   `-- TestUtilTest.java
|           |           |-- bo
|           |           |   `-- PersonTest.java
|           |           `-- jpa
|           |               |-- DBUtilTest.java
|           |               |-- DemoBase.java
|           |               `-- JPAPersonDAOTest.java
|           `-- resources
|               `-- log4j.xml
|-- javaeeExTest
|   |-- ...
`-- pom.xml
---

    [[1]] Add the Impl sub-project to your root pom.xml file.

---
    </description>
    <modules>
        <module>javaeeExImpl</module>
        <module>javaeeExEJB</module>
        <module>javaeeExEAR</module>
    </modules>

    <profiles>
---

    [[1]] Verify that the Impl and the entire application compiles and deploys from 
    the root.

---
$ mvn clean install
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO] 
[INFO] Java EE Exercise
[INFO] Java EE Exercise Impl
[INFO] Java EE Exercise EJB
[INFO] Java EE Exercise EAR
[INFO] Java EE Exercise Remote Test
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Java EE Exercise 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------

...

[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise .................................. SUCCESS [0.395s]
[INFO] Java EE Exercise Impl ............................. SUCCESS [11.150s]
[INFO] Java EE Exercise EJB .............................. SUCCESS [3.877s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [1.057s]
[INFO] Java EE Exercise Remote Test ...................... SUCCESS [25.080s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
---

    [Note:] You can avoid unecessary builds of the javaExImpl
    project by adding an extra set of parameters to the build that
    names the module you wish to resume the build from.

---
$ mvn clean install -rf :javaeeExEJB
---

    The above command will begin execution of the build at the EJB
    and skip the Impl project.

    []

    [[1]] Add a dependency from the EJB to the Impl project. This edit is done
    within the EJB/pom.xml. 

---
        <dependency>
          <groupId>${project.groupId}</groupId>
          <artifactId>javaeeExImpl</artifactId>
          <version>${project.version}</version>
          <scope>compile</scope>
        </dependency>
---

    [[1]] You should rebuild the application to verify that the Impl is 
    correctly located by the EJB project at this time.

---
$ mvn clean install

...
---

    [[1]] Integerate the business logic and DAO classes for the Impl 
    partially into our stateless session bean.

---
...

import javax.ejb.EJBException;

import myorg.javaeeex.bl.Registrar;
import myorg.javaeeex.blimpl.RegistrarImpl;
import myorg.javaeeex.dao.PersonDAO;
import myorg.javaeeex.jpa.JPAPersonDAO;

@Stateless
public class RegistrarEJB implements RegistrarLocal, RegistrarRemote {
    private static Log log = LogFactory.getLog(RegistrarEJB.class);
    private Registrar registrar;

    @PostConstruct
    public void init() {
        try {
            log.debug("**** init ****");
            PersonDAO dao = new JPAPersonDAO();
            //still missing the EntityManager at this point

            registrar = new RegistrarImpl();
            ((RegistrarImpl)registrar).setDAO(dao);
            log.debug("init complete, registrar=" + registrar);
        }
        catch (Throwable ex) {
            log.error("error in init", ex);
            throw new EJBException("error in init" + ex);
        }
    }

---

    [[1]] Build your application from the root and look at the output 
    on the server.

    [Note:] There are occasions where JBoss will not see you changes
    or refuses a change without a restart. When I hit this step, I ran
    into the case were I had to restart the server for it to see my
    new @PostCOnstruct implementation. It does not happen often, 
    but it does happen.

    []

---
//SERVER LOG

        /myorg/javaeeEx/RegistrarEJB/remote - EJB3.x Default Remote Business Interface
        javaeeExEAR-1.0-SNAPSHOT/javaeeExEJB-1.0-SNAPSHOT.jar/RegistrarEJB!myorg.javaeeex.ejb.RegistrarRemote - EJB3.x Remote Business Interface
        /myorg/javaeeEx/RegistrarEJB/local - EJB3.x Default Local Business Interface
        javaeeExEAR-1.0-SNAPSHOT/javaeeExEJB-1.0-SNAPSHOT.jar/RegistrarEJB!myorg.javaeeex.ejb.RegistrarLocal - EJB3.x Local Business Interface

22:59:52,150 WARN  [org.jboss.ejb3.TimerServiceContainer] EJBTHREE-2193: using deprecated TimerServiceFactory for restoring timers
22:59:56,809 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] **** init ****
22:59:56,810 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] init complete, registrar=myorg.javaeeex.blimpl.RegistrarImpl@4286a3
22:59:56,811 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] ping called
---

* {Integrate EntityManager into EJB}

    The business logic was developed and tested outside of the EJB using
    JUnit and an extended PersistanceContext -- but with an eye towards
    portability to the EJB tier. That means that this reused logic
    attempts no direct control of the transaction. All transaction 
    decisions are handled external to the core business logic. In this
    case, we will use an EntityManager injected by the container and
    integrated into the JTA tranactions going on within the application
    server.


    [[1]] Update your EJB implementation to add the PersistenceUnit.

---
    <repositories>
        ...
        <repository>
            <id>jboss-nexus</id>
            <name>JBoss Nexus Repository</name>
            <url>https://repository.jboss.org/nexus/content/groups/public-jboss/</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>org.hibernate.javax.persistence</groupId>
            <artifactId>hibernate-jpa-2.0-api</artifactId>
            <version>1.0.0.Final</version>
            <scope>provided</scope>
        </dependency>
        ...
---
---
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

...

@Stateless
public class RegistrarEJB implements RegistrarLocal, RegistrarRemote {
    @PersistenceContext(unitName="javaeeEx")
    private EntityManager em;
---

    [[1]] Update your @PostConstruct to make use of the PersistenceUnit.

---
            log.debug("**** init ****");
            log.debug("em=" + em);
            PersonDAO dao = new JPAPersonDAO();
            ((JPAPersonDAO)dao).setEntityManager(em);
---

    [[1]] Copy the persistence.xml file from the Impl project into the EJB
    project.

---
$ cp javaeeExImpl/src/test/resources/META-INF/persistence.xml javaeeExEJB/src/main/resources/META-INF/
---

    [[1]] Update the definition of the persistence.xml file to provide a jta-data-source
    and a reference to the entity jar-file. Since we are now using a DataSource from the
    JNDI tree, we no longer need the connection information. It can be deleted from the
    EJB's copy. The "-test" suffix can be removed at thsi time since this will be what
    we plan to use in operaton (except for the auto schema create).

---
    <persistence-unit name="javaeeEx">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        <jta-data-source>java:/ejavaDS</jta-data-source>
        <mapping-file>META-INF/orm.xml</mapping-file>
        <jar-file>javaeeExImpl-${project.version}.jar</jar-file>
        <properties>
            <property name="hibernate.dialect" value="${hibernate.dialect}"/>
            <property name="hibernate.show_sql" value="false"/>
            <property name="hibernate.hbm2ddl.auto" value="create"/>
        </properties>
    </persistence-unit>
---
    
    [[1]] Since we are using an orm.xml file, we do not need to specify each 
    entity here using a "class" element. However, you will likely need to do
    this in your projects that rely strictly on class annotations.

    [Note:] This exercise makes use of the provider automatically creating DB schema
    and supplies the hibernate.hbm2ddl.auto=true property. A real, non-demo
    project would not set that property and would design in when schema was created.

    []

    [[1]] Update your EJB/pom.xml to expand the variables defined within the persistence.xml
    file.

---
    <build>
         <!--tell the resource plugin to perform filtering on resources
             to fill in dialect, etc. -->
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>

    ...

    </build>
    <profiles>
        <profile> <!-- defines our persistence.xml dialect -->
            <id>hsql</id>
            <activation>
                <property> <!-- use this property to name another db -->
                    <name>jdbcdb</name>
                    <value>hsql</value>
                </property>
            </activation>
            <properties>
                  <hibernate.dialect>org.hibernate.dialect.HSQLDialect</hibernate.dialect>
            </properties>
        </profile>
    </profiles>
---


    [[1]] Rebuild your application and note that the EntityManager was resolved.

---
23:34:05,877 INFO  [org.jboss.jpa.deployment.PersistenceUnitDeployment] Starting persistence unit persistence.unit:unitName=javaeeExEAR-1.0-SNAPSHOT.ear/javaeeExEJB-1.0-SNAPSHOT.jar#javaeeEx
23:34:05,879 INFO  [org.hibernate.ejb.Ejb3Configuration] Processing PersistenceUnitInfo [
        name: javaeeEx
        ...]
...
23:34:07,499 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] **** init ****
23:34:07,500 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] em=org.jboss.jpa.tx.TransactionScopedEntityManager@1423a74
23:34:07,500 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] init complete, registrar=myorg.javaeeex.blimpl.RegistrarImpl@117f2d6
23:34:07,501 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] ping called
---

    If the server-side looks fine and you are now encountering a name not found
    problem locating the interface from the previous exercise, place a Thread.sleep()
    in the setUp() to allow the EJB a little extra time to deploy. The cargo plugin
    seems to get a handshake from JBoss and then turn things over to surefire/JUnit
    before the application has fully deployed.

---
myorg was not found
---

    Add the following
---
$ cat ./javaeeExTest/src/test/java/myorg/javaeeex/ejbclient/RegistrarTest.java
...
    @BeforeClass
    public static void setUpClass() throws Exception {
        Thread.sleep(3000);
    }
...
---

    [[1]] Note too that the persistence.xml file gets expanded to the following. If you see
    unexpanded variables in your target copy, check that the variable is declared, that
    filtering of that directory and file type are enabled, and everything is spelled 
    correctly.

---
$ cat javaeeExEJB/target/classes/META-INF/persistence.xml 
...
    <persistence-unit name="javaeeEx">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        <jta-data-source>java:/ejavaDS</jta-data-source>
        <mapping-file>META-INF/orm.xml</mapping-file>
        <jar-file>javaeeExImpl-1.0-SNAPSHOT.jar</jar-file>
        <properties>
            <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/>
            <property name="hibernate.show_sql" value="false"/>            
            <property name="hibernate.hbm2ddl.auto" value="create"/>
        </properties>
    </persistence-unit>            
    ...
---

* {End to End Test EJB}

    Lets add additional EJB and RMI Test logic that will leverage the
    EntityManager and the integated business logic.

    [[1]] Add the ability to add and get a Person to your @Remote interface.

---
package myorg.javaeeex.ejb;

import javax.ejb.Remote;

import myorg.javaeeex.bl.RegistrarException;
import myorg.javaeeex.bo.Person;

@Remote
public interface RegistrarRemote {
    void ping();
    Person createPerson(Person person)
        throws RegistrarException;

    Person getPersonById(long id)
        throws RegistrarException;
}
---

    [[1]] Add the implementation of createPerson() to the EJB class.

---
import myorg.javaeeex.bl.RegistrarException;
import myorg.javaeeex.bo.Person;
---
---
    public Person createPerson(Person person)
        throws RegistrarException {
        log.debug("*** createPerson() ***");

        //the person we return will have the PK set
        try {
            return registrar.createPerson(person);
        }
        catch (Throwable ex) {
            log.error(ex);
            throw new RegistrarException(ex.toString());
        }
    }
---

    [[1]] Add the implementation of getPersonById() to the EJB class.

---
    public Person getPersonById(long id)
        throws RegistrarException {
        log.debug("*** getPersonById(" + id + ") ***");
        return registrar.getPersonById(id);
    }
---

    [[1]] Add a testCreatePerson() to the RMI Test.

---
import myorg.javaeeex.bo.Person;
---
---
    protected Person makePerson() {
        Person person = new Person();
        person.setFirstName("joe");
        person.setLastName("smith");
        person.setSsn("123");
        return person;
    }

    @Test
    public void testCreatePerson() throws Exception {
        log.info("*** testCreatePerson ***");

        Person person = makePerson();
        Person person2 = registrar.createPerson(person);
            //note that our original Person does not have an ID
        assertEquals("unexpected id", 0, person.getId());
            //it is separate from the one returned
        assertFalse("unexpected id:" + person2.getId(), person2.getId()==0);

        Person person3 = registrar.getPersonById(person2.getId());
        assertEquals("unexpected name",
            person.getFirstName(),
            person3.getFirstName());
    }
---

    [[1]] Rebuild the application. It will fail because of a validation rule in the
    business logic.

---
$ mvn clean install

...
 -*** testCreatePerson ***
Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.319 sec <<< FAILURE!

Results :

Tests in error: 
  testCreatePerson(myorg.javaeeex.ejbclient.RegistrarTest)

Tests run: 2, Failures: 0, Errors: 1, Skipped: 0

---
---
./javaeeExTest/target/surefire-reports/myorg.javaeeex.ejbclient.RegistrarTest.txt
::::::::::::::
 -------------------------------------------------------------------------------
Test set: myorg.javaeeex.ejbclient.RegistrarTest
 -------------------------------------------------------------------------------
Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.324 sec <<< FAILURE!
testCreatePerson(myorg.javaeeex.ejbclient.RegistrarTest)  Time elapsed: 0.076 sec  <<< ERROR!
myorg.javaeeex.bl.RegistrarException: myorg.javaeeex.bl.RegistrarException: Person must have 1 address
        at myorg.javaeeex.ejb.RegistrarEJB.createPerson(RegistrarEJB.java:66)
---

    [[1]] Add an Address to the makePerson() in the RMI Test.

---
import myorg.javaeeex.bo.Address;
---
---
    protected Person makePerson() {
        Person person = new Person();
        person.setFirstName("joe");
        person.setLastName("smith");
        person.setSsn("123");
        Address address = new Address(0,"street1","city1", "state1", "zip1");
        person.getAddresses().add(address);
        return person;
    }
---

    [[1]] Rebuild the application.

---
$ mvn clean install

...

 -*** testCreatePerson ***
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.633 sec

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0

[INFO] 
[INFO] --- maven-jar-plugin:2.3.1:jar (default-jar) @ javaeeExTest ---
[WARNING] JAR will be empty - no content was marked for inclusion!
[INFO] Building jar: /home/jcstaff/solutions/javaeeEx/javaeeExTest/target/javaeeExTest-1.0-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-install-plugin:2.3.1:install (default-install) @ javaeeExTest ---
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExTest/target/javaeeExTest-1.0-SNAPSHOT.jar to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExTest/1.0-SNAPSHOT/javaeeExTest-1.0-SNAPSHOT.jar
[INFO] Installing /home/jcstaff/solutions/javaeeEx/javaeeExTest/pom.xml to /home/jcstaff/.m2/repository/myorg/javaee/javaeeExTest/1.0-SNAPSHOT/javaeeExTest-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Java EE Exercise .................................. SUCCESS [0.337s]
[INFO] Java EE Exercise Impl ............................. SUCCESS [11.316s]
[INFO] Java EE Exercise EJB .............................. SUCCESS [4.135s]
[INFO] Java EE Exercise EAR .............................. SUCCESS [1.291s]
[INFO] Java EE Exercise Remote Test ...................... SUCCESS [21.046s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
---


    [[1]] Note the extra output in the server.

---
//SERVER LOG

00:08:06,245 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] **** init ****
00:08:06,246 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] em=org.jboss.jpa.tx.TransactionScopedEntityManager@1929486
00:08:06,246 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] init complete, registrar=myorg.javaeeex.blimpl.RegistrarImpl@129460
00:08:06,247 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] ping called
00:08:06,316 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] *** createPerson() ***
00:08:06,317 DEBUG [myorg.javaeeex.jpa.JPAPersonDAO] creating person:id=0:joe smith 123, addresses={{street1 city1, state1 zip1},}
00:08:06,321 DEBUG [myorg.javaeeex.jpa.JPAPersonDAO] em=org.jboss.jpa.tx.TransactionScopedEntityManager@1929486
00:08:06,573 DEBUG [myorg.javaeeex.jpa.JPAPersonDAO] person created:id=1:joe smith 123, addresses={{street1 city1, state1 zip1},}
00:08:06,700 DEBUG [myorg.javaeeex.ejb.RegistrarEJB] *** getPersonById(1) ***
---

    []


* Summary

    * In this exercise, we put many of the end-to-end pieces together
    and we are left to add beef to the EJB implementation. Specifically
    we addressed:

        * adding the Impl classes to the EJB.

        * adding the Persistence Unit to the EJB and completing
        the initialization of the DAO and business logic.

        * adding a a few sample business methods that used the
        business logic and DAO to update the database. We first
        encountered a business rule exception defined within 
        the impoted business logic.
