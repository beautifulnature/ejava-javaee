Exercise: Entity Manager

* Goals

    * Become comfortable building and testing a component that uses 
    the Java Persistence API's EntityManager

* Objectives

    * {{{Part_A} Setup and Start Database}}

    * {{{Part_B} Setup Project Structure}}

    * {{{Part_C} Setup Maven Project Definition}}

    * {{{Part_D} Test Entity Manager Functions}}

    * {{{Part_E} Automatically Generating Schema}}

* Steps

    [Note:] Although this exercise will show you how to create each file,
    many of them are boilerplate from other exercises. If you already have
    the JDBC Tutorial Exercise completed, you can consider starting 
    with a copy of that project and modifying it.

** {Part A}: Setup and Start Database

    * If you haven't done so already, perform the setup instructions
    for JBoss and the database as defined in 
    {{{ex0.html#Part_E}Exercise 0}}. Refer back to those instructions for 
    basic commands.

    * Start the database (using the JBoss run.sh command). Note that the 
    application server is not necessary for this exercise. We are just 
    taking advantage of the fact it will start and stop the database 
    process.

    [Note:] You can also start the database manually to save some resources 
    on your system for now. You should test that the manual start creates
    the same instance of the database as JBoss. You can do this by checking
    that a manual start of the database creates a set of files called "ejava.*"
    in the JBOSS_HOME/server/JBOSS_SERVER/data/hypersonic directory. If they already
    exist, you can safely delete them to test for expected behavior. You will
    do this anyway in the future if you want to coldstart your database after
    significant schema changes have been made.

---
cd ${JBOSS_HOME}/server/${JBOSS_SERVER}/data/hypersonic
java -classpath ${JBOSS_HOME}/server/${JBOSS_SERVER}/lib/hsqldb.jar org.hsqldb.Server -database.0 ejava
---

    []

    * Start the DB GUI and login using the "HSQL Database Engine Server"
    option.

---
java -classpath ${JBOSS_HOME}/server/${JBOSS_SERVER}/lib/hsqldb.jar org.hsqldb.util.DatabaseManager
---

    * You can view the contents of your database at any time through the database
    UI using the following command, configuring it to talk to the server (3rd option)
    and entering the proper query SQL.

---
$ java -classpath ${JBOSS_HOME}/server/${JBOSS_SERVER}/lib/hsqldb.jar org.hsqldb.util.DatabaseManager
---

** {Part B}: Setup Project Structure

    * Create a set of ddl scripts in src/main/resources/ddl to
    handle creating the schema, deleting rows in the schema, and
    dropping tables in the schema. Make sure each script has the 
    word "create", "delete", or "drop" in its file name to match 
    some search strings we'll use later. Have the database generate
    a value for the primary key.

    [Note:] We could actually skip this step and have the persistence 
    provider create the table for us. That approach is great for quick
    Java-first prototypes. However, creating the schema outside of the
    persistence provider is a more realistic scenario for larger 
    developments.

    []

---
# emauto_create.ddl
CREATE TABLE EM_AUTO (
    ID BIGINT generated by default as identity (start with 1),
    MAKE VARCHAR(32),
    MODEL VARCHAR(32),
    COLOR VARCHAR(32),
    MILEAGE INT,

    CONSTRAINT em_autoPK PRIMARY KEY(ID)
)

# emauto_delete.ddl
DELETE * FROM EM_AUTO;

# emauto_drop.ddl
DROP TABLE EM_AUTO if EXISTS;
---

    * Create a META-INF/persistence.xml file to define the 
    persistence unit for our jar file.

        * persistence-unit name: must match what we place in our JUnit test

        * provider: specify that this persistence unit is defined for 
        the org.hibernate.ejb.HibernatePersistence provider.

        * define provider-specific properties that tell the provider how to 
        obtain a connection to the database as well as some other configuration
        properties. 
        
            [Note:] The technique to add the provider-specific properties
            includes somewhat sensitive information like user credentials.
            If we place them in the persistence.xml file within the src/main
            tree, these properties will become part of our deployed 
            artifact. To avoid this, we will define them in a separate
            hibernate.properties file placed in the src/test tree.
        
        []

---
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" version="1.0">

    <persistence-unit name="entityMgrEx">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        <properties>
            <!-- defined in src/test/resources/hibernate.properties -->
        </properties>
    </persistence-unit>
</persistence>
---

    * Create a hibernate.properties file in src/test/resources to hold 
    information we want to suport testing, but may not want to be 
    part of the deployed artifact. Leave the volatile values as variables
    so they can be expanded into the target tree during compile time.

---
hibernate.dialect=${hibernate.dialect}
hibernate.connection.url=${jdbc.url}
hibernate.connection.driver_class=${jdbc.driver}
hibernate.connection.password=${jdbc.password}
hibernate.connection.username=${jdbc.user}
#hibernate.hbm2ddl.auto=create
hibernate.show_sql=true
hibernate.format_sql=true
#hibernate.jdbc.batch_size=0
---

    * Create a JUnit Test case to hold your test code.

---
package myorg.entitymgrex;

import javax.persistence.EntityManager;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import junit.framework.TestCase;

public class EntityMgrTest extends TestCase {
    private static Log log = LogFactory.getLog(EntityMgrTest.class);


    public void testtemplate() {
        log.info("testTemplate");
    }
}
---

    * Override the JUnit setUp() method to create an entity manager
    and factory for the tests to use. 

---
    private static final String PERSISTENCE_UNIT = "entityMgrEx";
    private EntityManagerFactory emf;    
    private EntityManager em;    

    protected void setUp() throws Exception {
        log.debug("creating entity manager");
        emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT);
        em = emf.createEntityManager();
        assertNotNull(em);

        //cleanup();
    }
---

    * Override the JUnit tearDown() method to flush all remaining items
    in the persistence context to the database and close the entity manager
    and factory.

---
    protected void tearDown() throws Exception {
        try {
            log.debug("tearDown() started, em=" + em);
            em.getTransaction().begin();
            em.flush();
            //logAutos();
            em.getTransaction().commit();
            em.close();
            emf.close();
            log.debug("tearDown() complete, em=" + em);
        }
        catch (Exception ex) {
            log.fatal("tearDown failed", ex);
            throw ex;
        }
     }
---

    * Add in a logAutos() method to query and print all autos in the 
    database. Do this after flushing the entity manager in the tearDown()
    method so you can see the changes from the previous test. The following
    example uses the entity manager to create an ad-hoc EJB-QL statement.

---
    public void logAutos() {
        Query query = em.createQuery("select a from Auto as a");
        for (Object o: query.getResultList()) {
            log.info("EM_AUTO:" + o);
        }        
    }
---

    * You might also want to add a cleanup() to clear out the Auto
    table between tests. The example below uses the entity manager to
    create a native SQL statement.
    
---
    public void cleanup() {
        em.getTransaction().begin();
        Query query = em.createNativeQuery("delete from EM_AUTO");
        int rows = query.executeUpdate();
        em.getTransaction().commit();
        log.info("removed " + rows + " rows");
    }
---

    * Add a log4j.xml file to src/test/resources that has your 
    desired settings. The one below produces less timestamp information
    at the console and more details in the logfile.

    [Note:] Although it might be a bit entertaining to set the priority
    of the root appender to debug to see everything the persistence provider
    has to say, it is quite noisy. Consider changing to root priority to
    fatal so that a majority of the log statements are yours.

    []

---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration
    xmlns:log4j="http://jakarta.apache.org/log4j/"
    debug="false">

    <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
        <param name="Target" value="System.out"/>

        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="(%F:%M:%L)  -%m%n"/>
        </layout>
    </appender>

    <appender name="logfile" class="org.apache.log4j.RollingFileAppender">
        <param name="File" value="target/log4j-out.txt"/>
        <param name="Append" value="false"/>
        <param name="MaxFileSize" value="100KB"/>
        <param name="MaxBackupIndex" value="1"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="%-5p %d{dd-MM HH:mm:ss,SSS} [%c] (%F:%M:%L)  -%m%n"/>
        </layout>
   </appender>

   <logger name="myorg">
      <level value="debug"/>
      <appender-ref ref="logfile"/>
   </logger>

   <root>
      <priority value="fatal"/>
      <appender-ref ref="CONSOLE"/>
   </root>

</log4j:configuration>
---

    * Create a (Plain Old Java Object (POJO)) Class to represent an
    automobile. Use class annotations to prvide the following:

        * @Entity annotation on the class to tell persistence provider 
        this is part of persistence unit

        * @Table(name="EM_AUTO") annotation on the class to match the 
        table name in the emauto_create.ddl file

        * properties to hold id:long, make:String, model:String, color:String,
        mileage:int.

        * a public getId():long to return the id field.

        * a private setId(long) to set the primary key. This will be called
        by the persistence provider. You may want to add a 
        @SuppressWarnings("unused") if your compiler is warning you that
        the private setId() is not being used within the class.

        * @Id annotation on the getId() method to tell the persistence 
        provider the id property is the primary key and to use 
        PROPERTY type access (get/setId() versus FIELD type access)

        * make the class implement java.io.Serializable. 

---
package myorg.entitymgrex;

import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity @Table(name="EM_AUTO")
public class Auto implements Serializable {
    private static final long serialVersionUID = 1L;
    private long id;
    private String make;
    private String model;
    private String color;
    private int mileage;

    @Id @GeneratedValue
    public long getId() {
        return id;
    }
    @SuppressWarnings("unused")
    private void setId(long id) {
        this.id = id;
    }

    //more getter/setters go here
}
---

    * Add the remaining setter/getter methods to the class. Since we are
    using generated primary key values, there is no immediate need for a 
    constructor to set the id. If you add this later, remember to also 
    add a default constructor, which was removed by the compiler when 
    you manually add the first constructor.
    
---
    public String getMake() {
        return make;
    }
    public void setMake(String make) {
        this.make = make;
    }
    public int getMileage() {
        return mileage;
    }
    public void setMileage(int mileage) {
        this.mileage = mileage;
    }
    public String getModel() {
        return model;
    }
    public void setModel(String model) {
        this.model = model;
    }
    public String getColor() {
        return color;
    }
    public void setColor(String color) {
        this.color = color;
    }    
}
---

    * You may also want to add a public toString():String method to 
    conveniently print your Auto objects.

---
    public String toString() {
        return super.toString() +
            ", id=" + id +
            ", make=" + make +
            ", model=" + model +
            ", color=" + color +
            ", mileage=" + mileage;            
    }
---

    * Check that you have the following artifacts in your project src
    tree.

---
src/
|-- main
|   |-- java
|   |   `-- myorg
|   |       `-- entitymgrex
|   |           `-- Auto.java
|   `-- resources
|       |-- META-INF
|       |   `-- persistence.xml
|       `-- ddl
|           |-- emauto_create.ddl
|           |-- emauto_delete.ddl
|           `-- emauto_drop.ddl
`-- test
    |-- java
    |   `-- myorg
    |       `-- entitymgrex
    |           `-- EntityMgrTest.java
    `-- resources
        |-- hibernate.properties
        `-- log4j.xml
---

** {Part C}: Setup Maven Project Definition

    [Note:] This project definition may be long, but realize there is 
    a very limited amount that is project specific. Maven provides the 
    mechanism to create a layered set of pom.xml files, which can help
    establish templates for each lower-level project to take advantage of.
    The full pom.xml is being provided here to be complete. You would 
    surely refactor repeated details in a non-class environment.

    []

    * Create a pom.xml file to define the project

---
<?xml version="1.0"?>
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.jpa</groupId>
    <artifactId>entityMgrEx</artifactId>
    <name>Entity Manager Exercise</name>
    <version>1.0-SNAPSHOT</version>

</project> 
---

    * Add the src/main dependenciies. This represents what your code depends
    upon at compile time and runtime.

---
    <dependencies>
        <dependency>
          <groupId>javax.persistence</groupId>
          <artifactId>persistence-api</artifactId>
          <version>1.0</version>
          <scope>provided</scope>
        </dependency>
        <dependency>
          <groupId>commons-logging</groupId>
          <artifactId>commons-logging</artifactId>
          <version>1.0.4</version>
          <scope>compile</scope>
        </dependency>
    </dependencies>
---

    * Add the src/test standard dependencies. 

---
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.6</version>
            <scope>test</scope>
        </dependency>
        <dependency>
          <groupId>log4j</groupId>
          <artifactId>log4j</artifactId>
          <version>1.2.13</version>
            <scope>test</scope>
        </dependency>
---

    * Add a build section and begin by specifying that test resource files should be 
    filtered when copied into the target tree. We do this so we have a chance
    to replace the variables in persistence.xml with our specific database profile.

---
    <build>
        <!--tell the resource plugin to perform filtering on resources
            to fill in JDBC URL, etc. -->
        <testResources>
            <testResource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </testResource>
        </testResources>
    </build>
---

    * Add a plugin specification for Java 1.5.

---
    <build>
        ...

        <plugins>
              <!-- make sure we are building java5 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
---

    * Add a definition for the maven-surefire-plugin so we can set 
    properties needed for testing. At this point, we are just allowing
    the argLine defined in the settings.xml to be optionally specified.

---
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <argLine>${surefire.argLine}</argLine>
                    <systemProperties>
                    <!--
                        <property>
                            <name>name</name>
                            <value>value</value>
                        </property>
                        -->
                    </systemProperties>
                </configuration>
            </plugin>
---

    * Add a set of profiles that define Hypersonic and Hibernate as our database and 
    persistence provider.

---
    <profiles>
        <profile> <!-- defines our default database -->
            <id>hsql</id>
            <activation>
                <property> <!-- use this property to name another db -->
                    <name>jdbcdb</name>
                    <value>hsql</value>
                </property>
            </activation>
            <properties>
                  <jdbc.driver>org.hsqldb.jdbcDriver</jdbc.driver>
                  <jdbc.url>jdbc:hsqldb:hsql://localhost:9001</jdbc.url>
                  <jdbc.user>sa</jdbc.user>
                  <jdbc.password />
                  <hibernate.dialect>
                      org.hibernate.dialect.HSQLDialect
                  </hibernate.dialect>
            </properties>
            <dependencies>
                <dependency>
                    <groupId>hsqldb</groupId>
                    <artifactId>hsqldb</artifactId>
                    <version>1.8.0.4</version>
                    <scope>test</scope>
                </dependency>
            </dependencies>
        </profile>


        <profile> <!-- defines our default persistence provider -->
            <id>hibernate</id>
            <activation>
                <property> <!-- use this property to name alt persistence provider -->
                    <name>!jpa</name>
                </property>
            </activation>
            <dependencies>
                <dependency>
                    <groupId>org.hibernate</groupId>
                    <artifactId>hibernate-entitymanager</artifactId>
                    <version>3.4.0.GA</version>
                    <scope>test</scope>
                </dependency>
                <dependency>
                    <groupId>org.hibernate</groupId>
                    <artifactId>hibernate-core</artifactId>
                    <version>3.3.1.GA</version>
                    <scope>test</scope>
                </dependency>
                <dependency>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-log4j12</artifactId>
                    <version>1.5.2</version>
                    <scope>test</scope>
                </dependency>
            </dependencies>
        </profile>
---

    * Add the standard database setup and teardown scripts. This allows us
    to create a legacy database schema and write classes that map to that
    schema. We will later have the persistence provider create the schema
    for us when we are in quick prototype mode.

---
        <profile>
            <id>testing</id>
            <activation>
                <property>
                    <name>!maven.test.skip</name>
                </property>
            </activation>

            <build>
                <plugins>
                    <plugin>
                        <groupId>org.codehaus.mojo</groupId>
                        <artifactId>sql-maven-plugin</artifactId>
                        <version>1.0</version>

                        <dependencies>
                            <dependency>
                                <groupId>hsqldb</groupId>
                                <artifactId>hsqldb</artifactId>
                                <version>1.8.0.4</version>
                            </dependency>
                        </dependencies>

                        <configuration>
                            <username>${jdbc.user}</username>
                            <password>${jdbc.password}</password>
                            <driver>${jdbc.driver}</driver>
                            <url>${jdbc.url}</url>
                        </configuration>

                        <executions>

                        <!-- place execution elements here  -->

                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
---

    * Configure the sql-maven-plugin executions element to run any drop 
    scripts before running tests.

---
        <execution>
            <id>drop-db-before-test</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>main/resources/ddl/**/*drop*.ddl</include>
                    </includes>
                </fileset>
                <onError>continue</onError>
            </configuration>
        </execution>
---

    * Configure the sql-maven-plugin executions element to run any scripts 
    to create schema before running tests.

---
        <execution>
            <id>create-db-before-test</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>main/resources/ddl/**/*create*.ddl</include>

                    </includes>
                </fileset>
                <print>true</print>
            </configuration>
        </execution>
---

    * Configure the sql-maven-plugin executions element to run any populate 
    scripts to add rows to the database before running tests.

---
        <execution>
            <id>populate-db-before-test</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>test/resources/ddl/**/*populate*.ddl</include>
                    </includes>
                </fileset>
            </configuration>
        </execution>
---

    * Configure the sql-maven-plugin executions element to run any drop
    scripts after testing. You may want to comment this out if you want
    to view database changes in a GUI after the test.

---
        <execution>
            <id>drop-db-after-test</id>
            <phase>test</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>main/resources/ddl/**/*drop*.ddl</include>     
                        </includes>
                </fileset>
            </configuration>
        </execution>
---

    * Build and run the tests.


** {Part D}: Test Entity Manager Functions

    [Note:] The following changes are all made to the EntityMgrTest.java
    JUnit test class. Everything is being done within this file to 
    keep things simple. This test case is playing the role of the 
    business and persistence logic.

    []

    * add a testCreate() method to test the 
    functionality of EntityManager.create(). This will add an object to
    the database once associated with a transaction.

---
    public void testCreate() {
        log.info("testCreate");
        
        Auto car = new Auto();
        car.setMake("Chrysler");
        car.setModel("Gold Duster");
        car.setColor("Gold");
        car.setMileage(60*1000);
        
        log.info("creating auto:" + car);                        
        em.persist(car);        
    }
---
---
 -testCreate
 -creating auto:myorg.entitymgrex.Auto@140984b, id=0, make=Chrysler, model=Gold Duster, color=Gold, mileage=60000
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@3ac93e
 -EM_AUTO:myorg.entitymgrex.Auto@140984b, id=1, make=Chrysler, model=Gold Duster, color=Gold, mileage=60000
 -removed 1 rows
---

    * add a testMultiCreate() to test creating several objects. This should 
    also help verify that unique primary keys are being generated.

---
   public void testMultiCreate() {
        log.info("testMultiCreate");
        for(int i=0; i<5; i++) {
            Auto car = new Auto();
            car.setMake("Plymouth " + i);
            car.setModel("Grand Prix");
            car.setColor("Green");
            car.setMileage(80*1000);            
            log.info("creating auto:" + car);                        
            em.persist(car);        
        }
    }
---
---
 -testMultiCreate
 -creating auto:myorg.entitymgrex.Auto@c3e9e9, id=0, make=Plymouth 0, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@31f2a7, id=0, make=Plymouth 1, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@131c89c, id=0, make=Plymouth 2, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@1697b67, id=0, make=Plymouth 3, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@24c4a3, id=0, make=Plymouth 4, model=Grand Prix, color=Green, mileage=80000
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@1e9c82e
 -EM_AUTO:myorg.entitymgrex.Auto@c3e9e9, id=2, make=Plymouth 0, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@31f2a7, id=3, make=Plymouth 1, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@131c89c, id=4, make=Plymouth 2, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@1697b67, id=5, make=Plymouth 3, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@24c4a3, id=6, make=Plymouth 4, model=Grand Prix, color=Green, mileage=80000
---

    * add a testFind() to test the ability to find an object by its 
    primary key value.

---
   public void testFind() {
        log.info("testFind");
        
        Auto car = new Auto();
        car.setMake("Ford");
        car.setModel("Bronco II");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car2 = em.find(Auto.class, car.getId());
        assertNotNull("car not found:" + car.getId(), car2);
        log.info("found car:" + car2);
    }
---
---
 -testFind
 -creating auto:myorg.entitymgrex.Auto@aae86e, id=0, make=Ford, model=Bronco II, color=Red, mileage=0
 -found car:myorg.entitymgrex.Auto@aae86e, id=7, make=Ford, model=Bronco II, color=Red, mileage=0
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@97d026
 -EM_AUTO:myorg.entitymgrex.Auto@aae86e, id=7, make=Ford, model=Bronco II, color=Red, mileage=0
---

    * add a getReference() to test the ability to get a reference to an
    object. With such a shallow object, this will act much like find().

---
    public void testGetReference() {
        log.info("testGetReference");
        
        Auto car = new Auto();
        car.setMake("Ford");
        car.setModel("Escort");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car2 = em.getReference(Auto.class, car.getId());
        assertNotNull("car not found:" + car.getId(), car2);
        log.info("found car:" + car2);        
    }
---
---
 -testGetReference
 -creating auto:myorg.entitymgrex.Auto@608760, id=0, make=Ford, model=Escort, color=Red, mileage=0
 -found car:myorg.entitymgrex.Auto@608760, id=8, make=Ford, model=Escort, color=Red, mileage=0
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@157ea4a
 -EM_AUTO:myorg.entitymgrex.Auto@608760, id=8, make=Ford, model=Escort, color=Red, mileage=0
---

    * add a testUpdate() method to test the ability to have the setter()
    of a managed ubject update the database.

---
    public void testUpdate() {
        log.info("testUpdate");
        
        Auto car = new Auto();
        car.setMake("Pontiac");
        car.setModel("Gran Am");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        for(int mileage=car.getMileage(); mileage<(100*1000); mileage+=20000) {
            //here's where the update is done
            car.setMileage(mileage);
            
            //commit the update to the database for query 
            em.getTransaction().begin();
            em.getTransaction().commit();
            
            //inspect database for value
            int value = getMileage(car.getId());
            assertTrue("unexpected mileage:" + value, value == mileage);
            log.info("found mileage:" + value);        
        }
        
    }

    private int getMileage(long id) {
        Query query = 
            em.createQuery("select a.mileage from Auto as a where a.id=:pk");
        query.setParameter("pk", id);
        return (Integer)query.getSingleResult();        
    }
---
---
 -testUpdate
 -creating auto:myorg.entitymgrex.Auto@6a3960, id=0, make=Pontiac, model=Gran Am, color=Red, mileage=0
 -found mileage:0
 -found mileage:20000
 -found mileage:40000
 -found mileage:60000
 -found mileage:80000
 -EM_AUTO:myorg.entitymgrex.Auto@6a3960, id=9, make=Pontiac, model=Gran Am, color=Red, mileage=80000
---

    * add a testMerge() method to test the ability to perform updates based
    on the current values of a detached object. Note that we are using
    Java serialization to simulate sending a copy of the object to/from a
    remote process and then performing the merge based on the updated
    object.

---
    public void testMerge() throws Exception {
        log.info("testMerge");
        
        Auto car = new Auto();
        car.setMake("Chrystler");
        car.setModel("Concord");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        car = em.merge(car); //using merge to persist new
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        for(int mileage=(10*1000); mileage<(100*1000); mileage+=20000) {
            //simulate sending to remote system for update
            Auto car2 = updateMileage(car, mileage);
            
            //verify the object is not being managed by the EM
            assertFalse("object was managed", em.contains(car2));
            assertTrue("object wasn't managed", em.contains(car));
            assertTrue("mileage was same", 
                    car.getMileage() != car2.getMileage());
            
            //commit the update to the database for query 
            em.merge(car2);
            assertTrue("car1 not merged:" + car.getMileage(), 
                    car.getMileage() == mileage);
            em.getTransaction().begin();
            em.getTransaction().commit();
            
            //inspect database for value
            int value = getMileage(car.getId());
            assertTrue("unexpected mileage:" + value, value == mileage);
            log.info("found mileage:" + value);        
        }        
    }
    
    private Auto updateMileage(Auto car, int mileage) throws Exception {
        //simulate sending the object to a remote system
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(car);
        oos.close();
        
        //simulate receiving an update to the object from remote system
        ByteArrayInputStream bis = 
            new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        Auto car2 = (Auto)ois.readObject();
        ois.close();
        
        //here's what they would have changed in remote process 
        car2.setMileage(mileage);
        
        return car2;
    }
---
---
 -testMerge
 -creating auto:myorg.entitymgrex.Auto@147358f, id=0, make=Chrystler, model=Concord, color=Red, mileage=0
 -found mileage:10000
 -found mileage:30000
 -found mileage:50000
 -found mileage:70000
 -found mileage:90000
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@1b4c1d7
 -EM_AUTO:myorg.entitymgrex.Auto@147358f, id=10, make=Chrystler, model=Concord, color=Red, mileage=90000
---

    * add a testRemove() method to verify that we can delete objects from 
    the database.

---
    public void testRemove() {
        log.info("testRemove");
        
        Auto car = new Auto();
        car.setMake("Jeep");
        car.setModel("Cherokee");
        car.setColor("Green");
        car.setMileage(30*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);

        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car2 = em.find(Auto.class, car.getId());
        assertNotNull("car not found:" + car.getId(), car2);
        log.info("found car:" + car2);
        
        //now remove the car
        log.info("removing car:" + car);
        em.remove(car);
        //we need to associate the em with a transaction to  
        //physically remove from database
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car3 = em.find(Auto.class, car.getId());
        assertNull("car found", car3);
    }    
---
---
 -testRemove
 -creating auto:myorg.entitymgrex.Auto@28305d, id=0, make=Jeep, model=Cherokee, color=Green, mileage=30000
 -found car:myorg.entitymgrex.Auto@28305d, id=11, make=Jeep, model=Cherokee, color=Green, mileage=30000
 -removing car:myorg.entitymgrex.Auto@28305d, id=11, make=Jeep, model=Cherokee, color=Green, mileage=30000
---

** {Part E}: Automatically Generating Schema

    In part B, you manually created a set of DDL files to create schema, 
    delete rows from the schema in the database, and drop the schema
    from the database. Since your persistence provider knows how to
    work with schema, you can optionally get it to create schema for 
    you rather than generating it manually. Even if you are working with
    legacy schema (and won't be changing the database), it is extremely
    helpful to see the persistence providers version of the schema to
    be able to more quickly determine a mis-match in the mapping rather
    than waiting until runtime testing. In order to add schema generation
    to your projects you can add one of the following; runtime schema 
    generation or compile-time schema generation. Runtime schema generation
    is fine for examples and small prototypes, but compile-time 
    generation is suitable for more realistic development scenarios.

    * runtime schema generation can be added to your project by adding the
    following property to your persistence-unit properties.  Coldstart
    your database, comment out your SQL plugin, and re-run your tests
    if you want to verify the above will create the database at runtime.

---
   <property name="hibernate.hbm2ddl.auto" value="create"/> 
---

    * compile-time schema generation can be added to your project with
    the following plugin entry. Add the following to your pom.xml plugin
    area, re-run your compilation, and look at the files generated
    into target/classes/ddl

---
        <plugin>
            <artifactId>hibernate3-maven-plugin</artifactId>
            <groupId>org.codehaus.mojo</groupId>
            <version>2.0</version>
            <executions>
                <execution>
                    <id>generate-drop-ddl</id>
                    <phase>compile</phase>
                    <goals>
                        <goal>hbm2ddl</goal>
                    </goals>
                    <configuration>
                        <componentProperties>
                            <outputfilename>
                                ${pom.artifactId}-dropGEN.ddl
                            </outputfilename>
                            <drop>true</drop>
                            <create>false</create>
                        </componentProperties>
                    </configuration>
                </execution>
                <execution>
                    <id>generate-create-ddl</id>
                    <phase>compile</phase>
                    <goals>
                        <goal>hbm2ddl</goal>
                    </goals>
                    <configuration>
                        <componentProperties>
                            <outputfilename>
                                ${pom.artifactId}-createGEN.ddl
                            </outputfilename>
                            <drop>false</drop>
                            <create>true</create>
                        </componentProperties>
                    </configuration>
                </execution>
            </executions>
            <configuration>
                <components>
                    <component>
                        <name>hbm2ddl</name>
                        <implementation>
                            jpaconfiguration
                        </implementation>
                        <outputDirectory>
                            target/classes/ddl
                        </outputDirectory>
                    </component>
                </components>
                <componentProperties>
                    <persistenceunit>
                        entityMgrEx
                    </persistenceunit>
                    <export>false</export>
                    <format>true</format>
                </componentProperties>
            </configuration>
        </plugin>
---

---
target/classes/
...
|-- ddl
|   |-- emauto_create.ddl
|   |-- emauto_delete.ddl
|   |-- emauto_drop.ddl
|   |-- entityMgrEx-createGEN.ddl
|   `-- entityMgrEx-dropGEN.ddl
...
---
