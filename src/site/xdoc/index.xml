<?xml version="1.0"?>
<document>
  <properties>
    <title>Enterprise Java (605.784.31) Root</title>
    <author email="jcstaff@apl.jhu.edu">jcstaff@apl.jhu.edu</author>
  </properties>
  <body>
    <section name="Enterprise Java (605.784.31) Root">
      <p>
      This is the course home page for the Enterprise Java Course
      (605.784), taught at John's Hopkins University, Engineering
      Programs for Professionals.  

      This site will be populated as the
      semester progresses and topics are addressed. If you are looking
      for a version of the full content for ejava-javaee, refer to
      <a href="http://webdev.apl.jhu.edu/~jcs/legacy-ejava-javaee">
      http://webdev.apl.jhu.edu/~jcs/legacy-ejava-javaee</a>.
      </p>
      <p>
      Legal Disclaimer: The information and opinions expressed within the
      materials located on this site are the personal contributions of
      Jim Stafford. Content published here is not reviewed or approved by
      my employers (The Johns Hopkins University and SRA International)
      before it is posted and does not necessarily represent the views
      and opinions of my employers.
      </p>
      <subsection name="What's New" id="whatsnew">
      <ul>
          <li>2008-11-18: Posted JMS and Async updates</li>
          <li>2008-11-11: Posted Security updates</li>
          <li>2008-11-04: Posted WEB Tier updates</li>
          <li>2008-10-29: Posted EJB Transaction updates</li>
          <li>2008-10-21: Posted EJB Session Bean updates</li>
          <li>2008-10-12: Posted Callbacks and Listeners updates</li>
          <li>2008-10-12: Posted Inheritance updates</li>
          <li>2008-10-05: Posted Queries and EJB-QL updates</li>
          <li>2008-10-01: Posted ORM Relationships updates</li>
          <li>2008-09-22: Posted Core ORM updates</li>
          <li>2008-09-15: Posted EntityManager updates</li>
          <li>2008-09-09: Posted JDBC and JPA materials</li>
          <li>2008-09-01: Posted initial class site</li>
      </ul>
      </subsection>
      <subsection name="Class To Do" id="todo">
      <ul>
          <li>Finish security configuration, implementation, and testing</li>
          <li>Add JMS configuration file to JBoss server. Be sure
          to keep a copy in your source tree and refer to file in 
          project README if you don't auto-deploy the file.</li>
          <li>Design your JMS message type(s). Write and test a utility
          class that publishes the messages. If this class ideally
          would be plaved in with the BLImpl classes. However, if
          it publishes DTO classes, the DTOs may have to get moved in
          with the BO project to satisfy dependency constraints.</li>
          <li>Implement a Java SE Client to receive and log the JMS
          messages. This client can be placed in BLImpl, must use a
          selector, and be launchable by the grader using an Ant script.
          The Ant script can be part of either the BLImpl or RMI Test
          project. See class examples on how write the Ant script.</li>
      </ul>
      </subsection>
      <subsection name="Things you should have finished!" id="completed">
      <ul>
      <li><ul>
          <li>Start project 3</li>
          <li>Add user.properties and roles.properties to eSales project</li>
          <li>Assign EJB to security-domain "other".
          The RMI Tests should fail access at this point.</li>

          <li>Specify required roles to access each EJB method</li>
          <li>Add a java.security.auth.login.config to the RMI Test client</li>
          <li>Add a LoginContext with a CallbackHandler. The RMI Tests should 
          be able to access the EJB methods they are authorized to access.
          You should have at least one test that verifies an unauthorized
          user is refused access.</li>
          <li>Assign WAR to security-domain "java:/jaas/other"</li>
          <li>Add security-constraint elements to the WAR web.xml. The 
          user should be prompted for a login at this point and be able to
          access web pages and EJB methods that they are authorized for
          and be refused access to what they are un-authorized to access</li>
          <li>Eliminate access to any information or option the user does
          not have access to see or use</li>
          <li>Eliminate the passing of userId information when the appropriate
          means is to obtain through the EJB or WARs security context. Note
          that eBidbot will still need to pass the userId for bids. However,
          it should run-as a esales-trusted user.</li>
      </ul></li>
      <li><ul>
          <li>Finish implementing the remainder of the remote methods,
          adding DTOs where necessary, and testing from the RMI Client</li>

          <li>Add a WAR project to eSales and register it with the 
          parent project.</li>
          <li>Declare the project as type=war and make sure to 
          declare all dependencies in such a way that no jars 
          deployed with the EAR are duplicated in WEB-INF/lib. This
          is normally done by declaring all dependencies as 
          scope=provided.</li>
          <li>Add a controller servlet and have it locate your TestUtilEJB
          in the init() method. You may use either the @Local or @Remote
          interface of the EJB.  You may add any properties to locate
          the EJB within the servlet context within the web.xml</li>

          <li>Add a JSP main page and add an option to invoke controller
          servlet with a request to invoke the TestUtilEJB.ping() method.
          Verify the init() was called and verify the TestUtilEJB
          was successfully located.</li>
          <li>Add an action class to the controller servlet that
          will invoke the TestUtilEJB.ping() method(). Verify the EJB
          is now being called.</li>
          <li>Add a JSP to display the success or error invoking
          the EJB. Add a RequestDispatcher to the action class to
          forward the result information to the JSP View. You may place
          this view within the WEB-INF directory to prevent it from 
          being called outside the framework.</li>
          <li>Add the menu options, action classes, and results view
          for the resetAll() and populate() use cases. Consider adding
          these and the ping() method on a separate menu with an "admin"
          folder to help secure these operations later.</li>
          <li>Add the menu options, action classes, and results view
          for the remaining use cases. Consider separating adding
          separate menus for anonymous and logged in user access
          for the separate methods. During project 2 you will not 
          have a login context, so you will need to temporarily 
          prompt and pass the userId through the Web Tier.</li>

          <li>Add the necessary WAR to the eBidbot application. 
          This WAR should get all of its behavior from eBidbotEJB
          and not interact directly with eSalesEJB.</li>
      </ul></li>
      <li><ul>
          <li>Add the remaining session beans, remote interfaces,
          business logic to your eSales application and complete
          eSales end-to-end testing from the RMI Test client.</li>
          <li>Implement the eBidbit BLImpl using the @Remote interface
          of the eSales EJB(s). You can either test using a 
          stub implementation within eBidbotImpl or interface
          with the eSalesEJB that is deployed on the server. 
          Feel free to have this project depend on the eSalesEAR
          already being deployed to the server to avoid redundant 
          deployment work between the eSalesTest and eBidbotBLImpl
          projects.</li>
          <li>Implement the EJB tier for eBidbot. Attempt to reuse
          your BOs as DTOs instead of creating new classes.</li>
          <li>Finish end-to-end testing from an RMI Test client 
          within the eBidbot project. You will need the full end-to-end
          testing implemented within eBidbot to satisfy the end-to-end
          testing dependency on both eSales and eBidbot.</li>
          <li>Add @Transaction declarations</li>
          <li>Implement the transaction test requirement. You may
          want to place logic for the transaction test within 
          the TestUtilEJB since you may end up undesirable business
          logic in order to demonstrate the rollback of a transaction.
          </li>
      </ul></li>
      <li><ul>
          <li>Look over the specification for project 2.</li>
          <li>add an EJB module to your project.  Add the pom.xml
          (make sure the packaging type=ejb) and a dependency on
          your business logic. Add a src/main/java folder, and
          src/main/resources/META-INF folder.</li>
          <li>add the TestUtilRemote interface for the TestUtilEJB. Have
          the first method be a simple ping() method that accepts and
          returns no arguments.</li>
          <li>add a @Stateless TestUtilEJB that implements the @Remote
          interface. Add a @PostConstruct method that does nothing more
          than print some debug.</li>
          <li>add the ping() implementation method to the EJB.</li>
          <li>build the EJB at the leaf level. Add the EJB module
          to the parent pom.xml and re-build that that level as well.
          Be sure to execute the mvn "install" goal to place the EJB
          within the local repository.</li>

          <li>add an EAR module to your project. Add the pom.xml
          (make sure the packaging type=ear) and a dependency on
          the EJB.</li>
          <li>build the EAR at the leaf level. Add the EAR module 
          to the parent pom.xml are re-build that level as well.
          Be sure to execute the mvn "install" goal to place the EAR
          within the local repository.</li>

          <li>add an RMI Test module to your project. Add the pom.xml
          (packaging type=jar) and a dependency on your EAR. Add the
          cargo deployment configuration for the EAR. Add
          a src/test/java folder.</li>
          <li>Add the JNDI properties to the project to resolve the
          JNDI tree.</li>
          <li>add a JUnit test with a setUp() method that instantiates
          an InitialContext and locates the @Remote interface of 
          TestUtilEJB.</li>
          <li>create a testMethod() to invoke the ping() method of
          TestUtilEJB. Verify the debug output from the EJB is printed
          to the JBoss console. Make conf/jboss-log4j.xml updates
          to allow your DEBUG output to be displayed.</li>
          
          <li>Add a persistence.xml and EntityManager to your EJB
          and verify you resolved the EntityManager within your 
          @PostConstruct.</li>
          <li>Add your TestUtilImpl business logic to the TestUtilEJB
          and add an end-to-end test of the resetAll() logic using the
          EntityManager.</li>
          <li>Configure your EJB with a javax.sql.DataSource for ejavaDS
          and implement an end-to-end test of populate().</li>

          <li>Begin adding the other session beans, remote interfaces,
          business logic integration, and RMI tests for project 2.</li>
      </ul></li>
      <li><ul>
          <li>Finish up project 1 and submit to the graders according
          to the submission criteria.</li>
          <li>Perform any desired post-submission refactoring of your 
          project 1 implementation prior to re-use within project 2.</li>
          <li>Look over the specification for project 2.</li>
          <li>Begin looking at ejbsessionBank example application; 
          which forms an EJB, EAR, RMI Test, as well as a WAR Client.
          These will be key component types within project 2.</li>
      </ul></li>
      <li><ul>
          <li>Refactor or implement any necessary functionality using
          Queries and EJB-QL.</li>
          <li>Finish adding required business logic for end-to-end 
          testing.</li>
      </ul></li>
      <li><ul>
          <li>Enhance your Business Objects to include JPA relationships.
          Be sure to include proper deletion as a part of your cleanup
          in your test case. This now must take foreign key constraints
          into consideration (e.g., can't delete an Auction when you
          still have a Bid)</li>
          <li>Begin adding required business logic to satisfy the
          specified end-to-end scenario. Add unit tests to verify
          the functionality of the individual business logic methods.</li>
          <li>Implement your ingest capability. Provide some sort of 
          verification that something was successfully ingested. I would
          suggest no tying the verification to values specific to the
          file ingested (i.e., just check added entities >= 1 versus
          = 1000)</li>
          <li>Implement your populate() method in terms of the ingest.
          Encapsulate it an your resetAll() within a TestUtilImpl class.
          Re-use this class as a part of your unit testing.
          </li>
      </ul></li>
      <li><ul>
          <li>Create the remainder of your Business Objects for the
          project.</li>
          <li>Enhance your testing of the Business Objects to include
          anticipated use cases for the project (e.g., adding a bid to
          auction, closing an auction, etc.)</li>
          <li>Mature your JDBC DAO implementations to handle persisting
          the additional classes.</li>
          <li>Declare the Business Objects as Entities and map the classes
          to tables and columns in your database. Your JDBC and JPA
          DAOs should be using the same database tables at this point.
          You can attempt to use the JPA DAO to help test the JDBC DAO
          implementation.  Mark relationships and problem fields as
          @Transient at this point in time.</li>
          <li>If you have not yet done so, please submit a copy of your
          project to me for early sanity check. It should be in a known
          and stable state where it will build from the root with
          known and documented issues. I want to see your project
          at least once early in the project and as you run into 
          any significant issues.</li>
      </ul></li>
      <li><ul>
          <li>Go through the EntityManager Exercise</li>
          <li>Look over the class project example implementation</li>
          <li>Add JPA/Hibernate infrastructure to your DAO project
          DAO. This should at least consist of a successful connection to the DB.
          You are done with this step when you have a separate JPA JUnit test
          for the DAO and the setUp() method is able to create an EntityManager.</li>
          <li>Define your business objects as being an @Entity and identify the 
          primary key property with the @Id tag. Make sure you have a default
          constructor, but leave other things default for now. Annontate all
          collections with @Transient annotation. We are not ready to cover 
          relationships just yet.</li>

          <li>Design and implement an initial JPA implementation for your DAO</li>

          <li>Design and implement a set of unit tests for your JPA DAO. Note 
          how the default schema for the @Entities may not match up with 
          your DB schema at this point when you run the tests.</li>

          <li>Add JPA @Annotations to your class project business objects to properly 
          map the @Entities to the database schema design you created last time
          (primarily a topic for next week)</li>

          <li>Refine your BOs, DB Schema, and DAO based on your understanding 
          to date.</li>

          <li>Move forward with your DB Schema design, BO classes, and JDBC DAO
          implementation if there is extra time. You can turn off your JPA 
          JUnit Test by adding an excludes definition to your surefire 
          configuration. Perform a google search on "surefire excludes" for
          details.</li>

          <li>Send me a copy of your
          project, in a stable, known state, sometime this week;
          ideally by early Sunday evening. You do not have to be complete
          with the TODO items, but you should be able to describe what
          you know you have left to complete and describe any issues
          that have gotten in your way. This will not be graded, but
          that should not stop you from turning it in and making an
          honest effort to have the TODOs completed.</li>
      </ul></li>
      <li><ul>
          <li>Go through the JDBC Exercise</li>
          <li>Look over the class project and post any questions.</li>
          <li>Establish your project directory structure and perform a build from the root.</li>
          <li>Design and implement a few business objects for your class project.</li>
          <li>Design and implement a set of unit tests for your business objects.</li>
          <li>Design and implement the test infrastructure for your
          DAO. This should at least consist of a successful connection to the DB.</li>
          <li>Design a draft DB schema for your implemented business objects. This should go in 
          your DAO project. </li>
          <li>Implement a way to create your schema in the DB as a part of your DAO testing.</li>
          <li>Design and implement an initial DAO interface and JDBC implementation for your business objects.
          You only need a create method for the project.</li>
          <li>Consider all BO, DB Schema, and DAO work as draft prototypes at this time to get
          something end-to-end running. You will refine over next several weeks.</li>
      </ul></li>
      <li><ul>
          <li>register for newsgroup and setup e-mail handling (all e-mails will have
          ejava_class in subject)</li>
          <li>post at least 1 test message to newsgroup</li>
          <li>setup development environment by going through exercises 0 and 1</li>
      </ul></li>
      <li><ul>
          <li>enjoyed your summer!</li>
      </ul></li>
      </ul>
      </subsection>
    </section>
  </body>
</document>
