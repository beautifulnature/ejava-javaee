<?xml version="1.0"?>
<document>
  <properties>
    <title>Enterprise Java (605.784.31) Root</title>
    <author email="jcstaff@apl.jhu.edu">jcstaff@apl.jhu.edu</author>
  </properties>
  <body>
    <section name="Enterprise Java (605.784.31) Root">
      <p>
      This is the course home page for the Enterprise Java Course
      (605.784), taught at John's Hopkins University, Engineering
      Programs for Professionals.  

      This site will be populated as the
      semester progresses and topics are addressed. If you are looking
      for a version of the full content for ejava-javaee, refer to
      <a href="http://webdev.apl.jhu.edu/~jcs/legacy-ejava-javaee">
      http://webdev.apl.jhu.edu/~jcs/legacy-ejava-javaee</a>.
      </p>
      <p>
      Legal Disclaimer: The information and opinions expressed within the
      materials located on this site are the personal contributions of
      Jim Stafford. Content published here is not reviewed or approved by
      my employers (The Johns Hopkins University and SRA International)
      before it is posted and does not necessarily represent the views
      and opinions of my employers.
      </p>
      <subsection name="What's New" id="whatsnew">
      <ul>
          <li>2008-10-21: Posted EJB Session Bean updates</li>
          <li>2008-10-12: Posted Callbacks and Listeners updates</li>
          <li>2008-10-12: Posted Inheritance updates</li>
          <li>2008-10-05: Posted Queries and EJB-QL updates</li>
          <li>2008-10-01: Posted ORM Relationships updates</li>
          <li>2008-09-22: Posted Core ORM updates</li>
          <li>2008-09-15: Posted EntityManager updates</li>
          <li>2008-09-09: Posted JDBC and JPA materials</li>
          <li>2008-09-01: Posted initial class site</li>
      </ul>
      </subsection>
      <subsection name="Class To Do" id="todo">
      <ul>
          <li>Look over the specification for project 2.</li>
          <li>add an EJB module to your project.  Add the pom.xml
          (make sure the packaging type=ejb) and a dependency on
          your business logic. Add a src/main/java folder, and
          src/main/resources/META-INF folder.</li>
          <li>add the TestUtilRemote interface for the TestUtilEJB. Have
          the first method be a simple ping() method that accepts and
          returns no arguments.</li>
          <li>add a @Stateless TestUtilEJB that implements the @Remote
          interface. Add a @PostConstruct method that does nothing more
          than print some debug.</li>
          <li>add the ping() implementation method to the EJB.</li>
          <li>build the EJB at the leaf level. Add the EJB module
          to the parent pom.xml and re-build that that level as well.
          Be sure to execute the mvn "install" goal to place the EJB
          within the local repository.</li>

          <li>add an EAR module to your project. Add the pom.xml
          (make sure the packaging type=ear) and a dependency on
          the EJB.</li>
          <li>build the EAR at the leaf level. Add the EAR module 
          to the parent pom.xml are re-build that level as well.
          Be sure to execute the mvn "install" goal to place the EAR
          within the local repository.</li>

          <li>add an RMI Test module to your project. Add the pom.xml
          (packaging type=jar) and a dependency on your EAR. Add the
          cargo deployment configuration for the EAR. Add
          a src/test/java folder.</li>
          <li>Add the JNDI properties to the project to resolve the
          JNDI tree.</li>
          <li>add a JUnit test with a setUp() method that instantiates
          an InitialContext and locates the @Remote interface of 
          TestUtilEJB.</li>
          <li>create a testMethod() to invoke the ping() method of
          TestUtilEJB. Verify the debug output from the EJB is printed
          to the JBoss console. Make conf/jboss-log4j.xml updates
          to allow your DEBUG output to be displayed.</li>
          
          <li>Add a persistence.xml and EntityManager to your EJB
          and verify you resolved the EntityManager within your 
          @PostConstruct.</li>
          <li>Add your TestUtilImpl business logic to the TestUtilEJB
          and add an end-to-end test of the resetAll() logic using the
          EntityManager.</li>
          <li>Configure your EJB with a javax.sql.DataSource for ejavaDS
          and implement an end-to-end test of populate().</li>

          <li>Begin adding the other session beans, remote interfaces,
          business logic integration, and RMI tests for project 2.</li>
      </ul>
      </subsection>
      <subsection name="Things you should have finished!" id="completed">
      <ul>
      <li><ul>
          <li>Finish up project 1 and submit to the graders according
          to the submission criteria.</li>
          <li>Perform any desired post-submission refactoring of your 
          project 1 implementation prior to re-use within project 2.</li>
          <li>Look over the specification for project 2.</li>
          <li>Begin looking at ejbsessionBank example application; 
          which forms an EJB, EAR, RMI Test, as well as a WAR Client.
          These will be key component types within project 2.</li>
      </ul></li>
      <li><ul>
          <li>Refactor or implement any necessary functionality using
          Queries and EJB-QL.</li>
          <li>Finish adding required business logic for end-to-end 
          testing.</li>
      </ul></li>
      <li><ul>
          <li>Enhance your Business Objects to include JPA relationships.
          Be sure to include proper deletion as a part of your cleanup
          in your test case. This now must take foreign key constraints
          into consideration (e.g., can't delete an Auction when you
          still have a Bid)</li>
          <li>Begin adding required business logic to satisfy the
          specified end-to-end scenario. Add unit tests to verify
          the functionality of the individual business logic methods.</li>
          <li>Implement your ingest capability. Provide some sort of 
          verification that something was successfully ingested. I would
          suggest no tying the verification to values specific to the
          file ingested (i.e., just check added entities >= 1 versus
          = 1000)</li>
          <li>Implement your populate() method in terms of the ingest.
          Encapsulate it an your resetAll() within a TestUtilImpl class.
          Re-use this class as a part of your unit testing.
          </li>
      </ul></li>
      <li><ul>
          <li>Create the remainder of your Business Objects for the
          project.</li>
          <li>Enhance your testing of the Business Objects to include
          anticipated use cases for the project (e.g., adding a bid to
          auction, closing an auction, etc.)</li>
          <li>Mature your JDBC DAO implementations to handle persisting
          the additional classes.</li>
          <li>Declare the Business Objects as Entities and map the classes
          to tables and columns in your database. Your JDBC and JPA
          DAOs should be using the same database tables at this point.
          You can attempt to use the JPA DAO to help test the JDBC DAO
          implementation.  Mark relationships and problem fields as
          @Transient at this point in time.</li>
          <li>If you have not yet done so, please submit a copy of your
          project to me for early sanity check. It should be in a known
          and stable state where it will build from the root with
          known and documented issues. I want to see your project
          at least once early in the project and as you run into 
          any significant issues.</li>
      </ul></li>
      <li><ul>
          <li>Go through the EntityManager Exercise</li>
          <li>Look over the class project example implementation</li>
          <li>Add JPA/Hibernate infrastructure to your DAO project
          DAO. This should at least consist of a successful connection to the DB.
          You are done with this step when you have a separate JPA JUnit test
          for the DAO and the setUp() method is able to create an EntityManager.</li>
          <li>Define your business objects as being an @Entity and identify the 
          primary key property with the @Id tag. Make sure you have a default
          constructor, but leave other things default for now. Annontate all
          collections with @Transient annotation. We are not ready to cover 
          relationships just yet.</li>

          <li>Design and implement an initial JPA implementation for your DAO</li>

          <li>Design and implement a set of unit tests for your JPA DAO. Note 
          how the default schema for the @Entities may not match up with 
          your DB schema at this point when you run the tests.</li>

          <li>Add JPA @Annotations to your class project business objects to properly 
          map the @Entities to the database schema design you created last time
          (primarily a topic for next week)</li>

          <li>Refine your BOs, DB Schema, and DAO based on your understanding 
          to date.</li>

          <li>Move forward with your DB Schema design, BO classes, and JDBC DAO
          implementation if there is extra time. You can turn off your JPA 
          JUnit Test by adding an excludes definition to your surefire 
          configuration. Perform a google search on "surefire excludes" for
          details.</li>

          <li>Send me a copy of your
          project, in a stable, known state, sometime this week;
          ideally by early Sunday evening. You do not have to be complete
          with the TODO items, but you should be able to describe what
          you know you have left to complete and describe any issues
          that have gotten in your way. This will not be graded, but
          that should not stop you from turning it in and making an
          honest effort to have the TODOs completed.</li>
      </ul></li>
      <li><ul>
          <li>Go through the JDBC Exercise</li>
          <li>Look over the class project and post any questions.</li>
          <li>Establish your project directory structure and perform a build from the root.</li>
          <li>Design and implement a few business objects for your class project.</li>
          <li>Design and implement a set of unit tests for your business objects.</li>
          <li>Design and implement the test infrastructure for your
          DAO. This should at least consist of a successful connection to the DB.</li>
          <li>Design a draft DB schema for your implemented business objects. This should go in 
          your DAO project. </li>
          <li>Implement a way to create your schema in the DB as a part of your DAO testing.</li>
          <li>Design and implement an initial DAO interface and JDBC implementation for your business objects.
          You only need a create method for the project.</li>
          <li>Consider all BO, DB Schema, and DAO work as draft prototypes at this time to get
          something end-to-end running. You will refine over next several weeks.</li>
      </ul></li>
      <li><ul>
          <li>register for newsgroup and setup e-mail handling (all e-mails will have
          ejava_class in subject)</li>
          <li>post at least 1 test message to newsgroup</li>
          <li>setup development environment by going through exercises 0 and 1</li>
      </ul></li>
      <li><ul>
          <li>enjoyed your summer!</li>
      </ul></li>
      </ul>
      </subsection>
    </section>
  </body>
</document>
