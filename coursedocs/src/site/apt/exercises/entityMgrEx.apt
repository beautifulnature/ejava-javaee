Exercise: Entity Manager

* Goals

    * Gain hands on experience building and testing a component
    that uses the Java Persistence API's EntityManager.

    * Apply lessons learned during example to student's current project.

* Objectives

    * {{{Part_A} Setup and Start Database}}

    * {{{Part_B} Create Core POM}}

    * {{{Part_C} Setup Database Schema}}

    * {{{Part_D} Setup JPA Persistence Unit}}

    * {{{Part_E} Setup JPA Test Project}}

    * {{{Part_F} Ready Project for Import Into Eclipse}}
    
    * {{{Part_G} Test Entity Manager Functions}}
    
    * {{{Part_H} Automatically Generate Schema}}

* Steps

    [Note:] Although this exercise will show you how to create each file,
    many of them are boilerplate from other exercises. If you already have
    the another exercise completed, you can consider starting 
    with a copy of that project and modifying it.

** {Part A}: Setup and Start Database

    * Prepare your environment to run the database in server mode for this
    exercise by following the instructions defined in 
    {{{../../coursedocs/605-784-site/docs/content/html/devenv-h2-setup.html}Exercise 0}}. 

    * Start the database and web server server in a directory where you wish 
    to create database files. Your h2.jar file source be located in 
    M2_REPO/com/h2database/h2/*/h2*.jar to name at least one location.
    Another location is JBOSS_HOME/modules/com/h2database/h2/main/h2*.jar

---
cd /tmp
java -jar h2.jar
---

    * This should result in a database server process and a  
    {{{http://127.0.1.1:8082/login.jsp}web page login displayed}}
    
    * Connect using the following URL. This should create an h2db directory
    relative to where you started your server. You can also provide a fully
    qualified path name.

---
Driver Class: org.h2.Driver
JDBC URL: jdbc:h2:./h2db/ejava
User Name: sa
Password:
---    

** {Part B}: Create Core POM

    Create the starting point for the exercise by defining a few core
    elements that will allow Maven and Eclipse to recognize the elements
    of your source tree.
    
    * Create a root directory for your project and populate with a pom.xml 
    file.
    
---
|-- pom.xml
---    

---
<?xml version="1.0"?>
<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>myorg.jpa</groupId>
    <artifactId>entityMgrEx</artifactId>
    <name>Entity Manager Exercise</name>
    <version>1.0-SNAPSHOT</version>

</project> 
---

    * Define a remote repository to use to download hibernate artifacts
---
   <!-- needed to resolve some hibernate dependencies -->
    <repositories>
        <repository>
            <id>jboss-nexus</id>
            <name>JBoss Nexus Repository</name>
            <url>https://repository.jboss.org/nexus/content/groups/public-jboss/</url>
        </repository>
    </repositories>
---


    * Add property definitions for versions of dependencies and plugins 
    we will be using.
    
---
    <properties>
        <jboss.host>localhost</jboss.host>
        <db.host>${jboss.host}</db.host>
        <maven-compiler-plugin.version>2.5.1</maven-compiler-plugin.version>
        <maven-surefire-plugin.version>2.12.2</maven-surefire-plugin.version>
        <sql-maven-plugin.version>1.4</sql-maven-plugin.version>        
        <commons-logging.version>1.0.4</commons-logging.version>
        <hibernate-jpa-2.0-api.version>1.0.1.Final</hibernate-jpa-2.0-api.version>
        <junit.version>4.10</junit.version>
        <log4j.version>1.2.13</log4j.version>
        <hibernate-entitymanager.version>4.0.1.Final</hibernate-entitymanager.version>
        <slf4j.version>1.6.1</slf4j.version>
        <h2db.version>1.3.168</h2db.version>
        <hibernate3-maven-plugin.version>3.0</hibernate3-maven-plugin.version>
        <hibernate3.version>3.6.0.Final</hibernate3.version>
    </properties>
---    

    * Add the src/main dependencies. This represents what your code depends
    upon at compile time and runtime. 

        * scope=compile is used when your src/main code depends on
        the artifact to compile and you wish the design of transitive
        dependency to automatically bring this dependency with the module.

        * scope=provided is used when your src/main code depends on the
        artifact to compile but you do not wish this automatically 
        be brought along when used with downstream clients. Normally
        this type of artifact is an API and the downstream client will
        be providing their own version of the API packaged with their
        provider.

---
    <dependencies>
        <dependency>
          <groupId>commons-logging</groupId>
          <artifactId>commons-logging</artifactId>
          <version>${commons-logging.version}</version>
          <scope>compile</scope>
        </dependency>
    
        <dependency>
            <groupId>org.hibernate.javax.persistence</groupId>
            <artifactId>hibernate-jpa-2.0-api</artifactId>
            <version>${hibernate-jpa-2.0-api.version}</version>
            <scope>provided</scope>
        </dependency>
        ...
    </dependencies>
---

    * Add the src/test standard dependencies. 

        * scope=test is used for anything that your src/test code
        depends upon (but not your src/main) or what your unit tests
        need at runtime to operate the test. For example, a module
        may declare a scope=test dependency on hypersonic to do 
        some local unit testing and then be ultimately deployed to
        a postgres server in a downstream client. In this case
        we are picking JUnit4 as the testing framework and log4j
        as the logging plugin for commons-logging.

---
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
          <groupId>log4j</groupId>
          <artifactId>log4j</artifactId>
          <version>${log4j.version}</version>
          <scope>test</scope>
        </dependency>    
---

    * Add a build section and begin by specifying that test resource files should be 
    filtered when copied into the target tree. We do this so we have a chance
    to replace the variables in persistence.xml with our specific database profile.

---
    <build>
        <!--tell the resource plugin to perform filtering on resources
            to fill in JDBC URL, etc. -->
        <testResources>
            <testResource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </testResource>
        </testResources>
    </build>
---

    * Add a plugin specification for Java 1.6. 

---
    <build>
        ...
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
            ...      
        </plugins>
    </build>
---

    * Add a definition for the maven-surefire-plugin so we can set 
    properties needed for testing. At this point, we are just allowing
    the argLine defined in the settings.xml to be optionally specified.
    We do not yet have a need for system properties, but the example
    below shows how -Dname=value would be specified within the 
    plugin configuration.

---
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
                <configuration>
                    <argLine>${surefire.argLine}</argLine>
                    <systemPropertyVariables>
                    <!--
                        <name>value</name>
                        -->
                    </systemPropertyVariables>
                </configuration>
            </plugin>            
---

    * Add a set of profiles that define H2 and Hibernate as our database and 
    persistence provider.

    [Note:] Profiles can be used to control which options are enabled at
    build time to make the module more portable. I also use them to help
    identify which dependencies are brought in for what reason -- especially
    for profiles that are configure to always activate. Feel free
    to declare these properties outside the scope of a profile since you will
    not be asked to port this example to alternate platforms.

    []

---
    <profiles>
        <profile> <!-- H2 server-based DB -->
            <id>h2srv</id>
            <activation>
                <property> 
                    <name>!jdbcdb</name>
                </property>
            </activation>
            <properties>
                  <jdbc.driver>org.h2.Driver</jdbc.driver>
                  <jdbc.url>jdbc:h2:tcp://${db.host}:9092/h2db/ejava</jdbc.url>
                  <jdbc.user>sa</jdbc.user>
                  <jdbc.password/>
                  <hibernate.dialect>
                      org.hibernate.dialect.H2Dialect
                  </hibernate.dialect>
            </properties>
            <dependencies>
                <dependency>
                    <groupId>com.h2database</groupId>
                    <artifactId>h2</artifactId>
                    <version>${h2db.version}</version>
                    <scope>test</scope>
                </dependency>
            </dependencies>
        </profile>


        <profile> <!-- defines our default persistence provider -->
            <id>hibernate</id>
            <activation>
                <property> <!-- use this property to name alt persistence provider -->
                    <name>!jpa</name>
                </property>
            </activation>

            <dependencies>
                <dependency>
                    <groupId>org.hibernate</groupId>
                    <artifactId>hibernate-entitymanager</artifactId>
                    <version>${hibernate-entitymanager.version}</version>
                    <scope>test</scope>
                </dependency>
                <dependency>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-log4j12</artifactId>
                    <version>${slf4j.version}</version>
                    <scope>test</scope>
                </dependency>
            </dependencies>
        </profile>
---

    * Perform a test of your pom.xml by issuing a sample build command.
    All should complete even though there is nothing yet in your source tree.
    
---
$ mvn clean test
---    

** {Part C}: Setup Database Schema

    You will first need some database schema to get started. Begin
    filling out your source tree by creating some schema files that
    will be used to create schema, delete rows, and drop schema.

    * Create a set of ddl scripts in src/main/resources/ddl to
    handle creating the schema, deleting rows in the schema, and
    dropping tables in the schema. Make sure each script has the 
    word "create", "delete", or "drop" in its file name to match 
    some search strings we'll use later. Have the database generate
    a value for the primary key. That value should not be allowed
    to be null.

---
`-- src
    |-- main
    |   |-- java
    |   `-- resources
    |       |-- ddl
    |       |   |-- emauto_create.ddl
    |       |   |-- emauto_delete.ddl
    |       |   `-- emauto_drop.ddl
    `-- test
        |-- java
        `-- resources
---

    [Note:] We could actually skip this step and have the persistence 
    provider create the table for us. That approach is great for quick
    Java-first prototypes. However, creating the schema outside of the
    persistence provider is a more realistic scenario for larger 
    developments.

    []

---
# src/main/resources/ddl/emauto_create.ddl
CREATE TABLE EM_AUTO (
    ID BIGINT generated by default as identity (start with 1) not null,
    MAKE VARCHAR(32),
    MODEL VARCHAR(32),
    COLOR VARCHAR(32),
    MILEAGE INT,

    CONSTRAINT em_autoPK PRIMARY KEY(ID)
)

# src/main/resources/ddl/emauto_delete.ddl
DELETE * FROM EM_AUTO;

# src/main/resources/ddl/emauto_drop.ddl
DROP TABLE EM_AUTO if EXISTS;
---

    * You can perform a sanity check of the above scripts by pasting them
    into the DB UI SQL area and executing.

    * Add the standard database setup and teardown scripts. This allows us
    to create a legacy database schema and write classes that map to that
    schema. We will later have the persistence provider create the schema
    for us when we are in quick prototype mode.

---
        <profile>
            <id>testing</id>
            <activation>
                <property>
                    <name>!maven.test.skip</name>
                </property>
            </activation>

            <build>
                <plugins>
                    <plugin>
                        <groupId>org.codehaus.mojo</groupId>
                        <artifactId>sql-maven-plugin</artifactId>        
                        <version>${sql-maven-plugin.version}</version>        
                    
                        <dependencies>
                            <dependency>
                                <groupId>com.h2database</groupId>
                                <artifactId>h2</artifactId>
                                <version>${h2db.version}</version>
                            </dependency>
                        </dependencies>
                    
                        <configuration>
                            <username>${jdbc.user}</username>
                            <password>${jdbc.password}</password>
                            <driver>${jdbc.driver}</driver>
                            <url>${jdbc.url}</url>          
                        </configuration>

                        <executions>

                        <!-- place execution elements here  -->

                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
---

    * Configure the sql-maven-plugin executions element to run any drop 
    scripts before running tests.

---
        <execution>
            <id>drop-db-before-test</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>main/resources/ddl/**/*drop*.ddl</include>
                    </includes>
                </fileset>
                <onError>continue</onError>
            </configuration>
        </execution>
---

    * Configure the sql-maven-plugin executions element to run any scripts 
    to create schema before running tests.

---
        <execution>
            <id>create-db-before-test</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>main/resources/ddl/**/*create*.ddl</include>

                    </includes>
                </fileset>
                <print>true</print>
            </configuration>
        </execution>
---

    * Configure the sql-maven-plugin executions element to run any populate 
    scripts to add rows to the database before running tests.

---
        <execution>
            <id>populate-db-before-test</id>
            <phase>process-test-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>test/resources/ddl/**/*populate*.ddl</include>
                    </includes>
                </fileset>
            </configuration>
        </execution>
---

    * Configure the sql-maven-plugin executions element to run any drop
    scripts after testing. You may want to comment this out if you want
    to view database changes in a GUI after the test.

---
        <execution>
            <id>drop-db-after-test</id>
            <phase>test</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <autocommit>true</autocommit>
                <fileset>
                    <basedir>${basedir}/src</basedir>
                    <includes>
                        <include>main/resources/ddl/**/*drop*.ddl</include>     
                        </includes>
                </fileset>
            </configuration>
        </execution>
---

    * Build and run the tests. The schema should show up in the DB UI.
    
** {Part D}: Setup JPA Persistence Unit

    Create the entity class(es), the persistence.xml, and associated 
    property file to define the persistence unit.
    
---
`-- src
    |-- main
    |   |-- java
    |   |   `-- myorg
    |   |       `-- entitymgrex
    |   |           `-- Auto.java
    |   `-- resources
    |       `-- META-INF
    |           `-- persistence.xml
    `-- test
        |-- java
        `-- resources
            `-- hibernate.properties
---

    * Create a (Plain Old Java Object (POJO)) Class to represent an
    automobile. Use class annotations to prvide the following:

        * @Entity annotation on the class to tell persistence provider 
        this is part of persistence unit

        * @Table(name="EM_AUTO") annotation on the class to match the 
        table name in the emauto_create.ddl file

        * properties to hold id:long, make:String, model:String, color:String,
        mileage:int.

        * a public getId():long to return the id field.

        * a private setId(long) to set the primary key. This will be called
        by the persistence provider. You may want to add a 
        @SuppressWarnings("unused") if your compiler is warning you that
        the private setId() is not being used within the class.

        * @Id annotation on the id attribute to tell the persistence 
        provider the id property is the primary key and to use 
        FIELD type access (versus get/setId() PROPERTY type access)

        * @GeneratedValue to tell the provider to generate primary keys
        for rows inserted for this entity.

        * make the class implement java.io.Serializable. 

---
package myorg.entitymgrex;

import java.io.Serializable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GenerationType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity @Table(name="EM_AUTO")
public class Auto implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
    private long id;
    private String make;
    private String model;
    private String color;
    private int mileage;

    public long getId() {
        return id;
    }
    @SuppressWarnings("unused")
    private void setId(long id) {
        this.id = id;
    }

    //more getter/setters go here
}
---

    * Add the remaining setter/getter methods to the class. If you are
    using Eclipse to author the class -- right click->Source->Generate
    Getters and Setters will generate all of this for you.  Since we
    are using generated primary key values, there is no immediate need
    for a constructor to set the id. If you add this later, remember to
    also add a default constructor, which was removed by the compiler
    when you manually add the first constructor.
    
---
    public String getMake() {
        return make;
    }
    public void setMake(String make) {
        this.make = make;
    }
    public int getMileage() {
        return mileage;
    }
    public void setMileage(int mileage) {
        this.mileage = mileage;
    }
    public String getModel() {
        return model;
    }
    public void setModel(String model) {
        this.model = model;
    }
    public String getColor() {
        return color;
    }
    public void setColor(String color) {
        this.color = color;
    }    
}
---

    * You may also want to add a public toString():String method to 
    conveniently print your Auto objects. Eclipse can also generate 
    that on demand and configurable.

---
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder
            .append("id=").append(id)
            .append(", make=").append(make)
            .append(", model=").append(model)
            .append(", color=").append(color)
            .append(", mileage=").append(mileage);
        return builder.toString();
    }    
---
    
    * Create a META-INF/persistence.xml file to define the 
    persistence unit for our jar file.

        * persistence-unit name: must match what we place in our JUnit test

        * provider: specify that this persistence unit is defined for 
        the org.hibernate.ejb.HibernatePersistence provider.

        * define provider-specific properties that tell the provider how to 
        obtain a connection to the database as well as some other configuration
        properties. 
        
            [Note:] The technique to add the provider-specific properties
            includes somewhat sensitive information like user credentials.
            If we place them in the persistence.xml file within the src/main
            tree, these properties will become part of our deployed 
            artifact. To avoid this, we will define them in a separate
            hibernate.properties file placed in the src/test tree.
        
        []

---
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" version="1.0">

    <persistence-unit name="entityMgrEx">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        <properties>
            <!-- defined in src/test/resources/hibernate.properties -->
        </properties>
    </persistence-unit>
</persistence>
---

    * Create a hibernate.properties file in src/test/resources to hold 
    information we want to suport testing, but may not want to be 
    part of the deployed artifact. Leave the volatile values as variables
    so they can be expanded into the target tree during compile time.

        * the variables will be filled in during the build process using
        "filtering" and the resources plugin.

        * the show and format_sql options are only turned on during
        early development and debug.

        * the jdbc.batch_size property set to 0 is also used during
        debug. Setting it to this value will eliminate any batching
        of SQL commands, allowing errors about the commands to be 
        better reported to the developer. 

---
hibernate.dialect=${hibernate.dialect}
hibernate.connection.url=${jdbc.url}
hibernate.connection.driver_class=${jdbc.driver}
hibernate.connection.password=${jdbc.password}
hibernate.connection.username=${jdbc.user}
#hibernate.hbm2ddl.auto=create
hibernate.show_sql=true
hibernate.format_sql=true
#hibernate.jdbc.batch_size=0
---


    

** {Part E}: Setup JPA Test Project

    Create the unit test and supporting file(s) to be able to work with
    the perstence unit and database schema in the database.

---
`-- src
    `-- test
        |-- java
        |   `-- myorg
        |       `-- entitymgrex
        |           `-- EntityMgrTest.java
        `-- resources
            `-- log4j.xml
---

    * Create a JUnit Test case to hold your test code. The following
    is an example of a 4.x JUnit test case that uses @Annotations.
    You may also use a JUnit 3.x approach that uses he older 
    inheritance approach.

---
package myorg.entitymgrex;

import javax.persistence.EntityManager;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;


public class EntityMgrTest {
    private static Log log = LogFactory.getLog(EntityMgrTest.class);

    @Test
    public void testTemplate() {
        log.info("testTemplate");
    }
}
---

    * Provide a setUpClass() method that runs once before all tests that
    can create the entity manager. This method must be static.
    
---
    private static final String PERSISTENCE_UNIT = "entityMgrEx";
    private static EntityManagerFactory emf;

    @BeforeClass
    public static void setUpClass() {
        log.debug("creating entity manager factory");
        emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT);
    }
---    

    * Provide a setUp() method that will be called before each testMethod
    is executed. Have this method create an entity manager
    for the tests to use.

---
    private EntityManager em;    

    @Before
    public void setUp() throws Exception {
        log.debug("creating entity manager");
        em = emf.createEntityManager();
        //cleanup();
    }
---

    * Provide a tearDown() method that will be called after each
    testMethod.  Have this flush all remaining items in the persistence
    context to the database and close the entity manager.

---

    @After
    public void tearDown() throws Exception {
        try {
            log.debug("tearDown() started, em=" + em);
            em.getTransaction().begin();
            em.flush();            
            //logAutos();            
            em.getTransaction().commit();            
            em.close();
            log.debug("tearDown() complete, em=" + em);
        }
        catch (Exception ex) {
            log.fatal("tearDown failed", ex);
            throw ex;
        }
     }
---

    * Provide a tearDownClass() method that will be called after all 
    testMethods have completed. This method must be static and should 
    close the entity manager factory.
    
---
    @AfterClass
    public static void tesrDownClass() {
        log.debug("closing entity manager factory");
        emf.close();
    }
---    

    * Add in a logAutos() method to query and print all autos in the 
    database. Do this after flushing the entity manager in the tearDown()
    method so you can see the changes from the previous test. The following
    example uses the entity manager to create an ad-hoc EJB-QL statement.

---
    @After
    public void tearDown() throws Exception {
...
            em.flush();            
            logAutos();            
            em.getTransaction().commit();            
...
     }

    public void logAutos() {
        Query query = em.createQuery("select a from Auto as a");
        for (Object o: query.getResultList()) {
            log.info("EM_AUTO:" + o);
        }        
    }
---

    * You might also want to add a cleanup() to clear out the Auto
    table between tests. The example below uses the entity manager to
    create a native SQL statement.
    
---
    @Before
    public void setUp() throws Exception {
        ...
        em = emf.createEntityManager();
        cleanup();
    }

    public void cleanup() {
        em.getTransaction().begin();
        Query query = em.createNativeQuery("delete from EM_AUTO");
        int rows = query.executeUpdate();
        em.getTransaction().commit();
        log.info("removed " + rows + " rows");
    }
---

    * Add a log4j.xml file to src/test/resources that has your 
    desired settings. The one below produces less timestamp information
    at the console and more details in the logfile.

    [Note:] Although it might be a bit entertaining to set the priority
    of the root appender to debug to see everything the persistence provider
    has to say, it is quite noisy. Consider changing to root priority to
    fatal so that a majority of the log statements are yours.

    []

---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration
    xmlns:log4j="http://jakarta.apache.org/log4j/"
    debug="false">

    <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
        <param name="Target" value="System.out"/>

        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="(%F:%M:%L)  -%m%n"/>
        </layout>
    </appender>

    <appender name="logfile" class="org.apache.log4j.RollingFileAppender">
        <param name="File" value="target/log4j-out.txt"/>
        <param name="Append" value="false"/>
        <param name="MaxFileSize" value="100KB"/>
        <param name="MaxBackupIndex" value="1"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="%-5p %d{dd-MM HH:mm:ss,SSS} [%c] (%F:%M:%L)  -%m%n"/>
        </layout>
   </appender>

   <logger name="myorg">
      <level value="debug"/>
      <appender-ref ref="logfile"/>
   </logger>

   <root>
      <priority value="fatal"/>
      <appender-ref ref="CONSOLE"/>
   </root>

</log4j:configuration>
---

    * Check that you have the following artifacts in your project src
    tree.

---
src/
|-- main
|   |-- java
|   |   `-- myorg
|   |       `-- entitymgrex
|   |           `-- Auto.java
|   `-- resources
|       |-- META-INF
|       |   `-- persistence.xml
|       `-- ddl
|           |-- emauto_create.ddl
|           |-- emauto_delete.ddl
|           `-- emauto_drop.ddl
`-- test
    |-- java
    |   `-- myorg
    |       `-- entitymgrex
    |           `-- EntityMgrTest.java
    `-- resources
        |-- hibernate.properties
        `-- log4j.xml
---

** {Part F}: Ready Project for Import Into Eclipse

    Eclipse Indigo users will get a warning/error for the 
    sql-maven-plugin. The error is related 
    to Eclipse trying to have a tighter integration with Maven by trying to 
    perform comparable tasks inside of Eclipse for what would happen in 
    a normal Maven command line build. For some of the plugins -- Maven does
    not know yet what to do with them and will be asking you for assistance 
    on how to treat the plugin. In most cases you will just tell Eclipse to
    ignore the plugin.  These can be ignored but but adding the following profile 
    will eliminate the error shown by Eclipse for the project pom.xml.

---
    <profiles>
       ...
        <!--  tell Eclipse what to do with some of the plugins -->
        <profile>
          <id>m2e</id>
          <activation>
            <property>
              <name>m2e.version</name>
            </property>
          </activation>
          <build>
            <pluginManagement>
                <plugins>
                    <plugin>
                      <groupId>org.eclipse.m2e</groupId>
                      <artifactId>lifecycle-mapping</artifactId>
                      <version>1.0.0</version>
                      <configuration>
                        <lifecycleMappingMetadata>
                          <pluginExecutions>
                            
                            <!-- more plugin exclusions will go here -->

                            <pluginExecution>
                              <pluginExecutionFilter>
                                <groupId>org.codehaus.mojo</groupId>
                                <artifactId>sql-maven-plugin</artifactId>
                                <versionRange>[1.4,)</versionRange>
                                <goals>
                                  <goal>execute</goal>
                                </goals>
                              </pluginExecutionFilter>
                              <action>
                                <ignore/>
                              </action>
                            </pluginExecution>
    
                          </pluginExecutions>
                        </lifecycleMappingMetadata>
                      </configuration>
                    </plugin>

                </plugins>
            </pluginManagement>
           </build>
        </profile>
    ...
    </profiles>        
---



** {Part G}: Test Entity Manager Functions

    [Note:] The following changes are all made to the EntityMgrTest.java
    JUnit test class. Everything is being done within this file to 
    keep things simple. This test case is playing the role of the 
    business and persistence logic.

    []

    * add a testCreate() method to test the 
    functionality of EntityManager.create(). This will add an object to
    the database once associated with a transaction.

---
    @Test
    public void testCreate() {
        log.info("testCreate");
        
        Auto car = new Auto();
        car.setMake("Chrysler");
        car.setModel("Gold Duster");
        car.setColor("Gold");
        car.setMileage(60*1000);
        
        log.info("creating auto:" + car);                        
        em.persist(car);        
    }
---
---
 -testCreate
 -creating auto:myorg.entitymgrex.Auto@140984b, id=0, make=Chrysler, model=Gold Duster, color=Gold, mileage=60000
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@3ac93e
 -EM_AUTO:myorg.entitymgrex.Auto@140984b, id=1, make=Chrysler, model=Gold Duster, color=Gold, mileage=60000
 -removed 1 rows
---

    * add a testMultiCreate() to test creating several objects. This should 
    also help verify that unique primary keys are being generated.

---
    @Test
    public void testMultiCreate() {
        log.info("testMultiCreate");
        for(int i=0; i<5; i++) {
            Auto car = new Auto();
            car.setMake("Plymouth " + i);
            car.setModel("Grand Prix");
            car.setColor("Green");
            car.setMileage(80*1000);            
            log.info("creating auto:" + car);                        
            em.persist(car);        
        }
    }
---
---
 -testMultiCreate
 -creating auto:myorg.entitymgrex.Auto@c3e9e9, id=0, make=Plymouth 0, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@31f2a7, id=0, make=Plymouth 1, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@131c89c, id=0, make=Plymouth 2, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@1697b67, id=0, make=Plymouth 3, model=Grand Prix, color=Green, mileage=80000
 -creating auto:myorg.entitymgrex.Auto@24c4a3, id=0, make=Plymouth 4, model=Grand Prix, color=Green, mileage=80000
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@1e9c82e
 -EM_AUTO:myorg.entitymgrex.Auto@c3e9e9, id=2, make=Plymouth 0, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@31f2a7, id=3, make=Plymouth 1, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@131c89c, id=4, make=Plymouth 2, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@1697b67, id=5, make=Plymouth 3, model=Grand Prix, color=Green, mileage=80000
 -EM_AUTO:myorg.entitymgrex.Auto@24c4a3, id=6, make=Plymouth 4, model=Grand Prix, color=Green, mileage=80000
---

    * add a testFind() to test the ability to find an object by its 
    primary key value.

---
    @Test
    public void testFind() {
        log.info("testFind");
        
        Auto car = new Auto();
        car.setMake("Ford");
        car.setModel("Bronco II");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car2 = em.find(Auto.class, car.getId());
        assertNotNull("car not found:" + car.getId(), car2);
        log.info("found car:" + car2);
    }
---
---
 -testFind
 -creating auto:myorg.entitymgrex.Auto@aae86e, id=0, make=Ford, model=Bronco II, color=Red, mileage=0
 -found car:myorg.entitymgrex.Auto@aae86e, id=7, make=Ford, model=Bronco II, color=Red, mileage=0
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@97d026
 -EM_AUTO:myorg.entitymgrex.Auto@aae86e, id=7, make=Ford, model=Bronco II, color=Red, mileage=0
---

    * add a getReference() to test the ability to get a reference to an
    object. With such a shallow object, this will act much like find().

---
    @Test
    public void testGetReference() {
        log.info("testGetReference");
        
        Auto car = new Auto();
        car.setMake("Ford");
        car.setModel("Escort");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car2 = em.getReference(Auto.class, car.getId());
        assertNotNull("car not found:" + car.getId(), car2);
        log.info("found car:" + car2);        
    }
---
---
 -testGetReference
 -creating auto:myorg.entitymgrex.Auto@608760, id=0, make=Ford, model=Escort, color=Red, mileage=0
 -found car:myorg.entitymgrex.Auto@608760, id=8, make=Ford, model=Escort, color=Red, mileage=0
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@157ea4a
 -EM_AUTO:myorg.entitymgrex.Auto@608760, id=8, make=Ford, model=Escort, color=Red, mileage=0
---

    * add a testUpdate() method to test the ability to have the setter()
    of a managed ubject update the database.

---
    @Test
    public void testUpdate() {
        log.info("testUpdate");
        
        Auto car = new Auto();
        car.setMake("Pontiac");
        car.setModel("Gran Am");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        for(int mileage=car.getMileage(); mileage<(100*1000); mileage+=20000) {
            //here's where the update is done
            car.setMileage(mileage);
            
            //commit the update to the database for query 
            em.getTransaction().begin();
            em.getTransaction().commit();
            
            //inspect database for value
            int value = getMileage(car.getId());
            assertTrue("unexpected mileage:" + value, value == mileage);
            log.info("found mileage:" + value);        
        }
        
    }

    private int getMileage(long id) {
        Query query = 
            em.createQuery("select a.mileage from Auto as a where a.id=:pk");
        query.setParameter("pk", id);
        return (Integer)query.getSingleResult();        
    }
---
---
 -testUpdate
 -creating auto:myorg.entitymgrex.Auto@6a3960, id=0, make=Pontiac, model=Gran Am, color=Red, mileage=0
 -found mileage:0
 -found mileage:20000
 -found mileage:40000
 -found mileage:60000
 -found mileage:80000
 -EM_AUTO:myorg.entitymgrex.Auto@6a3960, id=9, make=Pontiac, model=Gran Am, color=Red, mileage=80000
---

    * add a testMerge() method to test the ability to perform updates based
    on the current values of a detached object. Note that we are using
    Java serialization to simulate sending a copy of the object to/from a
    remote process and then performing the merge based on the updated
    object.

---
    @Test
    public void testMerge() throws Exception {
        log.info("testMerge");
        
        Auto car = new Auto();
        car.setMake("Chrystler");
        car.setModel("Concord");
        car.setColor("Red");
        car.setMileage(0*1000);
        log.info("creating auto:" + car);                        
        car = em.merge(car); //using merge to persist new
        
        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        for(int mileage=(10*1000); mileage<(100*1000); mileage+=20000) {
            //simulate sending to remote system for update
            Auto car2 = updateMileage(car, mileage);
            
            //verify the object is not being managed by the EM
            assertFalse("object was managed", em.contains(car2));
            assertTrue("object wasn't managed", em.contains(car));
            assertTrue("mileage was same", 
                    car.getMileage() != car2.getMileage());
            
            //commit the update to the database for query 
            em.merge(car2);
            assertTrue("car1 not merged:" + car.getMileage(), 
                    car.getMileage() == mileage);
            em.getTransaction().begin();
            em.getTransaction().commit();
            
            //inspect database for value
            int value = getMileage(car.getId());
            assertTrue("unexpected mileage:" + value, value == mileage);
            log.info("found mileage:" + value);        
        }        
    }
    
    private Auto updateMileage(Auto car, int mileage) throws Exception {
        //simulate sending the object to a remote system
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(car);
        oos.close();
        
        //simulate receiving an update to the object from remote system
        ByteArrayInputStream bis = 
            new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        Auto car2 = (Auto)ois.readObject();
        ois.close();
        
        //here's what they would have changed in remote process 
        car2.setMileage(mileage);
        
        return car2;
    }
---
---
 -testMerge
 -creating auto:myorg.entitymgrex.Auto@147358f, id=0, make=Chrystler, model=Concord, color=Red, mileage=0
 -found mileage:10000
 -found mileage:30000
 -found mileage:50000
 -found mileage:70000
 -found mileage:90000
 -tearDown() started, em=org.hibernate.ejb.EntityManagerImpl@1b4c1d7
 -EM_AUTO:myorg.entitymgrex.Auto@147358f, id=10, make=Chrystler, model=Concord, color=Red, mileage=90000
---

    * add a testRemove() method to verify that we can delete objects from 
    the database.

---
    @Test
    public void testRemove() {
        log.info("testRemove");
        
        Auto car = new Auto();
        car.setMake("Jeep");
        car.setModel("Cherokee");
        car.setColor("Green");
        car.setMileage(30*1000);
        log.info("creating auto:" + car);                        
        em.persist(car);

        //we need to associate the em with a transaction to get a 
        //primary key generated and assigned to the auto
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car2 = em.find(Auto.class, car.getId());
        assertNotNull("car not found:" + car.getId(), car2);
        log.info("found car:" + car2);
        
        //now remove the car
        log.info("removing car:" + car);
        em.remove(car);
        //we need to associate the em with a transaction to  
        //physically remove from database
        em.getTransaction().begin();
        em.getTransaction().commit();
        
        Auto car3 = em.find(Auto.class, car.getId());
        assertNull("car found", car3);
    }    
---
---
 -testRemove
 -creating auto:myorg.entitymgrex.Auto@28305d, id=0, make=Jeep, model=Cherokee, color=Green, mileage=30000
 -found car:myorg.entitymgrex.Auto@28305d, id=11, make=Jeep, model=Cherokee, color=Green, mileage=30000
 -removing car:myorg.entitymgrex.Auto@28305d, id=11, make=Jeep, model=Cherokee, color=Green, mileage=30000
---

** {Part H}: Automatically Generate Schema

    In part C, you manually created a set of DDL files to create schema, 
    delete rows from the schema in the database, and drop the schema
    from the database. Since your persistence provider knows how to
    work with schema, you can optionally get it to create schema for 
    you rather than generating it manually. Even if you are working with
    legacy schema (and won't be changing the database), it is extremely
    helpful to see the persistence providers version of the schema to
    be able to more quickly determine a mis-match in the mapping rather
    than waiting until runtime testing. In order to add schema generation
    to your projects you can add one of the following; runtime schema 
    generation or compile-time schema generation. Runtime schema generation
    is fine for examples and small prototypes, but compile-time 
    generation is suitable for more realistic development scenarios.

    * runtime schema generation can be added to your project by adding the
    following property to your persistence-unit or hibernate.properties.
    Coldstart your database, comment out your SQL plugin, and re-run
    your tests if you want to verify the above will create the database
    at runtime.

---
#persistence.xml
   <property name="hibernate.hbm2ddl.auto" value="create"/> 

#hibernate.properties
    hibernate.hbm2ddl.auto=create
---

    * compile-time schema generation can be added to your project with
    the following plugin entry. Add the following to your pom.xml plugin
    area, re-run your compilation, and look at the files generated
    into target/classes/ddl

---
        <!-- generates a DDL file for persistence unit 
        -->
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>hibernate3-maven-plugin</artifactId>
            <version>${hibernate3-maven-plugin.version}</version>
            <configuration>
                <hibernatetool destdir="target/classes/ddl">
                    <classpath>
                        <path location="${project.build.directory}/test-classes"/>
                    </classpath>
                    <jpaconfiguration persistenceunit="entityMgrEx"
                         propertyfile="${basedir}/target/test-classes/hibernate.properties"/>
                </hibernatetool>
            </configuration>

            <extensions>true</extensions>
            <dependencies>
                <dependency>
                    <groupId>org.hibernate</groupId>
                    <artifactId>hibernate-entitymanager</artifactId>
                    <version>${hibernate3.version}</version>
                </dependency>
            </dependencies>
            <executions>
                <execution>
                    <id>generate-drop-ddl</id>
                    <phase>process-test-resources</phase>
                    <goals>
                        <goal>run</goal>
                    </goals>
                    <configuration>
                        <hibernatetool>
                            <hbm2ddl export="false" create="false" drop="true" format="true" 
                                outputfilename="${project.artifactId}-dropJPA.ddl"/>
                        </hibernatetool>
                    </configuration>
                </execution>
                <execution>
                    <id>generate-create-ddl</id>
                    <phase>process-test-resources</phase>
                    <goals>
                        <goal>run</goal>
                    </goals>
                    <configuration>
                        <hibernatetool>
                            <hbm2ddl export="false" create="true" drop="false" format="true" 
                                outputfilename="${project.artifactId}-createJPA.ddl"/>
                        </hibernatetool>
                    </configuration>
                </execution>
            </executions>
        </plugin>
---

    * Add a lifecycle mapping for the hibernate3-maven-plugin to tell Eclipse
    to ignore the functionality of the plugin and eliminate any errors Eclipse
    might display. This goes with the definition you created for the sql-maven-plugin. 
    
---
                            <pluginExecution>
                              <pluginExecutionFilter>
                                <groupId>org.codehaus.mojo</groupId>
                                <artifactId>hibernate3-maven-plugin</artifactId>
                                <versionRange>[2.2,)</versionRange>
                                <goals>
                                  <goal>hbm2ddl</goal>
                                </goals>
                              </pluginExecutionFilter>
                              <action>
                                <ignore/>
                              </action>
                            </pluginExecution>
---    

    * Run a maven build and observe the generated schema created in the 
    target/classes tree.
    
---
target/classes/
...
|-- ddl
|   |-- emauto_create.ddl
|   |-- emauto_delete.ddl
|   |-- emauto_drop.ddl
|   |-- entityMgrEx-createGEN.ddl
|   `-- entityMgrEx-dropGEN.ddl
...
---
