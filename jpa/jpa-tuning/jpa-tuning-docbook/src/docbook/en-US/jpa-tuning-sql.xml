<!DOCTYPE partintro PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"  [ ]>

<chapter id="jpa-tuning-sql">
    <title>SQL Tuning</title>
        
    <section id="jpa-tuning-sql-guidelines">
       <title>General Guidelines</title>
        <itemizedlist spacing="compact">
            <listitem><para>Keep the number of indexes down to a minimal amount</para>
                <itemizedlist spacing="compact">
                    <listitem><para>Create indexes on tables when accessing small (15%) percentage of total rows</para></listitem>
                    <listitem><para>Create indexes on foreign keys when using in JOIN statements in queries</para></listitem>
                    <listitem><para>Small tables do not need indexes</para></listitem>
                    <listitem><para>Queries without where clauses do not need indexes</para></listitem>
                    <listitem><para>Queries for null values do not use indexes</para></listitem>
                </itemizedlist>
            </listitem>
            <listitem><para>Order columns of index to best match order within where clauses</para></listitem>
            <listitem><para>Consider NOLOGGING indexes that so not write to redo logs (thus cannot be restored)</para></listitem>
            <listitem><para>Look for improper SQL</para>
                <itemizedlist spacing="compact">
                    <listitem><para>Start with table with the most restrictive filter. Look to pass fewest rows to next step.</para></listitem>
                    <listitem><para>Look for tables accessed efficiently</para>
                        <itemizedlist spacing="compact">
                            <listitem><para>Beware of full table scans when a "where" clause is present</para></listitem>
                        </itemizedlist>
                    </listitem>
                    <listitem><para>Look for data type mis-matches</para></listitem>
                    <listitem><para>Eliminate cartesian JOINs</para></listitem>
                    <listitem><para></para></listitem>
                </itemizedlist>
            </listitem>
            <listitem><para>Look for inefficient indexes</para>
                <itemizedlist spacing="compact">
                    <listitem><para>Monotonically incrementing values lead to un-balanced B*-trees</para></listitem>
                    <listitem><para>Out-dated statistics can negatively impact optimizer</para></listitem>
                    <listitem><para></para></listitem>
                </itemizedlist>
            </listitem>
        </itemizedlist>
    </section>    
    
    
    <section id="jpa-tuning-sql-table">
        <title>Table Access</title>
         <itemizedlist spacing="compact">
            <listitem><para>Access paths - strategies used to access data within table</para></listitem>
            <listitem><para>Indexes - good for when accessing small amounts of data out of much larger data set</para></listitem>
            <listitem><para>Full table scans - good for small tables and unrestricted row access</para></listitem>
            <listitem><para>Any row can be *functionally* accessed with either method</para></listitem>
            <listitem><para>Use execution plans to help use the appropriate technique</para></listitem>
        </itemizedlist>

        <section id="jpa-tuning-sql-table-fullscan">
            <title>Full Table Scan</title>
            <itemizedlist spacing="compact">
                <listitem><para>Performs multi-blocks reads -- including read of deleted rows</para></listitem>
                <listitem><para>May filter rows</para></listitem>
                <listitem><para>Faster than "INDEX RANGE SCANS" for large amounts of data</para></listitem>
                <listitem><para>Uses</para>
                    <itemizedlist spacing="compact">
                        <listitem><para>No suitable index</para>
                            <itemizedlist spacing="compact">
                                <listitem><para>Function used on indexed column (ex. lower(FIRST_NAME)=:fname)</para></listitem>
                                <listitem><para>Like clauses starting with wildcard (ex. '%term%')</para></listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem><para>Low(/no) selectivity filters</para></listitem>
                        <listitem><para>Small tables</para></listitem>
                        <listitem><para>High degree of parallelism</para></listitem>
                    </itemizedlist>
                </listitem>
                <listitem><para>Hint <code>/*+ full(table_var) */</code></para></listitem>
            </itemizedlist>
            <note>
                <title>Normalize Data or Use Function Indexes</title>
                <para>If you perform functions on indexed data -- such as lower(COLUMN_NAME), either
                    add a function index or normalize data prior to inserting/updating database.</para>
            </note>
            
            <section id="jpa-tuning-sql-table-fullscan-unrestricted">
                <title>Full Table Scan - Unrestricted</title>
                <figure>
                    <title>Unrestricted Where Clause causes Full Table Scan</title>
                    <graphic scale="70" fileref="images/jpa-tuning-full-table-scan-unrestricted.png"/>
                </figure>
                <itemizedlist spacing="compact">
                    <listitem><para>Table accessed using full table scan to locate and obtain row data</para></listitem>
                    <listitem><para>No where clause provided causes non-use of index</para></listitem>
                </itemizedlist>
            </section>    
            
            <section id="jpa-tuning-sql-table-fullscan-function">
                <title>Full Table Scan - Function</title>
                <figure>
                    <title>Function Applied to Index Column causes Full Table Scan</title>
                    <graphic scale="70" fileref="images/jpa-tuning-full-table-scan-function.png"/>
                </figure>
                <itemizedlist spacing="compact">
                    <listitem><para>Table accessed using full table scan to locate and obtain row data</para></listitem>
                    <listitem><para>Function performed on indexed column negates use of index</para></listitem>
                </itemizedlist>
                <figure>
                    <title>Normalized Data allows use of Index</title>
                    <graphic scale="70" fileref="images/jpa-tuning-full-table-scan-normalized.png"/>
                </figure>
                <itemizedlist spacing="compact">
                    <listitem><para>Index accessed using Range Scan because function removed from column</para></listitem>
                    <listitem><para>Table accessed using RowId Scan to obtain row data</para></listitem>
                    <listitem><para>Function performed on indexed column negates use of index</para></listitem>
                </itemizedlist>
            </section>    

            <section id="jpa-tuning-sql-table-fullscan-wildcard">
                <title>Full Table Scan - Like Wildcards</title>
                <figure>
                    <title>Like Clauses Starting with Wildcard causes Full Table Scan</title>
                    <graphic scale="70" fileref="images/jpa-tuning-full-table-scan-left-wildcard.png"/>
                </figure>
                <itemizedlist spacing="compact">
                    <listitem><para>Table accessed using full table scan to locate and obtain row data</para></listitem>
                    <listitem><para>Strings starting with wildcard characters are not valid for use with index</para></listitem>
                </itemizedlist>
                <figure>
                    <title>Like Clauses not Starting with Wildcard allows use of Index</title>
                    <graphic scale="70" fileref="images/jpa-tuning-full-table-scan-right-wildcard.png"/>
                </figure>
                <itemizedlist spacing="compact">
                    <listitem><para>Index accessed using Range Scan because string does not start with wildcard</para></listitem>
                    <listitem><para>Table accessed using RowId Scan to obtain row data</para></listitem>
                    <listitem><para>Strings starting with wildcard characters are not valid for use with index</para></listitem>
                </itemizedlist>
            </section>    

            <section id="jpa-tuning-sql-table-fullscan-hint">
                <title>Full Table Scan - Hint</title>
                <figure>
                    <title>Hint can Force Full Table Scan</title>
                    <graphic scale="70" fileref="images/jpa-tuning-full-table-scan-hint.png"/>
                </figure>
                <itemizedlist spacing="compact">
                    <listitem><para>Hints can be added to SQL Select to influence execution plan</para></listitem>
                </itemizedlist>
            </section>    
        </section>    
 
        <section id="jpa-tuning-sql-table-rowid">
            <title>Row Id Scan</title>
            <itemizedlist spacing="compact">
                <listitem><para>RowId specifies data file, data block, and row location</para></listitem>
                <listitem><para>Fastest technique to locate specific row</para></listitem>
                <listitem><para>Primarily obtained from index scans</para></listitem>
                <listitem><para>Can be eliminated (with minimal benefit) using a composite index</para></listitem>
                <listitem><para>Updated rows can get re-located to another block -- causing extra expense
                    in RowId scan performance due to rowId indirection</para></listitem>
            </itemizedlist>
            
                <section id="jpa-tuning-sql-table-rowid-index">
                    <title>RowId Scan used by Index Scan</title>
                    <figure>
                        <title>RowId Scan used by Index Scan</title>
                        <graphic scale="70" fileref="images/jpa-tuning-rowid-scan-index.png"/>
                    </figure>
                    <itemizedlist spacing="compact">
                        <listitem><para>Index accessed using Range Scan for values in where clause</para></listitem>
                        <listitem><para>RowId obtained from index</para></listitem>
                        <listitem><para>Table accessed using RowId Scan to fetch row data to satisfy select clause</para></listitem>
                    </itemizedlist>
                </section>    

                <section id="jpa-tuning-sql-table-rowid-composite">
                    <title>RowId Scan skipped using Composite Index</title>
                    <figure>
                        <title>RowId Scan skipped using Composite Index</title>
                        <graphic scale="70" fileref="images/jpa-tuning-rowid-scan-composite.png"/>
                    </figure>
                    <itemizedlist spacing="compact">
                        <listitem><para>Index accessed using Range Scan for values in where and select clauses</para></listitem>
                        <listitem><para>No need to access row/table</para></listitem>
                        <listitem><para>Eliminates need for RowId scan</para></listitem>
                    </itemizedlist>
                </section>    

                <section id="jpa-tuning-sql-table-rowid-composite-2ndterm">
                    <title>RowId Scan replaced with Full Index Scan - Non-matching Where</title>
                    <figure>
                        <title>RowId Scan replaced with Full Index Scan - Non-matching Where</title>
                        <graphic scale="70" fileref="images/jpa-tuning-rowid-scan-composite-2nd-term.png"/>
                    </figure>
                    <itemizedlist spacing="compact">
                        <listitem><para>Index accessed using Full Scan for values in where and select clauses</para></listitem>
                        <listitem><para>Range Scan not used since index not fully aligned with where clause</para></listitem>
                    </itemizedlist>
                </section>    
        </section>    
    </section>    

    <section id="jpa-tuning-sql-index">
        <title>Index Access</title>
        <itemizedlist spacing="compact">
            <listitem><para>Logically and physically independent from table data</para></listitem>
            <listitem><para>May provide faster access to data</para></listitem>
            <listitem><para>Incur storage and (update) processing costs</para></listitem>
            <listitem><para>Can be unique or non-unique</para></listitem>
            <listitem><para>Can be simple or composite</para></listitem>
            <listitem><para>Can be normal (ascending), reverse key (descending), or function-based</para></listitem>
        </itemizedlist>
        <note>
            <title>B*-tree Indexes Need to be Balanced</title>
            <para>A B(alanced)*-tree index based on a monotonically incrementing sequence 
                value will become un-balanced and be of limited use. "Reverse Keys" are 
                used to mix up the bits of the value to appear more random and help keep 
                the index tree balanced. This, obviously, can work for equality tests
                but not for relative comparisons.</para>
            <para>An un-balanced or sparse index can be corrected with 
                <code>ALTER INDEX (index-name) (COALESCE | REBUILD)</code>.</para>                
                <itemizedlist spacing="compact">
                    <listitem><para>COALESCE - repairs index in-place, good for small repairs</para></listitem>
                    <listitem><para>REBUILD - totally rebuilds index, good for large repairs</para></listitem>
                </itemizedlist>
        </note>
        
        <section id="jpa-tuning-sql-index-unique">
            <title>Index Unique Scan</title>
            <figure>
                <title>Index Unique Scan</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-unique-scan.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Index accessed using Unique Scan for values in where clause</para></listitem>
                <listitem><para>Index Unique Scan returns, at most, one rowId</para></listitem>
                <listitem><para>Table accessed using RowId Scan to fetch row data to satisfy select clause</para></listitem>
            </itemizedlist>
        </section>    
        
        <section id="jpa-tuning-sql-index-range">
            <title>Index Range Scan</title>
            <figure>
                <title>Index Range Scan</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-range-scan.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Index accessed using Range Scan for values in where clause</para></listitem>
                <listitem><para>Index Range Scan returns zero to many rowIds</para></listitem>
                <listitem><para>Table accessed using RowId Scan to fetch row data to satisfy select clause</para></listitem>
            </itemizedlist>
        </section>    
        
        <section id="jpa-tuning-sql-index-sort">
            <title>Index Full Scan</title>
            <itemizedlist spacing="compact">
                <listitem><para>Can be used when one of the columns in index is non-null</para></listitem>
                <listitem><para>Can replace table access if all columns in query also within index</para></listitem>
            </itemizedlist>
            <note>
                <para>Entire table could be defined as a B*-tree index. Using this feature
                    for some tables can provide efficient access to data while saving overhead of duplicating 
                    columns within a separate index.
                </para>
<programlisting language=""><![CDATA[create table MOVIE(...) organization index;]]></programlisting>
                <para>H2 always tries to store data tables as B*-trees.</para>                        
            </note>
            <figure>
                <title>Non-Null Indexed Columns Speed Sort</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-sort-nonnull.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>"Sort By" column index accessed using Full scan because column not-nullable and is in requested sort order</para></listitem>
                <listitem><para>Table accessed using RowId scan to get row data in the order of the indexed column</para></listitem>
            </itemizedlist>

            <figure>
                <title>Nullable Indexed Columns Unusable by Sort</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-sort-null.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>"Where clause" column index accessed using Range Scan to locate matching values</para></listitem>
                <listitem><para>Table accessed using RowId scan to get row data</para></listitem>
                <listitem><para>Result is sorted</para></listitem>
            </itemizedlist>
        </section>    
        
        <section id="jpa-tuning-sql-index-composite">
            <title>Composite Index</title>
            <itemizedlist spacing="compact">
                <listitem><para>Index multiple columns in single index</para></listitem>
                <listitem><para>Column order should align primarily with where clause and optionally contain columns from select clause</para></listitem>
                <listitem><para>Can be used to bypass table access when all query terms contained in index</para></listitem>
            </itemizedlist>
            <figure>
                <title>Composite Index Bypasses Table Access and Sort</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-full-scan-composite.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Composite index accessed thru Range Scan to locate matches and select term(s)</para></listitem>
                <listitem><para>Table bypassed because select term(s) present in index</para></listitem>
                <listitem><para>Sort bypassed because index order used</para></listitem>
            </itemizedlist>
        </section>    
        
        <section id="jpa-tuning-sql-index-function">
            <title>Function Index</title>
            <itemizedlist spacing="compact">
                <listitem><para>Used when applying function to column data within query</para></listitem>
                <listitem><para>Reduces need to normalize data during insert/update</para></listitem>
            </itemizedlist>

            <figure>
                <title>Non-function Access to Data</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-function-nofunction.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Column index accessed thru Range Scan to locate match</para></listitem>
                <listitem><para>Table accessed thru RowId Scan to get row data</para></listitem>
            </itemizedlist>

            <figure>
                <title>Function Access to Data w/o Function Index</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-function-function.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Table accessed using Full Scan to locate match and get row data</para></listitem>
                <listitem><para>Column index not used because function applied to column</para></listitem>
            </itemizedlist>

            <figure>
                <title>Function Access to Data with Function Index</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-function-function-index.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Function(column) index accessed thru Range Scan to locate match using normalized value</para></listitem>
                <listitem><para>Table accessed thru RowId Scan to get row data</para></listitem>
            </itemizedlist>
        </section>
        

        
        <section id="jpa-tuning-sql-index-null">
            <title>Indexes Contain non-Null Values</title>
            <figure>
                <title>Unable to Index Range Scan with Null Value</title>
                <graphic scale="70" fileref="images/jpa-tuning-index-null-scan.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Table accessed using Full Scan for values in where and select clauses</para></listitem>
                <listitem><para>Index Range Scan not performed because index contains only non-null values</para></listitem>
            </itemizedlist>
        </section>    

        <section id="jpa-tuning-sql-index-left-wildcard">
            <title>Index Not Searched for Starting Wildcards</title>
            <figure>
                <title>Index Not Searched for Starting Wildcards</title>
                <graphic scale="70" fileref="images/jpa-tuning-full-table-scan-left-wildcard.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Table accessed using Full Scan for values in where and select clauses</para></listitem>
                <listitem><para>Index Range Scan not performed because search term starts with wildcard</para></listitem>
            </itemizedlist>
        </section>    
    </section>    
    
    <section id="jpa-tuning-sql-sql">
        <title>SQL Tuning</title>
        
        <section id="jpa-tuning-sql-sql-semijoins">
            <title>Semi-Join</title>
            <itemizedlist spacing="compact">
                <listitem><para>Used to return single parent table row without extra overhead of an INNER JOIN</para></listitem>
            </itemizedlist>
            
            <figure>
                <title>Inner Join (without Index)</title>
                <graphic scale="70" fileref="images/jpa-tuning-semi-join-innerjoin.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Both tables accessed using Full Table Scan</para></listitem>
                <listitem><para>Data from both tables JOINed using Hash Join</para></listitem>
                <listitem><para>Inner Join inefficient</para>
                    <itemizedlist spacing="compact">
                        <listitem><para>If just want parent rows that have children</para></listitem>
                        <listitem><para>For large parent tables (parent rows repeated for each child)</para></listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>
            
            <figure>
                <title>Inner Join (with Index)</title>
                <graphic scale="70" fileref="images/jpa-tuning-semi-join-innerjoin-index.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para></para></listitem>
                <listitem><para></para></listitem>
                <listitem><para></para></listitem>
            </itemizedlist>
            
            <figure>
                <title>Semi Join (without Index)</title>
                <graphic scale="70" fileref="images/jpa-tuning-semi-join.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Parent table accessed using Full Table Scan</para></listitem>
                <listitem><para>Primary Key Index of child table accessed using Fast Full Scan</para></listitem>
                <listitem><para>Child table does not need to be accessed</para></listitem>
                <listitem><para>Single instance of each parent row returned without duplication</para></listitem>
            </itemizedlist>
            
            <figure>
                <title>Semi Join (with Index)</title>
                <graphic scale="70" fileref="images/jpa-tuning-semi-join-index.png"/>
            </figure>
            <itemizedlist spacing="compact">
                <listitem><para>Parent table accessed using Full Table scan to get row data</para></listitem>
                <listitem><para>Foreign key index of child table access using Range Scan to locate *first* match against parent</para></listitem>
                <listitem><para>Most efficient if only want parent rows that have children</para></listitem>
            </itemizedlist>
            
        </section>

        <section id="jpa-tuning-sql-sql-">
            <title></title>
            <itemizedlist spacing="compact">
                <listitem><para></para></listitem>
                <listitem><para></para></listitem>
                <listitem><para></para></listitem>
            </itemizedlist>
        </section>
        
    </section>

    <section id="jpa-tuning-sql-summary">
       <title>Summary</title>
        <itemizedlist spacing="compact">
            <listitem><para></para></listitem>
            <listitem><para></para></listitem>
            <listitem><para></para></listitem>
        </itemizedlist>
    </section>    
</chapter>
  
