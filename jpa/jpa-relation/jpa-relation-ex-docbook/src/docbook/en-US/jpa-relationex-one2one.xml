<!DOCTYPE partintro PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"  [ ]>

<chapter id="jpa-relationex-one2one">
    <title>Mapping One-to-One Relationships</title>
    <para>In this chapter we will work thru several ways to relate two entities
        in a one-to-one relationship. As the name implies each side of the
        relationship has no more than one instance of the other. That sounds
        easy -- and it is if we keep in mind that this is a unique relationship
        (i.e., no other instance has it) from both sides.</para>
        
        
    <section id="jpa-relationex-o2o-setup">
        <title>Setup</title>
        <para>Create a JUnit test class to host tests for the one-to-one mappings.</para>

        <orderedlist>
            <listitem><para>Put the following Junit test case base class in your src/test tree.
                You can delete the sample test method once we add our first real test. JUnit
                will fail a test case if it cannot locate a @Test to run.</para>
<programlisting language="java"><![CDATA[
package myorg.relex;

import static org.junit.Assert.*;

import javax.persistence.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.*;

public class One2OneTest extends JPATestBase {
    private static Log log = LogFactory.getLog(One2OneTest.class);
    @Test
    public void testSample() {
        log.info("testSample");
    }
}
]]></programlisting>                        
                </listitem>
 
                <listitem><para>Verify the new JUnit test class builds and executes to completion</para>
<programlisting language=""><![CDATA[
relationEx]$ mvn clean test -P\!h2db -Ph2srv
...
 -HHH000401: using driver [org.h2.Driver] at URL [jdbc:h2:tcp://localhost:9092/h2db/ejava]
...
[INFO] BUILD SUCCESS                
]]></programlisting>                        
                </listitem>
        
        </orderedlist>
    </section>
        
        
    <section id="jpa-relationex-o2o-uni">
        <title>One-to-One Uni-directional Relationships</title>
        <para>The notion of a uni-directional relationship is solely a characterization
            of what the Java class at either end of the relationship knows about the 
            other. For uni-directional relationships only one class references the 
            other while the other passively participates in the relationship.</para>
  
        <section id="jpa-relationex-o2o-uni-fk">
            <title>One-to-One Uni-directional Using a Foreign Key</title>
            <para>In this first case we are going to model the relationship from the
                owning side of the relationship as a foreign key in the owning entity's
                table.</para>
            <orderedlist>
            
                <listitem><para>Create the following entity class in your src/main tree to
                    represent the passive side of the relationship. I am calling this "passive"
                    (or "ignorant") because it will know nothing of the relationships we will 
                    form within this section. This is different than the "inverse" side we will 
                    address in the bi-directional case.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Target of uni-directional relationship
 */
@Entity
@Table(name="RELATIONEX_PERSON")
public class Person {
    @Id @GeneratedValue
    private int id;
    private String name;
    
    public int getId() { return id; }
    
    public String getName() { return name; }
    public void setName(String name) {
        this.name = name; 
    }
}
]]></programlisting>
                    <para>Notice there is no reference to the owning Player class within
                        this entity. This fact alone makes it uni-directional</para>                        
                </listitem>
                
                <listitem><para>Create the following entity class in your src/main tree to
                    represent the owning side of the relationship. It is currently incomplete.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using foreign key.
 */
@Entity
@Table(name="RELATIONEX_PLAYER")
public class Player {
    public enum Position { DEFENSE, OFFENSE, SPECIAL_TEAMS};
    @Id @GeneratedValue
    private int id;
    @Enumerated(EnumType.STRING)
    @Column(length=16)
    private Position position;
    
    //@OneToOne
    private Person person;
    
    public int getId() { return id; }

    public Person getPerson() { return person; }
    public void setPerson(Person person) {
        this.person = person;
    }

    public Position getPosition() { return position; }
    public void setPosition(Position position) {
        this.position = position;
    }
}
]]></programlisting>                        
                </listitem>
                <listitem><para>Add the two entity classes to the persistence unit housed in 
                    src/test tree</para>
<programlisting language=""><![CDATA[
    <persistence-unit name="relationEx-test">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        ...
        <class>myorg.relex.one2one.Person</class>
        <class>myorg.relex.one2one.Player</class>
        ...
    </persistence-unit>            
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to build the module and note the error that results.
                    The error is stating the provider does not know how to map the non-serializable
                    Person class to a column within the Player table.</para>
<programlisting language=""><![CDATA[
org.hibernate.MappingException: Could not determine type for: myorg.relex.one2one.Person, at table: 
RELATIONEX_PLAYER, for columns: [org.hibernate.mapping.Column(person). 
]]></programlisting>
                    <para>If you look back at the Class mapping topic, we were able to map a 
                        serialized relationship to a BLOB column. That is what we are accidentally 
                        doing here if we leave off the @XxxToXxx relationship specification.</para>                        
                </listitem>
                
                <listitem><para>Add a JPA @OneToOne relationship mapping from the Player to Person.
                    Also include a definitions to...</para>
                    <itemizedlist>
                        <listitem><para>Make the Person required for the Player</para></listitem>
                        <listitem><para>Specify the Person must be also fetched when obtaining the Player</para></listitem>
                        <listitem><para>Specify a foreign key column in the Player table that references the Person table</para></listitem>
                    </itemizedlist>
<programlisting language=""><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Build the module and observe the database schema generated.</para>
<programlisting language=""><![CDATA[
   create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );

    create table RELATIONEX_PLAYER (
        id integer generated by default as identity,
        position varchar(16),
        PERSON_ID integer not null,
        primary key (id),
        unique (PERSON_ID)
    );

    alter table RELATIONEX_PLAYER 
        add constraint FK58E275714BE1E366 
        foreign key (PERSON_ID) 
        references RELATIONEX_PERSON;
]]></programlisting>
                    <itemizedlist>
                        <listitem><para>The Player table contains a foreign key referencing the Person table. Note
                            the foreign key *value* (PERSON_ID) is not modeled within the Player entity class. Only the
                            *relationship* to the Person has been depicted within the Player. If we want the person
                            ID value, we can ask the person object related to the player.</para></listitem>
                        <listitem><para>The foreign key column is required to be supplied ("not null"). This means that all
                            Players must have a Person</para></listitem>
                        <listitem><para>The foreign key column is required to be unique. This means that only one
                            Player may reference one Person using the PERSON_ID.</para></listitem>
                    </itemizedlist>                        
                </listitem>
                
                <listitem><para>Add the following test method to your existing JUnit test case.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniFK() {
        log.info("*** testOne2OneUniFK ***");
        Person person = new Person();
        person.setName("Johnny Unitas");
        Player player = new Player();
        player.setPerson(person);
        player.setPosition(Player.Position.OFFENSE);
        //em.persist(person);
        em.persist(player); //provider will propagate person.id to player.FK
        
        //clear the persistence context and get new instances
        em.flush(); em.clear();
        Player player2 = em.find(Player.class, player.getId());
        assertEquals("unexpected position", player.getPosition(), player2.getPosition());
        assertEquals("unexpected name", player.getPerson().getName(), player2.getPerson().getName());
    }
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to re-build the module and note the error.</para>
<programlisting language=""><![CDATA[
./target/surefire-reports/myorg.relex.One2OneTest.txt
::::::::::::::
-------------------------------------------------------------------------------
Test set: myorg.relex.One2OneTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.874 sec <<< FAILURE!
testOne2OneUniFK(myorg.relex.One2OneTest)  Time elapsed: 0.171 sec  <<< ERROR!
java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - 
save the transient instance before flushing: myorg.relex.one2one.Player.person -> myorg.relex.one2one.Person
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1358)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1289)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1295)
        at org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:976)
        at myorg.relex.One2OneTest.testOne2OneUniFK(One2OneTest.java:29)
]]></programlisting>
                    <para>The provider is stating that our test case is trying to persist the
                        Player when the reference to the Person references an unmanaged Person
                        object. We need add a persist of the Person prior to hitting the call
                        to flush.</para>                        
                </listitem>
                
                <listitem><para>Update the test method to persist both the Person and Player
                    prior to the flush.</para>
<programlisting language="java"><![CDATA[
        em.persist(person);
        em.persist(player);
]]></programlisting>       
                    <note>
                        <para>We will look at cascades a bit later which may or may not be
                            appropriate to solve this dependent/parent table persistence.</para>
                    </note>                 
                </listitem>
                
                <listitem><para>Rebuild and observe the results of the test method. Note the 
                    Person and Player being persisted and the PERSON_ID of the Player being set 
                    to the generated primary key value of the Person. During the find(), the
                    Person and Player are both obtained through a database join. Since the
                    Person is required for the Player and we requested an EAGER fetch type, 
                    an database inner join is performed between the Player and Person tables.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
-*** testOne2OneUniFK ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_PLAYER
        (id, PERSON_ID, position) 
    values
        (null, ?, ?)
Hibernate: 
    select
        player0_.id as id2_1_,
        player0_.PERSON_ID as PERSON3_2_1_,
        player0_.position as position2_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    inner join
        RELATIONEX_PERSON person1_ 
            on player0_.PERSON_ID=person1_.id 
    where
        player0_.id=?
]]></programlisting>

                    <para>If we made the Person optional the database query is converted from 
                        an inner join to an outer join -- allowing Players without a Person
                        to be returned.</para>                        
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.EAGER)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_1_,
        player0_.PERSON_ID as PERSON3_2_1_,
        player0_.position as position2_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    left outer join
        RELATIONEX_PERSON person1_ 
            on player0_.PERSON_ID=person1_.id 
    where
        player0_.id=?
]]></programlisting>

                    <para>Also note if we modified the fetch specification to LAZY, the join
                       is removed entirely and replaced with a single select of the Player 
                       table during the find() and then a follow-up select of the Person table
                       once we got to the player.getPerson().getName() calls.</para>    
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_0_,
        player0_.PERSON_ID as PERSON3_2_0_,
        player0_.position as position2_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    where
        player0_.id=?
Hibernate: <<<=== caused by player.getPerson().getName() 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
]]></programlisting>

                        <para>If we comment out the calls to getPerson.getName(), only a 
                            single select on the Player is performed and the Person is 
                            never retrieved. That is the performance power of LAZY load.</para>
<programlisting language="java"><![CDATA[
        //assertEquals("unexpected name", player.getPerson().getName(), player2.getPerson().getName());
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_0_,
        player0_.PERSON_ID as PERSON3_2_0_,
        player0_.position as position2_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    where
        player0_.id=?
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Add the following code to the test method to perform
                    a query of the two tables using SQL in order to verify the expected 
                    mappings and values</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "player.id player_id, player.person_id player_person_id " +
                "from RELATIONEX_PLAYER player " +
                "join RELATIONEX_PERSON person on person.id = player.person_id " +
                "where player.id = ?1")
                .setParameter(1, player.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected player_id", player.getId(), ((Number)cols[2]).intValue());
        assertEquals("unexpected player_person_id", person.getId(), ((Number)cols[3]).intValue());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Rebuild the module to verify the SQL mappings is 
                   what we expected.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        player.id player_id,
        player.person_id player_person_id 
    from
        RELATIONEX_PLAYER player 
    join
        RELATIONEX_PERSON person 
            on person.id = player.person_id 
    where
        player.id = ?
 -row=[1, Johnny Unitas, 1, 1]
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Add the following delete logic to the test method to remove the 
                    Person object.</para>
<programlisting language="java"><![CDATA[
        //em.remove(player2);
        em.remove(player2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("player not deleted", em.find(Player.class, player.getId()));
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to re-build the module and note the error that occurs.
                    The problem is we have attempted to delete the Person row from the database
                    while a foreign key from the Player was still referencing it.</para>
<programlisting language=""><![CDATA[
.Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?

/target/surefire-reports/myorg.relex.One2OneTest.txt
::::::::::::::
-------------------------------------------------------------------------------
Test set: myorg.relex.One2OneTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.551 sec <<< FAILURE!
testOne2OneUniFK(myorg.relex.One2OneTest)  Time elapsed: 1.103 sec  <<< ERROR!
javax.persistence.PersistenceException: org.hibernate.exception.ConstraintViolationException: Referential integrity constraint violation:
 "FK58E275714BE1E366: PUBLIC.RELATIONEX_PLAYER FOREIGN KEY(PERSON_ID) REFERENCES PUBLIC.RELATIONEX_PERSON(ID) (1)"; SQL statement:
delete from RELATIONEX_PERSON where id=? [23503-168]
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1361)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1289)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1295)
        at org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:976)
        at myorg.relex.One2OneTest.testOne2OneUniFK(One2OneTest.java:37)
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Fix the problem by deleting the Player prior to the Person.</para>
<programlisting language=""><![CDATA[
        em.remove(player2);
        em.remove(player2.getPerson());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Rebuild the module and note the success of the test method and the
                    sensible delete order within the database.</para>
<programlisting language=""><![CDATA[
Hibernate: 
    delete 
    from
        RELATIONEX_PLAYER 
    where
        id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
]]></programlisting>                        
                </listitem>
                
            </orderedlist>
            
            <para>We have finished a pass at the first way to hook up a one-to-one,
                uni-directional relationship by using a foreign key. With that, we 
                also showed the database impact of making the relationship optional 
                and modifying the fetch type. We also purposely created errors 
                common to persisting and deleting obejcts with foreign key references.</para>
            
        </section>



        <section id="jpa-relationex-o2o-uni-jointable">
            <title>One-to-One Uni-directional Using a Join Table</title>
            <para>Next we are going to realize the one-to-one uni-directional relationship
                from the dependent to parent entity using a join table. The implementation
                of the dependent entity is identical except for changing the @JoinColumn
                to a @JoinTable</para>
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
            
        </section>



        <section id="jpa-relationex-o2o-uni-pkj">
            <title>One-to-One Uni-directional Using a Primary Key Join</title>
            <para>Next we will attempt to remove the separate foreign key column
                from the child table and map the child to the parent using a 
                join of their primary key values. This will mean that the 
                primary keys of both entities/tables must be the same value. 
            </para>
            <orderedlist>

                <listitem><para>Add the following entity class to your src/main tree to
                    implement a one-to-one, uni-directional, primary key join. In this
                    entity class, we have replaced the @JoinColumn with a @PrimaryKeyJoinColumn
                    specification. This tells the provider not to create a separate foreign
                    key column in the database and to reuse the primary key column to form 
                    the relation to the Person.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.util.Date;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using a primary key join.
 */
@Entity
@Table(name="RELATIONEX_EMPLOYEE")
public class Employee {
    @Id
    private int id;
    @Temporal(TemporalType.DATE)
    private Date hireDate;
    
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @PrimaryKeyJoinColumn
    private Person person;
    
    public int getId() { return id; }

    public Person getPerson() { return person; }
    public Employee setPerson(Person person) {
        this.person = person; return this;
    }

    public Date getHireDate() { return hireDate; }
    public Employee setHireDate(Date hireDate) {
        this.hireDate = hireDate; return this;
    }
}
]]></programlisting>                        
                </listitem>

                <listitem><para>Add the new entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Employee</class>
]]></programlisting>                        
                </listitem>

                <listitem><para>Build the module and observe the database schema generated.
                    Notice the Employee table does not have a separate foreign key column
                    and its primary key is assigned the duties of the foreign key.</para>
<programlisting language=""><![CDATA[
    create table RELATIONEX_EMPLOYEE (
        id integer not null,
        hireDate date,
        primary key (id)
    );

    create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );

    alter table RELATIONEX_EMPLOYEE 
        add constraint FK813A593E1907563C 
        foreign key (id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>

                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>

                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>

                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>

            </orderedlist>
        </section>

        <section id="jpa-relationex-o2o-uni-mapsid">
            <title>One-to-One Uni-directional Using MapsId</title>
            <para></para>
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
        </section>

        <section id="jpa-relationex-o2o-uni-compositepk">
            <title>One-to-One Uni-directional Using Composite Keys</title>
            <para>This section will cover cases where one wants to map 
                a one-to-one primary key join to a parent entity that
                uses a composite primary key. The dependent entity may
                use either an @IdClass/@PrimaryKeyJoins or an @EmbeddedId/@MapsId 
                to realize this relationship and identity</para>

            <section id="jpa-relationex-o2o-uni-idclass">
                <title>One-to-One Uni-directional </title>
                <para></para>
                <orderedlist>
                    <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
                </orderedlist>
            </section>

            <section id="jpa-relationex-o2o-uni-embeddedid">
                <title>One-to-One Uni-directional </title>
                <para></para>
                <orderedlist>
                    <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
                </orderedlist>
            </section>

        </section>



        <section id="jpa-relationex-o2o-uni-cascade">
            <title>One-to-One Uni-directional Using Cascades</title>
            <para></para>
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
        </section>
    </section>



    <section id="jpa-relationex-o2o-bi">
        <title>Mapping One-to-One Bi-directional Relationships</title>
        <para></para>
  
        <section id="jpa-relationex-o2o-bi-1">
            <title>One-to-One Bi-directional Relationships</title>
            <para></para>
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
        </section>

    </section>


    <section id="jpa-relationex-summary">
       <title>Summary</title>
       <para>In this chapter we
       </para>
    </section>    
</chapter>
