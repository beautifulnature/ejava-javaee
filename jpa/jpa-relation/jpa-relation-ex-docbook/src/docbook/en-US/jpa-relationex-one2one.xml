<!DOCTYPE partintro PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"  [ ]>

<chapter id="jpa-relationex-one2one">
    <title>Mapping One-to-One Relationships</title>
    <para>In this chapter we will work thru several ways to relate two entities
        in a one-to-one relationship. As the name implies each side of the
        relationship has no more than one instance of the other. That sounds
        easy -- and it is if we keep in mind that this is a unique relationship
        (i.e., no other instance has it) from both sides.</para>
        
        
    <section id="jpa-relationex-o2o-setup">
        <title>Setup</title>
        <para>Create a JUnit test class to host tests for the one-to-one mappings.</para>

        <orderedlist>
            <listitem><para>Put the following Junit test case base class in your src/test tree.
                You can delete the sample test method once we add our first real test. JUnit
                will fail a test case if it cannot locate a @Test to run.</para>
<programlisting language="java"><![CDATA[
package myorg.relex;

import static org.junit.Assert.*;

import javax.persistence.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.*;

public class One2OneTest extends JPATestBase {
    private static Log log = LogFactory.getLog(One2OneTest.class);
    @Test
    public void testSample() {
        log.info("testSample");
    }
}
]]></programlisting>                        
                </listitem>
 
                <listitem><para>Verify the new JUnit test class builds and executes to completion</para>
<programlisting language=""><![CDATA[
relationEx]$ mvn clean test -P\!h2db -Ph2srv
...
 -HHH000401: using driver [org.h2.Driver] at URL [jdbc:h2:tcp://localhost:9092/h2db/ejava]
...
[INFO] BUILD SUCCESS                
]]></programlisting>                        
                </listitem>
        
        </orderedlist>
    </section>
        
        
    <section id="jpa-relationex-o2o-uni">
        <title>One-to-One Uni-directional Relationships</title>
        <para>The notion of a uni-directional relationship is solely a characterization
            of what the Java class at either end of the relationship knows about the 
            other. For uni-directional relationships only one class references the 
            other while the other passively participates in the relationship.</para>
  
        <section id="jpa-relationex-o2o-uni-fk">
            <title>One-to-One Uni-directional Using a Foreign Key</title>
            <para>In this first case we are going to model the relationship from the
                owning side of the relationship as a foreign key in the owning entity's
                table.</para>
            <orderedlist>
            
                <listitem><para>Create the following entity class in your src/main tree to
                    represent the passive side of the relationship. I am calling this "passive"
                    (or "ignorant") because it will know nothing of the relationships we will 
                    form within this section. This is different than the "inverse" side we will 
                    address in the bi-directional case.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Target of uni-directional relationship
 */
@Entity
@Table(name="RELATIONEX_PERSON")
public class Person {
    @Id @GeneratedValue
    private int id;
    private String name;
    
    public int getId() { return id; }
    
    public String getName() { return name; }
    public void setName(String name) {
        this.name = name; 
    }
}
]]></programlisting>
                    <para>Notice there is no reference to the owning Player class within
                        this entity. This fact alone makes it uni-directional</para>                        
                </listitem>
                
                <listitem><para>Create the following entity class in your src/main tree to
                    represent the owning side of the relationship. It is currently incomplete.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using foreign key.
 */
@Entity
@Table(name="RELATIONEX_PLAYER")
public class Player {
    public enum Position { DEFENSE, OFFENSE, SPECIAL_TEAMS};
    @Id @GeneratedValue
    private int id;
    @Enumerated(EnumType.STRING)
    @Column(length=16)
    private Position position;
    
    //@OneToOne
    private Person person;
    
    public int getId() { return id; }

    public Person getPerson() { return person; }
    public void setPerson(Person person) {
        this.person = person;
    }

    public Position getPosition() { return position; }
    public void setPosition(Position position) {
        this.position = position;
    }
}
]]></programlisting>                        
                </listitem>
                <listitem><para>Add the two entity classes to the persistence unit housed in 
                    src/test tree</para>
<programlisting language="xml"><![CDATA[
    <persistence-unit name="relationEx-test">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        ...
        <class>myorg.relex.one2one.Person</class>
        <class>myorg.relex.one2one.Player</class>
        ...
    </persistence-unit>            
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to build the module and note the error that results.
                    The error is stating the provider does not know how to map the non-serializable
                    Person class to a column within the Player table.</para>
<programlisting language=""><![CDATA[
org.hibernate.MappingException: Could not determine type for: myorg.relex.one2one.Person, at table: 
RELATIONEX_PLAYER, for columns: [org.hibernate.mapping.Column(person). 
]]></programlisting>
                    <para>If you look back at the Class mapping topic, we were able to map a 
                        serialized relationship to a BLOB column. That is what we are accidentally 
                        doing here if we leave off the @XxxToXxx relationship specification.</para>                        
                </listitem>
                
                <listitem><para>Add a JPA @OneToOne relationship mapping from the Player to Person.
                    Also include a definitions to...</para>
                    <itemizedlist>
                        <listitem><para>Make the Person required for the Player</para></listitem>
                        <listitem><para>Specify the Person must be also fetched when obtaining the Player</para></listitem>
                        <listitem><para>Specify a foreign key column in the Player table that references the Person table</para></listitem>
                    </itemizedlist>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Build the module and observe the database schema generated.</para>
<programlisting language=""><![CDATA[
   create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );

    create table RELATIONEX_PLAYER (
        id integer generated by default as identity,
        position varchar(16),
        PERSON_ID integer not null,
        primary key (id),
        unique (PERSON_ID)
    );

    alter table RELATIONEX_PLAYER 
        add constraint FK58E275714BE1E366 
        foreign key (PERSON_ID) 
        references RELATIONEX_PERSON;
]]></programlisting>
                    <itemizedlist>
                        <listitem><para>The Player table contains a foreign key referencing the Person table. Note
                            the foreign key *value* (PERSON_ID) is not modeled within the Player entity class. Only the
                            *relationship* to the Person has been depicted within the Player. If we want the person
                            ID value, we can ask the person object related to the player.</para></listitem>
                        <listitem><para>The foreign key column is required to be supplied ("not null"). This means that all
                            Players must have a Person</para></listitem>
                        <listitem><para>The foreign key column is required to be unique. This means that only one
                            Player may reference one Person using the PERSON_ID.</para></listitem>
                    </itemizedlist>                        
                </listitem>
                
                <listitem><para>Add the following test method to your existing JUnit test case. It is
                   currently incomplete.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniFK() {
        log.info("*** testOne2OneUniFK ***");
        Person person = new Person();
        person.setName("Johnny Unitas");
        Player player = new Player();
        player.setPerson(person);
        player.setPosition(Player.Position.OFFENSE);
        //em.persist(person);
        em.persist(player); //provider will propagate person.id to player.FK
        
        //clear the persistence context and get new instances
        em.flush(); em.clear();
        Player player2 = em.find(Player.class, player.getId());
        assertEquals("unexpected position", player.getPosition(), player2.getPosition());
        assertEquals("unexpected name", player.getPerson().getName(), player2.getPerson().getName());
    }
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to re-build the module and note the error.</para>
<programlisting language=""><![CDATA[
./target/surefire-reports/myorg.relex.One2OneTest.txt
::::::::::::::
-------------------------------------------------------------------------------
Test set: myorg.relex.One2OneTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.874 sec <<< FAILURE!
testOne2OneUniFK(myorg.relex.One2OneTest)  Time elapsed: 0.171 sec  <<< ERROR!
java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - 
save the transient instance before flushing: myorg.relex.one2one.Player.person -> myorg.relex.one2one.Person
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1358)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1289)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1295)
        at org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:976)
        at myorg.relex.One2OneTest.testOne2OneUniFK(One2OneTest.java:29)
]]></programlisting>
                    <para>The provider is stating that our test case is trying to persist the
                        Player when the reference to the Person references an unmanaged Person
                        object. We need add a persist of the Person prior to hitting the call
                        to flush.</para>                        
                </listitem>
                
                <listitem><para>Update the test method to persist both the Person and Player
                    prior to the flush.</para>
<programlisting language="java"><![CDATA[
        em.persist(person);
        em.persist(player);
]]></programlisting>       
                    <note>
                        <para>We will look at cascades a bit later which may or may not be
                            appropriate to solve this dependent/parent table persistence.</para>
                    </note>                 
                </listitem>
                
                <listitem><para>Rebuild and observe the results of the test method. Note the 
                    Person and Player being persisted and the PERSON_ID of the Player being set 
                    to the generated primary key value of the Person. During the find(), the
                    Person and Player are both obtained through a database join. Since the
                    Person is required for the Player and we requested an EAGER fetch type, 
                    a database inner join is performed between the Player and Person tables.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
-*** testOne2OneUniFK ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_PLAYER
        (id, PERSON_ID, position) 
    values
        (null, ?, ?)
Hibernate: 
    select
        player0_.id as id2_1_,
        player0_.PERSON_ID as PERSON3_2_1_,
        player0_.position as position2_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    inner join
        RELATIONEX_PERSON person1_ 
            on player0_.PERSON_ID=person1_.id 
    where
        player0_.id=?
]]></programlisting>

                    <para>If we made the Person optional the database query is converted from 
                        an inner join to an outer join -- allowing Players without a Person
                        to be returned.</para>                        
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.EAGER)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_1_,
        player0_.PERSON_ID as PERSON3_2_1_,
        player0_.position as position2_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    left outer join
        RELATIONEX_PERSON person1_ 
            on player0_.PERSON_ID=person1_.id 
    where
        player0_.id=?
]]></programlisting>

                    <para>Also note if we modified the fetch specification to LAZY, the join
                       is removed entirely and replaced with a single select of the Player 
                       table during the find() and then a follow-up select of the Person table
                       once we got to the player.getPerson().getName() calls.</para>    
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_0_,
        player0_.PERSON_ID as PERSON3_2_0_,
        player0_.position as position2_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    where
        player0_.id=?
Hibernate: <<<=== caused by player.getPerson().getName() 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
]]></programlisting>

                        <para>If we comment out the calls to getPerson.getName(), only a 
                            single select on the Player is performed and the Person is 
                            never retrieved. That is the performance power of LAZY load.</para>
<programlisting language="java"><![CDATA[
        //assertEquals("unexpected name", player.getPerson().getName(), player2.getPerson().getName());
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_0_,
        player0_.PERSON_ID as PERSON3_2_0_,
        player0_.position as position2_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    where
        player0_.id=?
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Add the following code to the test method to perform
                    a query of the two tables using SQL in order to verify the expected 
                    mappings and values</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "player.id player_id, player.person_id player_person_id " +
                "from RELATIONEX_PLAYER player " +
                "join RELATIONEX_PERSON person on person.id = player.person_id " +
                "where player.id = ?1")
                .setParameter(1, player.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected player_id", player.getId(), ((Number)cols[2]).intValue());
        assertEquals("unexpected player_person_id", person.getId(), ((Number)cols[3]).intValue());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Rebuild the module to verify the SQL mappings is 
                   what we expected.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        player.id player_id,
        player.person_id player_person_id 
    from
        RELATIONEX_PLAYER player 
    join
        RELATIONEX_PERSON person 
            on person.id = player.person_id 
    where
        player.id = ?
 -row=[1, Johnny Unitas, 1, 1]
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Add the following delete logic to the test method to remove the 
                    Person object. It is currently incomplete.</para>
<programlisting language="java"><![CDATA[
        //em.remove(player2);
        em.remove(player2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("player not deleted", em.find(Player.class, player.getId()));
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to re-build the module and note the error that occurs.
                    The problem is we have attempted to delete the Person row from the database
                    while a foreign key from the Player was still referencing it.</para>
<programlisting language=""><![CDATA[
.Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?

/target/surefire-reports/myorg.relex.One2OneTest.txt
::::::::::::::
-------------------------------------------------------------------------------
Test set: myorg.relex.One2OneTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.551 sec <<< FAILURE!
testOne2OneUniFK(myorg.relex.One2OneTest)  Time elapsed: 1.103 sec  <<< ERROR!
javax.persistence.PersistenceException: org.hibernate.exception.ConstraintViolationException: Referential integrity constraint violation:
 "FK58E275714BE1E366: PUBLIC.RELATIONEX_PLAYER FOREIGN KEY(PERSON_ID) REFERENCES PUBLIC.RELATIONEX_PERSON(ID) (1)"; SQL statement:
delete from RELATIONEX_PERSON where id=? [23503-168]
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1361)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1289)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1295)
        at org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:976)
        at myorg.relex.One2OneTest.testOne2OneUniFK(One2OneTest.java:37)
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Fix the problem by deleting the Player prior to the Person.</para>
<programlisting language=""><![CDATA[
        em.remove(player2);
        em.remove(player2.getPerson());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Rebuild the module and note the success of the test method and the
                    sensible delete order within the database.</para>
<programlisting language=""><![CDATA[
Hibernate: 
    delete 
    from
        RELATIONEX_PLAYER 
    where
        id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
]]></programlisting>                        
                </listitem>
                
            </orderedlist>
            
            <para>We have finished a pass at the first way to hook up a one-to-one,
                uni-directional relationship by using a foreign key. With that, we 
                also showed the database impact of making the relationship optional 
                and modifying the fetch type. We also purposely created errors 
                common to persisting and deleting obejcts with foreign key references.</para>
            
        </section>



        <section id="jpa-relationex-o2o-uni-jointable">
            <title>One-to-One Uni-directional Using a Join Table</title>
            <para>Next we are going to realize the one-to-one uni-directional relationship
                from the dependent to parent entity using a join table. The implementation
                of the dependent entity is identical to what we did in the FK-join except 
                for changing the @JoinColumn to a @JoinTable</para>
            <orderedlist>
            
                <listitem><para>Add the following entity class to your src/main tree.
                    The comments make it incomplete and use a default mapping for the 
                    @OneToOne relationship.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using join table.
 */
@Entity
@Table(name="RELATIONEX_MEMBER")
public class Member {
    public enum Role { PRIMARY, SECONDARY};

    @Id @GeneratedValue
    private int id;
    
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    /*@JoinTable(name="RELATIONEX_MEMBER_PERSON",
        joinColumns={
            @JoinColumn(name="MEMBER_ID", referencedColumnName="ID"),
        }, inverseJoinColumns={
            @JoinColumn(name="PERSON_ID", referencedColumnName="ID"),
        }
    )*/
    private Person person;

    @Enumerated(EnumType.STRING)
    @Column(length=16)
    private Role role;
    
    protected Member() {}
    public Member(Person person) {
        this.person = person;
    }
    
    public int getId() { return id; }
    public Person getPerson() { return person; }

    public Role getRole() { return role; }
    public void setRole(Role role) {
        this.role = role;
    }
}
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the entity to the persistence unit</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Member</class>
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Build the module and observe the generated database schema.
                    Notice the default mapping for the relationship is a foreign key join.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_MEMBER (
        id integer generated by default as identity,
        role varchar(16),
        person_id integer not null,
        primary key (id),
        unique (person_id)
    );
...
    alter table RELATIONEX_MEMBER 
        add constraint FK5366652A4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Update the mapping to use a a join table using the @JoinTable
                   annotation. The name of the join table is required in this case, but 
                   leave the rest of the mapping defaulted at this point.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    @JoinTable(name="RELATIONEX_MEMBER_PERSON")/*,
        joinColumns={
            @JoinColumn(name="MEMBER_ID", referencedColumnName="ID"),
        }, inverseJoinColumns={
            @JoinColumn(name="PERSON_ID", referencedColumnName="ID"),
        }
    )*/
    private Person person;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Re-build the module and observe the generated database 
                    schema for our new @JoinTable relationship.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );
...
    create table RELATIONEX_MEMBER (
        id integer generated by default as identity,
        role varchar(16),
        primary key (id)
    );

    create table RELATIONEX_MEMBER_PERSON (
        person_id integer not null,
        id integer not null,
        primary key (id),
        unique (person_id)
    );
...
    alter table RELATIONEX_MEMBER_PERSON 
        add constraint FK3D65E40A13E64581 
        foreign key (id) 
        references RELATIONEX_MEMBER;

    alter table RELATIONEX_MEMBER_PERSON 
        add constraint FK3D65E40A4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>       
                    <para>Note...</para>
                    <itemizedlist>
                        <listitem><para>The provider derived names for the Person.id and Member.id foreign keys in the join table</para></listitem>
                        <listitem><para>The "id" column of the join table is the primary key and has a primary key
                            join relationship with the dependent's table.</para></listitem>
                        <listitem><para>The "person_id" of the join table is also constrained to be unique since
                            this is a one-to-one relationship. We can only have a single entry in this table 
                            referencing the parent entity.</para></listitem>
                    </itemizedlist>
                 
                </listitem>
            
                <listitem><para>Finish the @JoinTable mapping by making the join table column
                    mapping explicit.</para>
<programlisting language="java"><![CDATA[
    @JoinTable(name="RELATIONEX_MEMBER_PERSON",
        joinColumns={
            @JoinColumn(name="MEMBER_ID", referencedColumnName="ID"),
        }, inverseJoinColumns={
            @JoinColumn(name="PERSON_ID", referencedColumnName="ID"),
        }
    )
    private Person person;
]]></programlisting>
                    <itemizedlist>
                        <listitem><para>The JoinTable.name property was used to name the table</para></listitem>
                        <listitem><para>The JoinTable.joinColumns property was used define column(s) pointing to this dependent entity</para></listitem>
                        <listitem><para>The JoinTable.inverseJoinColumns property was used to define column(s) pointing to the parent entity</para></listitem>
                        <listitem><para>Multiple @JoinColumns would have been necessary only when using composite keys</para></listitem>
                    </itemizedlist>                        
                </listitem>
            
                <listitem><para>Re-build the module and note the generated database schema for 
                    the join table. The columns now have the custom names we assigned.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_MEMBER_PERSON (
        PERSON_ID integer not null,
        MEMBER_ID integer not null,
        primary key (MEMBER_ID),
        unique (PERSON_ID)
    );    
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following test method to you existing one-to-one test case.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniJoinTable() {
        log.info("*** testOne2OneUniJoinTable ***");
        Person person = new Person();
        person.setName("Joe Smith");
        Member member = new Member(person);
        member.setRole(Member.Role.SECONDARY);
        em.persist(person);
        em.persist(member); //provider will propagate person.id to player.FK
        
        //clear the persistence context and get new instances
        em.flush(); em.clear();
        Member member2 = em.find(Member.class, member.getId());
        assertEquals("unexpected role", member.getRole(), member2.getRole());
        assertEquals("unexpected name", member.getPerson().getName(), member2.getPerson().getName());
    }        
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Build the module, run the new test method, and observe the 
                    database output. Notice the extra insert for the join table</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniJoinTable
...
 -*** testOne2OneUniJoinTable ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_MEMBER
        (id, role) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_MEMBER_PERSON
        (PERSON_ID, MEMBER_ID) 
    values
        (?, ?)
Hibernate: 
    select
        member0_.id as id3_1_,
        member0_.role as role3_1_,
        member0_1_.PERSON_ID as PERSON1_4_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_MEMBER member0_ 
    left outer join
        RELATIONEX_MEMBER_PERSON member0_1_ 
            on member0_.id=member0_1_.MEMBER_ID 
    inner join
        RELATIONEX_PERSON person1_ 
            on member0_1_.PERSON_ID=person1_.id 
    where
        member0_.id=?

]]></programlisting>

                    <para>If you make the relationship optional then the 
                        inner join to the Person changes to a left outer join
                        -- allowing us to locate Members that have no Person
                        related.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.EAGER)
    @JoinTable(name="RELATIONEX_MEMBER_PERSON",
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        member0_.id as id3_1_,
        member0_.role as role3_1_,
        member0_1_.PERSON_ID as PERSON1_4_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_MEMBER member0_ 
    left outer join
        RELATIONEX_MEMBER_PERSON member0_1_ 
            on member0_.id=member0_1_.MEMBER_ID 
    left outer join
        RELATIONEX_PERSON person1_ 
            on member0_1_.PERSON_ID=person1_.id 
    where
        member0_.id=?
]]></programlisting>                        

                    <para>If you change from EAGER to LAZY fetch type, the 
                        provider then has the option of skipping the two extra 
                        tables until the Person is actually needed. Note, however,
                        in the provided output that the provider joined with at 
                        least the join table so that it could build a lightweight
                        reference to the Person.</para>        
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @JoinTable(name="RELATIONEX_MEMBER_PERSON",
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        member0_.id as id3_0_,
        member0_.role as role3_0_,
        member0_1_.PERSON_ID as PERSON1_4_0_ 
    from
        RELATIONEX_MEMBER member0_ 
    left outer join
        RELATIONEX_MEMBER_PERSON member0_1_ 
            on member0_.id=member0_1_.MEMBER_ID 
    where
        member0_.id=?
]]></programlisting>
                    <para>Using LAZY fetch mode, the provider is able to postpone 
                        getting the parent object until it is actually requested.</para> 
<programlisting language=""><![CDATA[
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following test of the SQL structure to the test method.
                    Here we can assert what we believe the mapping and values should be in the 
                    database when forming the one-to-one relationship using the join table.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "member.id member_id, member.role member_role, " +
                       "link.member_id link_member, link.person_id link_person " +
                "from RELATIONEX_MEMBER member " +
                "join RELATIONEX_MEMBER_PERSON link on link.member_id = member.id " +
                "join RELATIONEX_PERSON person      on link.person_id = person.id " +
                "where member.id = ?1")
                .setParameter(1, member.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected member_id", member.getId(), ((Number)cols[2]).intValue());
        assertEquals("unexpected member_role", member.getRole().name(), (String)cols[3]);
        assertEquals("unexpected link_member_id", member.getId(), ((Number)cols[4]).intValue());
        assertEquals("unexpected link_person_id", person.getId(), ((Number)cols[5]).intValue());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Re-build the module run the test method of interest, and note the
                    success of our assertions on the schema and the produced values.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniJoinTable
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        member.id member_id,
        member.role member_role,
        link.member_id link_member,
        link.person_id link_person 
    from
        RELATIONEX_MEMBER member 
    join
        RELATIONEX_MEMBER_PERSON link 
            on link.member_id = member.id 
    join
        RELATIONEX_PERSON person      
            on link.person_id = person.id 
    where
        member.id = ?
 -row=[1, Joe Smith, 1, SECONDARY, 1, 1]
]]></programlisting>                        
                
                </listitem>
            
                <listitem><para>Add the following cleanup to the test method.</para>
<programlisting language=""><![CDATA[
        em.remove(member2);
        em.remove(member2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("member not deleted", em.find(Member.class, member.getId()));
]]></programlisting>
                </listitem>
            
                <listitem><para>Re-build, not the successful results of our assertions,
                    and the database output. A row is deleted from the Member and join table
                    when the Member is deleted. Person row is deleted when we finally delete
                    the person.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniJoinTable
...
Hibernate: 
    delete 
    from
        RELATIONEX_MEMBER_PERSON 
    where
        MEMBER_ID=?
Hibernate: 
    delete 
    from
        RELATIONEX_MEMBER 
    where
        id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
...        
]]></programlisting>                        
                </listitem>
            </orderedlist>
            
            <para>We have completed our one-to-one, uni-directional relationship
                implemented through a join table. It required an extra table, and
                some more verbose mappings -- but not any structural change to the
                dependent entity class. 
            </para>
            
        </section>



        <section id="jpa-relationex-o2o-uni-pkj">
            <title>One-to-One Uni-directional Using a Primary Key Join</title>
            <para>Next we will attempt to remove the separate foreign key column
                from the dependent table or the separate join table mapping the dependent
                and parent tables. We will instead map the dependent to the parent using a 
                join of their primary key values. This means that the 
                primary keys of both entities/tables must be the same value. The parent's
                primary key can be automatically generated -- but the dependent's primary
                key value must be based on the parent's value. As you will see, that will cause
                a slight complication in ordering the persists of the two entities. 
            </para>
            <orderedlist>

                <listitem><para>Add the following entity class to your src/main tree to
                    implement a one-to-one, uni-directional, primary key join. In this
                    entity class, we have replaced the @JoinColumn with a @PrimaryKeyJoinColumn
                    specification. This tells the provider not to create a separate foreign
                    key column in the database and to reuse the primary key column to form 
                    the relation to the Person.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.util.Date;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using a primary key join.
 */
@Entity
@Table(name="RELATIONEX_EMPLOYEE")
public class Employee {
    @Id //pk value must be assigned, not generated
    private int id;
    
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;

    @Temporal(TemporalType.DATE)
    private Date hireDate;
    
    protected Employee() {}
    public Employee(Person person) {
        this.person = person;
        if (person != null) { id = person.getId(); }
    }

    public int getId() { return person.getId(); }
    public Person getPerson() { return person; }

    public Date getHireDate() { return hireDate; }
    public void setHireDate(Date hireDate) {
        this.hireDate = hireDate;
    }
}
]]></programlisting>
                    <para>Note...</para>
                    <itemizedlist>
                        <listitem><para>The dependent entity has an @Id property compatible with the type in the parent entity @Id</para></listitem>
                        <listitem><para>The dependent entity @Id is not generated -- it must be assigned</para></listitem>
                        <listitem><para>The relationship to the parent entity is defined as being realized through the
                            value in the primary key</para></listitem>
                        <listitem><para>The dependent entity class requires the parent be provided in the constructor and
                            provides no setters for the relation. JPA has no requirement for this but is an appropriate
                            class design since the person is a required relation, the source of the primary key, and 
                            it is illegal to change the value of a primary key in the database.</para></listitem>
                    </itemizedlist>
                        
                </listitem>

                <listitem><para>Add the new entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Employee</class>
]]></programlisting>                        
                </listitem>

                <listitem><para>Build the module and observe the database schema generated.
                    Notice the Employee table does not have a separate foreign key column
                    and its primary key is assigned the duties of the foreign key.</para>
<programlisting language=""><![CDATA[
    create table RELATIONEX_EMPLOYEE (
        id integer not null,
        hireDate date,
        primary key (id)
    );

    create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );

    alter table RELATIONEX_EMPLOYEE 
        add constraint FK813A593E1907563C 
        foreign key (id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>

                <listitem><para>Add the following test method to your existing one-to-one 
                    test case. It is incomplete at this point and will cause an error.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniPKJ() {
        log.info("*** testOne2OneUniPKJ ***");
        Person person = new Person();
        person.setName("Ozzie Newsome");
        //em.persist(person);
        //em.flush(); //generate the PK for the person
        
        Employee employee = new Employee(person);//set PK/FK -- provider will not auto propagate
        employee.setHireDate(new GregorianCalendar(1996, Calendar.JANUARY, 1).getTime());
        em.persist(person);
        em.persist(employee);
        
        //clear the persistence context and get new instances
        em.flush(); em.clear();
        Employee employee2 = em.find(Employee.class, employee.getPerson().getId());
        log.info("calling person...");
        assertEquals("unexpected name", employee.getPerson().getName(), employee2.getPerson().getName());
    }
]]></programlisting>                        
                </listitem>

                <listitem><para>Attempt to build and execute the new test method and observe
                    the results. The problem is the the primary key is not being set and the 
                    required foreign key is being realized by the unset primary key.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniPKJ
...
 -*** testOne2OneUniPKJ ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_EMPLOYEE
        (hireDate, id) 
    values
        (?, ?)
 -SQL Error: 23506, SQLState: 23506
 -Referential integrity constraint violation: "FK813A593E1907563C: PUBLIC.RELATIONEX_EMPLOYEE FOREIGN KEY(ID) 
 REFERENCES PUBLIC.RELATIONEX_PERSON(ID) (0)"; SQL statement:
insert into RELATIONEX_EMPLOYEE (hireDate, id) values (?, ?) [23506-168]
]]></programlisting>                        
                </listitem>

                <listitem><para>Move the persistence of the parent entity so that it is in place
                    prior to being assigned to the dependent entity. That way the dependent entity
                    will be receiving the primary key value in time for it to be persisted.</para>
<programlisting language="java"><![CDATA[
        em.persist(person);
        em.flush(); //generate the PK for the person
        
        Employee employee = new Employee(person);//set PK/FK -- provider will not auto propagate
        employee.setHireDate(new GregorianCalendar(1996, Calendar.JANUARY, 1).getTime());
        //em.persist(person);
        em.persist(employee);
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and re-run the test method. It should now be 
                    able to persist both entities and successfully pull them back.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniPKJ
...
 -*** testOne2OneUniPKJ ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_EMPLOYEE
        (hireDate, id) 
    values
        (?, ?)
...
]]></programlisting>

                    <para>Notice that -- in the primary key join case -- the query to the 
                        database uses two separate selects rather than a single select with 
                        a join as done with the FK-join case. We can tell the fetch mode is 
                        EAGER by the fact that the select for the parent table occurs
                        prior to making a call to the parent.</para>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_0_,
        employee0_.hireDate as hireDate6_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    where
        employee0_.id=?
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
 -calling person...
...
]]></programlisting>
                    <para>If you change the relationship to optional/EAGER, the select changes
                        to a single outer join.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.EAGER)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;
]]></programlisting>                        

<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_1_,
        employee0_.hireDate as hireDate6_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    left outer join
        RELATIONEX_PERSON person1_ 
            on employee0_.id=person1_.id 
    where
        employee0_.id=?
 -calling person...
]]></programlisting>

                    <para>If you change the relationship to required/LAZY you will notice
                        by the location of  "calling person..." -- 
                        the second select occurs at the point where the parent is being
                        dereferenced and called.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_0_,
        employee0_.hireDate as hireDate6_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    where
        employee0_.id=?
 -calling person...
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
]]></programlisting>                        
        
                    <para>One odd thing of note -- if we change the relationship 
                        to optional/LAZY, the provider performs the same
                        type of query as when it was required/EAGER.</para>                
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.LAZY)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_0_,
        employee0_.hireDate as hireDate6_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    where
        employee0_.id=?
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
 -calling person...
]]></programlisting>                        

                </listitem>
                
                <listitem><para>Add the following to your test method to verify the 
                    tables, columns, and values we expect at the raw SQL level.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "employee.id employee_id " +
                "from RELATIONEX_EMPLOYEE employee " +
                "join RELATIONEX_PERSON person on person.id = employee.id " +
                "where employee.id = ?1")
                .setParameter(1, employee.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected employee_id", employee.getId(), ((Number)cols[2]).intValue());
]]></programlisting>                        
                </listitem>

                <listitem><para>Rebuild the module and execute the test method to verify the 
                    assertions about the raw SQL structure and values.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniPKJ
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        employee.id employee_id 
    from
        RELATIONEX_EMPLOYEE employee 
    join
        RELATIONEX_PERSON person 
            on person.id = employee.id 
    where
        employee.id = ?
 -row=[1, Ozzie Newsome, 1]
]]></programlisting>                        
                </listitem>

                <listitem><para>Add the following cleanup logic and to test the ability to delete
                    the entities and their relationships.</para>
<programlisting language="java"><![CDATA[
        em.remove(employee2);
        em.remove(employee2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("employee not deleted", em.find(Employee.class, employee.getId()));
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and verify the ability to delete the dependent 
                    and parent entities.</para>
<programlisting language=""><![CDATA[
Hibernate: 
    delete 
    from
        RELATIONEX_EMPLOYEE 
    where
        id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
]]></programlisting>                        
                </listitem>

            </orderedlist>
            
            <para>You have finished modeling a one-to-one, uni-directional relationship
                using a primary key join. Using this technique saved the dependent of 
                using a separate foreign key column but created the requirement that the
                parent entity be persisted first. We also saw how changing the required and 
                fetch mode could impact the underlying quieries to the database. 
                In the next section we will show how a new feature in JPA 2.0 can ease
                the propagation of the parent primary key to the dependent entity.</para>
            
        </section>

        <section id="jpa-relationex-o2o-uni-mapsid">
            <title>One-to-One Uni-directional Using MapsId</title>
            <para>JPA 2.0 added a new annotation called @MapsId that can ease the propagation
                of the parent primary key to the dependent entity. There are several uses of
                @MapsId. We will first look at its capability to identify the foreign key of
                a dependent entity as being the source of the primary key value. We saw in the 
                FK-join case where the provider automatically propagates FK values to dependent
                entities but not PK-joins. Rather than saying the PK realizes the FK. @MapsId 
                seems to state the FK realizes the PK. Lets take a concrete look... 
                </para>
            <orderedlist>
            
                <listitem><para>Add the following entity class to your src/main tree.
                    It is incomplete at this point in time.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * This class demonstrates a one-to-one, uni-directional relationship
 * where the foreign key is used to define the primary key with the
 * use of @MapsId
 */
@Entity
@Table(name="RELATIONEX_COACH")
public class Coach {
    public enum Type {HEAD, ASSISTANT };
    @Id //provider sets to FK value with help from @MapsId 
    private int id;

    @OneToOne(optional=false, fetch=FetchType.EAGER)
//    @MapsId //informs provider the PK is derived from FK
    private Person person;

    @Enumerated(EnumType.STRING) @Column(length=16)
    private Type type;

    public Coach() {}   
    public Coach(Person person) {
        this.person = person;
    }
    
    public int getId() { return person==null ? 0 : person.getId(); }
    public Person getPerson() { return person; }

    public Type getType() { return type; }
    public void setType(Type type) {
        this.type = type;
    }
}
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Coach</class>
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Rebuild the module and take a look at the generated
                    database schema for what was initially defined above. Notice 
                    how the dependent table has been define to have both a primary 
                    key and a separate foreign key. Lets fix that so there is only
                    a single column to represent the two purposes like what we did
                    for the PK-join case.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_COACH (
        id integer not null,
        type varchar(16),
        person_id integer not null,
        primary key (id),
        unique (person_id)
    );
...
    alter table RELATIONEX_COACH 
        add constraint FK75C513EA4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Update the dependent entity class to inform the provider
                    to derive the primary key value from the assigned foreign key relationship
                    using the @MapsId annotation.</para>
<programlisting language="java"><![CDATA[
    @Id //provider sets to FK value with help from @MapsId 
    private int id;

    @OneToOne(optional=false, fetch=FetchType.EAGER)
    @MapsId //informs provider the PK is derived from FK
    private Person person;
]]></programlisting>
                    <para>If you look back over the entire class design you should
                        notice that the class provides no way to ever assign the @Id
                        except through @MapsId.</para>                        
                </listitem>
            
                <listitem><para>Rebuild the module and review the generated database schema.
                    Notice how the provider is now using the column named after the 
                    foreign key as the primary key and has eliminated the separate 
                    primary key.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
   create table RELATIONEX_COACH (
        type varchar(16),
        person_id integer not null,
        primary key (person_id),
        unique (person_id)
    );
...
    alter table RELATIONEX_COACH 
        add constraint FK75C513EA4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following test method to your existing one-to-one test case.
                   Notice the design of the test method persists the parent and dependent class
                   together -- without having to worry about deriving the parent primary key first.
                   That is very convenient.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniMapsId() {
        log.info("*** testOne2OneUniMapsId ***");
        Person person = new Person();
        person.setName("John Harbaugh");
        Coach coach = new Coach(person);
        coach.setType(Coach.Type.HEAD);
        em.persist(person);
        em.persist(coach); //provider auto propagates person.id to coach.FK mapped to coach.PK 
        
        //flush commands to database, clear cache, and pull back new instance
        em.flush(); em.clear();
        Coach coach2 = em.find(Coach.class, coach.getId());
        log.info("calling person...");
        assertEquals("unexpected name", coach.getPerson().getName(), coach2.getPerson().getName());
    }
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Re-build the module and run the the new test method. Notice 
                   the provider issues two separate selects; one select each for the dependent 
                   and parent entity.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniMapsId
...
 -*** testOne2OneUniMapsId ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_COACH
        (type, person_id) 
    values
        (?, ?)
Hibernate: 
    select
        coach0_.person_id as person2_5_0_,
        coach0_.type as type5_0_ 
    from
        RELATIONEX_COACH coach0_ 
    where
        coach0_.person_id=?
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
 -calling person...
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following assertions about the SQL structure and values.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "coach.person_id coach_id " +
                "from RELATIONEX_COACH coach " +
                "join RELATIONEX_PERSON person on person.id = coach.person_id " +
                "where coach.person_id = ?1")
                .setParameter(1, coach.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected coach_id", coach.getId(), ((Number)cols[2]).intValue());]]></programlisting>                        
                </listitem>
            
                <listitem><para>Rebuild the module, re-run the test method, and observe the
                   results of the new assertions.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniMapsId
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        coach.person_id coach_id 
    from
        RELATIONEX_COACH coach 
    join
        RELATIONEX_PERSON person 
            on person.id = coach.person_id 
    where
        coach.person_id = ?
 -row=[1, John Harbaugh, 1]
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add cleanup logic and assertions of the removal of the 
                   two entity rows.</para>
<programlisting language="java"><![CDATA[
        em.remove(coach2);
        em.remove(coach2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("coach not deleted", em.find(Coach.class, coach.getId()));
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Re-build the module, re-run the test method, and note the
                    successful deletion of the two entity rows.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniMapsId
...
Hibernate: 
    delete 
    from
        RELATIONEX_COACH 
    where
        person_id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
]]></programlisting>                        
                </listitem>
            </orderedlist>
            
            <para>You have completed implementing a one-to-one, uni-directional
                relationship using a @MapsId to derive the primary key of the 
                dependent entity from the foreign key to the parent entity.
                This allowed the persist() of the two entities to occur without
                worrying about a sequencing them in separate actions to the database.</para>
        </section>

        <section id="jpa-relationex-o2o-uni-compositepk">
            <title>One-to-One Uni-directional Using Composite Keys</title>
            <para>This section will cover cases where one wants to map 
                a one-to-one primary key join to a parent entity that
                uses a composite primary key. The dependent entity may
                use either an @IdClass/@PrimaryKeyJoins or an @EmbeddedId/@MapsId 
                to realize this relationship and identity</para>

            <section id="jpa-relationex-o2o-uni-idclass">
                <title>One-to-One Uni-directional </title>
                <para></para>
                <orderedlist>
                    <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
                </orderedlist>
            </section>

            <section id="jpa-relationex-o2o-uni-embeddedid">
                <title>One-to-One Uni-directional </title>
                <para></para>
                <orderedlist>
                    <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
                </orderedlist>
            </section>

        </section>



        <section id="jpa-relationex-o2o-uni-cascade">
            <title>One-to-One Uni-directional Using Cascades</title>
            <para></para>
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
        </section>
    </section>



    <section id="jpa-relationex-o2o-bi">
        <title>Mapping One-to-One Bi-directional Relationships</title>
        <para></para>
  
        <section id="jpa-relationex-o2o-bi-1">
            <title>One-to-One Bi-directional Relationships</title>
            <para></para>
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
        </section>

    </section>


    <section id="jpa-relationex-summary">
       <title>Summary</title>
       <para>In this chapter we
       </para>
    </section>    
</chapter>
