<!DOCTYPE partintro PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"  [ ]>

<chapter id="jpa-relationex-one2one">
    <title>Mapping One-to-One Relationships</title>
    <para>In this chapter we will work thru several ways to relate two entities
        in a one-to-one relationship. As the name implies each side of the
        relationship has no more than one instance of the other. That sounds
        easy -- and it is if we keep in mind that this is a unique relationship
        (i.e., no other instance has it) from both sides.</para>
        
        
    <section id="jpa-relationex-o2o-setup">
        <title>Setup</title>
        <para>Create a JUnit test class to host tests for the one-to-one mappings.</para>

        <orderedlist>
            <listitem><para>Put the following Junit test case base class in your src/test tree.
                You can delete the sample test method once we add our first real test. JUnit
                will fail a test case if it cannot locate a @Test to run.</para>
<programlisting language="java"><![CDATA[
package myorg.relex;

import static org.junit.Assert.*;

import javax.persistence.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.*;

public class One2OneTest extends JPATestBase {
    private static Log log = LogFactory.getLog(One2OneTest.class);
    @Test
    public void testSample() {
        log.info("testSample");
    }
}
]]></programlisting>                        
                </listitem>
 
                <listitem><para>Verify the new JUnit test class builds and executes to completion</para>
<programlisting language=""><![CDATA[
relationEx]$ mvn clean test -P\!h2db -Ph2srv
...
 -HHH000401: using driver [org.h2.Driver] at URL [jdbc:h2:tcp://localhost:9092/h2db/ejava]
...
[INFO] BUILD SUCCESS                
]]></programlisting>                        
                </listitem>
        
        </orderedlist>
    </section>
        
        
    <section id="jpa-relationex-o2o-uni">
        <title>One-to-One Uni-directional Relationships</title>
        <para>The notion of a uni-directional relationship is solely a characterization
            of what the Java class at either end of the relationship knows about the 
            other. For uni-directional relationships only one class references the 
            other while the other passively participates in the relationship.</para>
  
        <section id="jpa-relationex-o2o-uni-fk">
            <title>One-to-One Uni-directional Using a Foreign Key</title>
            <para>In this first case we are going to model the relationship from the
                owning side of the relationship as a foreign key in the owning entity's
                table.</para>
            <orderedlist>
            
                <listitem><para>Create the following entity class in your src/main tree to
                    represent the passive side of the relationship. I am calling this "passive"
                    (or "ignorant") because it will know nothing of the relationships we will 
                    form within this section. This is different than the "inverse" side we will 
                    address in the bi-directional case.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Target of uni-directional relationship
 */
@Entity
@Table(name="RELATIONEX_PERSON")
public class Person {
    @Id @GeneratedValue
    private int id;
    private String name;
    
    public int getId() { return id; }
    
    public String getName() { return name; }
    public void setName(String name) {
        this.name = name; 
    }
}
]]></programlisting>
                    <para>Notice there is no reference to the owning Player class within
                        this entity. This fact alone makes it uni-directional</para>                        
                </listitem>
                
                <listitem><para>Create the following entity class in your src/main tree to
                    represent the owning side of the relationship. It is currently incomplete.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using foreign key.
 */
@Entity
@Table(name="RELATIONEX_PLAYER")
public class Player {
    public enum Position { DEFENSE, OFFENSE, SPECIAL_TEAMS};
    @Id @GeneratedValue
    private int id;
    @Enumerated(EnumType.STRING)
    @Column(length=16)
    private Position position;
    
    //@OneToOne
    private Person person;
    
    public int getId() { return id; }

    public Person getPerson() { return person; }
    public void setPerson(Person person) {
        this.person = person;
    }

    public Position getPosition() { return position; }
    public void setPosition(Position position) {
        this.position = position;
    }
}
]]></programlisting>                        
                </listitem>
                <listitem><para>Add the two entity classes to the persistence unit housed in 
                    src/test tree</para>
<programlisting language="xml"><![CDATA[
    <persistence-unit name="relationEx-test">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        ...
        <class>myorg.relex.one2one.Person</class>
        <class>myorg.relex.one2one.Player</class>
        ...
    </persistence-unit>            
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to build the module and note the error that results.
                    The error is stating the provider does not know how to map the non-serializable
                    Person class to a column within the Player table.</para>
<programlisting language=""><![CDATA[
org.hibernate.MappingException: Could not determine type for: myorg.relex.one2one.Person, at table: 
RELATIONEX_PLAYER, for columns: [org.hibernate.mapping.Column(person). 
]]></programlisting>
                    <para>If you look back at the Class mapping topic, we were able to map a 
                        serialized relationship to a BLOB column. That is what we are accidentally 
                        doing here if we leave off the @XxxToXxx relationship specification.</para>                        
                </listitem>
                
                <listitem><para>Add a JPA @OneToOne relationship mapping from the Player to Person.
                    Also include a definitions to...</para>
                    <itemizedlist>
                        <listitem><para>Make the Person required for the Player</para></listitem>
                        <listitem><para>Specify the Person must be also fetched when obtaining the Player</para></listitem>
                        <listitem><para>Specify a foreign key column in the Player table that references the Person table</para></listitem>
                    </itemizedlist>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Build the module and observe the database schema generated.</para>
<programlisting language=""><![CDATA[
   create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );

    create table RELATIONEX_PLAYER (
        id integer generated by default as identity,
        position varchar(16),
        PERSON_ID integer not null,
        primary key (id),
        unique (PERSON_ID)
    );

    alter table RELATIONEX_PLAYER 
        add constraint FK58E275714BE1E366 
        foreign key (PERSON_ID) 
        references RELATIONEX_PERSON;
]]></programlisting>
                    <itemizedlist>
                        <listitem><para>The Player table contains a foreign key referencing the Person table. Note
                            the foreign key *value* (PERSON_ID) is not modeled within the Player entity class. Only the
                            *relationship* to the Person has been depicted within the Player. If we want the person
                            ID value, we can ask the person object related to the player.</para></listitem>
                        <listitem><para>The foreign key column is required to be supplied ("not null"). This means that all
                            Players must have a Person</para></listitem>
                        <listitem><para>The foreign key column is required to be unique. This means that only one
                            Player may reference one Person using the PERSON_ID.</para></listitem>
                    </itemizedlist>                        
                </listitem>
                
                <listitem><para>Add the following test method to your existing JUnit test case. It is
                   currently incomplete.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniFK() {
        log.info("*** testOne2OneUniFK ***");
        Person person = new Person();
        person.setName("Johnny Unitas");
        Player player = new Player();
        player.setPerson(person);
        player.setPosition(Player.Position.OFFENSE);
        //em.persist(person);
        em.persist(player); //provider will propagate person.id to player.FK
        
        //clear the persistence context and get new instances
        em.flush(); em.clear();
        Player player2 = em.find(Player.class, player.getId());
        assertEquals("unexpected position", player.getPosition(), player2.getPosition());
        assertEquals("unexpected name", player.getPerson().getName(), player2.getPerson().getName());
    }
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to re-build the module and note the error.</para>
<programlisting language=""><![CDATA[
./target/surefire-reports/myorg.relex.One2OneTest.txt
::::::::::::::
-------------------------------------------------------------------------------
Test set: myorg.relex.One2OneTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.874 sec <<< FAILURE!
testOne2OneUniFK(myorg.relex.One2OneTest)  Time elapsed: 0.171 sec  <<< ERROR!
java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - 
save the transient instance before flushing: myorg.relex.one2one.Player.person -> myorg.relex.one2one.Person
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1358)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1289)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1295)
        at org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:976)
        at myorg.relex.One2OneTest.testOne2OneUniFK(One2OneTest.java:29)
]]></programlisting>
                    <para>The provider is stating that our test case is trying to persist the
                        Player when the reference to the Person references an unmanaged Person
                        object. We need add a persist of the Person prior to hitting the call
                        to flush.</para>                        
                </listitem>
                
                <listitem><para>Update the test method to persist both the Person and Player
                    prior to the flush.</para>
<programlisting language="java"><![CDATA[
        em.persist(person);
        em.persist(player);
]]></programlisting>       
                    <note>
                        <para>We will look at cascades a bit later which may or may not be
                            appropriate to solve this dependent/parent table persistence.</para>
                    </note>                 
                </listitem>
                
                <listitem><para>Rebuild and observe the results of the test method. Note the 
                    Person and Player being persisted and the PERSON_ID of the Player being set 
                    to the generated primary key value of the Person. During the find(), the
                    Person and Player are both obtained through a database join. Since the
                    Person is required for the Player and we requested an EAGER fetch type, 
                    a database inner join is performed between the Player and Person tables.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
-*** testOne2OneUniFK ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_PLAYER
        (id, PERSON_ID, position) 
    values
        (null, ?, ?)
Hibernate: 
    select
        player0_.id as id2_1_,
        player0_.PERSON_ID as PERSON3_2_1_,
        player0_.position as position2_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    inner join
        RELATIONEX_PERSON person1_ 
            on player0_.PERSON_ID=person1_.id 
    where
        player0_.id=?
]]></programlisting>

                    <para>If we made the Person optional the database query is converted from 
                        an inner join to an outer join -- allowing Players without a Person
                        to be returned.</para>                        
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.EAGER)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_1_,
        player0_.PERSON_ID as PERSON3_2_1_,
        player0_.position as position2_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    left outer join
        RELATIONEX_PERSON person1_ 
            on player0_.PERSON_ID=person1_.id 
    where
        player0_.id=?
]]></programlisting>

                    <para>Also note if we modified the fetch specification to LAZY, the join
                       is removed entirely and replaced with a single select of the Player 
                       table during the find() and then a follow-up select of the Person table
                       once we got to the player.getPerson().getName() calls.</para>    
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @JoinColumn(name="PERSON_ID")
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_0_,
        player0_.PERSON_ID as PERSON3_2_0_,
        player0_.position as position2_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    where
        player0_.id=?
Hibernate: <<<=== caused by player.getPerson().getName() 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
]]></programlisting>

                        <para>If we comment out the calls to getPerson.getName(), only a 
                            single select on the Player is performed and the Person is 
                            never retrieved. That is the performance power of LAZY load.</para>
<programlisting language="java"><![CDATA[
        //assertEquals("unexpected name", player.getPerson().getName(), player2.getPerson().getName());
]]></programlisting>                        
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        player0_.id as id2_0_,
        player0_.PERSON_ID as PERSON3_2_0_,
        player0_.position as position2_0_ 
    from
        RELATIONEX_PLAYER player0_ 
    where
        player0_.id=?
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Add the following code to the test method to perform
                    a query of the two tables using SQL in order to verify the expected 
                    mappings and values</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "player.id player_id, player.person_id player_person_id " +
                "from RELATIONEX_PLAYER player " +
                "join RELATIONEX_PERSON person on person.id = player.person_id " +
                "where player.id = ?1")
                .setParameter(1, player.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected player_id", player.getId(), ((Number)cols[2]).intValue());
        assertEquals("unexpected player_person_id", person.getId(), ((Number)cols[3]).intValue());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Rebuild the module to verify the SQL mappings is 
                   what we expected.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniFK
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        player.id player_id,
        player.person_id player_person_id 
    from
        RELATIONEX_PLAYER player 
    join
        RELATIONEX_PERSON person 
            on person.id = player.person_id 
    where
        player.id = ?
 -row=[1, Johnny Unitas, 1, 1]
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Add the following delete logic to the test method to remove the 
                    Person object. It is currently incomplete.</para>
<programlisting language="java"><![CDATA[
        //em.remove(player2);
        em.remove(player2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("player not deleted", em.find(Player.class, player.getId()));
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Attempt to re-build the module and note the error that occurs.
                    The problem is we have attempted to delete the Person row from the database
                    while a foreign key from the Player was still referencing it.</para>
<programlisting language=""><![CDATA[
.Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?

/target/surefire-reports/myorg.relex.One2OneTest.txt
::::::::::::::
-------------------------------------------------------------------------------
Test set: myorg.relex.One2OneTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.551 sec <<< FAILURE!
testOne2OneUniFK(myorg.relex.One2OneTest)  Time elapsed: 1.103 sec  <<< ERROR!
javax.persistence.PersistenceException: org.hibernate.exception.ConstraintViolationException: Referential integrity constraint violation:
 "FK58E275714BE1E366: PUBLIC.RELATIONEX_PLAYER FOREIGN KEY(PERSON_ID) REFERENCES PUBLIC.RELATIONEX_PERSON(ID) (1)"; SQL statement:
delete from RELATIONEX_PERSON where id=? [23503-168]
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1361)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1289)
        at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1295)
        at org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:976)
        at myorg.relex.One2OneTest.testOne2OneUniFK(One2OneTest.java:37)
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Fix the problem by deleting the Player prior to the Person.</para>
<programlisting language=""><![CDATA[
        em.remove(player2);
        em.remove(player2.getPerson());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Rebuild the module and note the success of the test method and the
                    sensible delete order within the database.</para>
<programlisting language=""><![CDATA[
Hibernate: 
    delete 
    from
        RELATIONEX_PLAYER 
    where
        id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
]]></programlisting>                        
                </listitem>
                
            </orderedlist>
            
            <para>We have finished a pass at the first way to hook up a one-to-one,
                uni-directional relationship by using a foreign key. With that, we 
                also showed the database impact of making the relationship optional 
                and modifying the fetch type. We also purposely created errors 
                common to persisting and deleting obejcts with foreign key references.</para>
            
        </section>



        <section id="jpa-relationex-o2o-uni-jointable">
            <title>One-to-One Uni-directional Using a Join Table</title>
            <para>Next we are going to realize the one-to-one uni-directional relationship
                from the dependent to parent entity using a join table. The implementation
                of the dependent entity is identical to what we did in the FK-join except 
                for changing the @JoinColumn to a @JoinTable</para>
            <orderedlist>
            
                <listitem><para>Add the following entity class to your src/main tree.
                    The comments make it incomplete and use a default mapping for the 
                    @OneToOne relationship.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using join table.
 */
@Entity
@Table(name="RELATIONEX_MEMBER")
public class Member {
    public enum Role { PRIMARY, SECONDARY};

    @Id @GeneratedValue
    private int id;
    
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    /*@JoinTable(name="RELATIONEX_MEMBER_PERSON",
        joinColumns={
            @JoinColumn(name="MEMBER_ID", referencedColumnName="ID"),
        }, inverseJoinColumns={
            @JoinColumn(name="PERSON_ID", referencedColumnName="ID"),
        }
    )*/
    private Person person;

    @Enumerated(EnumType.STRING)
    @Column(length=16)
    private Role role;
    
    protected Member() {}
    public Member(Person person) {
        this.person = person;
    }
    
    public int getId() { return id; }
    public Person getPerson() { return person; }

    public Role getRole() { return role; }
    public void setRole(Role role) {
        this.role = role;
    }
}
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the entity to the persistence unit</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Member</class>
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Build the module and observe the generated database schema.
                    Notice the default mapping for the relationship is a foreign key join.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_MEMBER (
        id integer generated by default as identity,
        role varchar(16),
        person_id integer not null,
        primary key (id),
        unique (person_id)
    );
...
    alter table RELATIONEX_MEMBER 
        add constraint FK5366652A4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Update the mapping to use a a join table using the @JoinTable
                   annotation. The name of the join table is required in this case, but 
                   leave the rest of the mapping defaulted at this point.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    @JoinTable(name="RELATIONEX_MEMBER_PERSON")/*,
        joinColumns={
            @JoinColumn(name="MEMBER_ID", referencedColumnName="ID"),
        }, inverseJoinColumns={
            @JoinColumn(name="PERSON_ID", referencedColumnName="ID"),
        }
    )*/
    private Person person;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Re-build the module and observe the generated database 
                    schema for our new @JoinTable relationship.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );
...
    create table RELATIONEX_MEMBER (
        id integer generated by default as identity,
        role varchar(16),
        primary key (id)
    );

    create table RELATIONEX_MEMBER_PERSON (
        person_id integer not null,
        id integer not null,
        primary key (id),
        unique (person_id)
    );
...
    alter table RELATIONEX_MEMBER_PERSON 
        add constraint FK3D65E40A13E64581 
        foreign key (id) 
        references RELATIONEX_MEMBER;

    alter table RELATIONEX_MEMBER_PERSON 
        add constraint FK3D65E40A4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>       
                    <para>Note...</para>
                    <itemizedlist>
                        <listitem><para>The provider derived names for the Person.id and Member.id foreign keys in the join table</para></listitem>
                        <listitem><para>The "id" column of the join table is the primary key and has a primary key
                            join relationship with the dependent's table.</para></listitem>
                        <listitem><para>The "person_id" of the join table is also constrained to be unique since
                            this is a one-to-one relationship. We can only have a single entry in this table 
                            referencing the parent entity.</para></listitem>
                    </itemizedlist>
                 
                </listitem>
            
                <listitem><para>Finish the @JoinTable mapping by making the join table column
                    mapping explicit.</para>
<programlisting language="java"><![CDATA[
    @JoinTable(name="RELATIONEX_MEMBER_PERSON",
        joinColumns={
            @JoinColumn(name="MEMBER_ID", referencedColumnName="ID"),
        }, inverseJoinColumns={
            @JoinColumn(name="PERSON_ID", referencedColumnName="ID"),
        }
    )
    private Person person;
]]></programlisting>
                    <itemizedlist>
                        <listitem><para>The JoinTable.name property was used to name the table</para></listitem>
                        <listitem><para>The JoinTable.joinColumns property was used define column(s) pointing to this dependent entity</para></listitem>
                        <listitem><para>The JoinTable.inverseJoinColumns property was used to define column(s) pointing to the parent entity</para></listitem>
                        <listitem><para>Multiple @JoinColumns would have been necessary only when using composite keys</para></listitem>
                    </itemizedlist>                        
                </listitem>
            
                <listitem><para>Re-build the module and note the generated database schema for 
                    the join table. The columns now have the custom names we assigned.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_MEMBER_PERSON (
        PERSON_ID integer not null,
        MEMBER_ID integer not null,
        primary key (MEMBER_ID),
        unique (PERSON_ID)
    );    
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following test method to you existing one-to-one test case.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniJoinTable() {
        log.info("*** testOne2OneUniJoinTable ***");
        Person person = new Person();
        person.setName("Joe Smith");
        Member member = new Member(person);
        member.setRole(Member.Role.SECONDARY);
        em.persist(person);
        em.persist(member); //provider will propagate person.id to player.FK
        
        //clear the persistence context and get new instances
        em.flush(); em.clear();
        Member member2 = em.find(Member.class, member.getId());
        assertEquals("unexpected role", member.getRole(), member2.getRole());
        assertEquals("unexpected name", member.getPerson().getName(), member2.getPerson().getName());
    }        
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Build the module, run the new test method, and observe the 
                    database output. Notice the extra insert for the join table</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniJoinTable
...
 -*** testOne2OneUniJoinTable ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_MEMBER
        (id, role) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_MEMBER_PERSON
        (PERSON_ID, MEMBER_ID) 
    values
        (?, ?)
Hibernate: 
    select
        member0_.id as id3_1_,
        member0_.role as role3_1_,
        member0_1_.PERSON_ID as PERSON1_4_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_MEMBER member0_ 
    left outer join
        RELATIONEX_MEMBER_PERSON member0_1_ 
            on member0_.id=member0_1_.MEMBER_ID 
    inner join
        RELATIONEX_PERSON person1_ 
            on member0_1_.PERSON_ID=person1_.id 
    where
        member0_.id=?

]]></programlisting>

                    <para>If you make the relationship optional then the 
                        inner join to the Person changes to a left outer join
                        -- allowing us to locate Members that have no Person
                        related.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.EAGER)
    @JoinTable(name="RELATIONEX_MEMBER_PERSON",
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        member0_.id as id3_1_,
        member0_.role as role3_1_,
        member0_1_.PERSON_ID as PERSON1_4_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_MEMBER member0_ 
    left outer join
        RELATIONEX_MEMBER_PERSON member0_1_ 
            on member0_.id=member0_1_.MEMBER_ID 
    left outer join
        RELATIONEX_PERSON person1_ 
            on member0_1_.PERSON_ID=person1_.id 
    where
        member0_.id=?
]]></programlisting>                        

                    <para>If you change from EAGER to LAZY fetch type, the 
                        provider then has the option of skipping the two extra 
                        tables until the Person is actually needed. Note, however,
                        in the provided output that the provider joined with at 
                        least the join table so that it could build a lightweight
                        reference to the Person.</para>        
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @JoinTable(name="RELATIONEX_MEMBER_PERSON",
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        member0_.id as id3_0_,
        member0_.role as role3_0_,
        member0_1_.PERSON_ID as PERSON1_4_0_ 
    from
        RELATIONEX_MEMBER member0_ 
    left outer join
        RELATIONEX_MEMBER_PERSON member0_1_ 
            on member0_.id=member0_1_.MEMBER_ID 
    where
        member0_.id=?
]]></programlisting>
                    <para>Using LAZY fetch mode, the provider is able to postpone 
                        getting the parent object until it is actually requested.</para> 
<programlisting language=""><![CDATA[
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following test of the SQL structure to the test method.
                    Here we can assert what we believe the mapping and values should be in the 
                    database when forming the one-to-one relationship using the join table.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "member.id member_id, member.role member_role, " +
                       "link.member_id link_member, link.person_id link_person " +
                "from RELATIONEX_MEMBER member " +
                "join RELATIONEX_MEMBER_PERSON link on link.member_id = member.id " +
                "join RELATIONEX_PERSON person      on link.person_id = person.id " +
                "where member.id = ?1")
                .setParameter(1, member.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected member_id", member.getId(), ((Number)cols[2]).intValue());
        assertEquals("unexpected member_role", member.getRole().name(), (String)cols[3]);
        assertEquals("unexpected link_member_id", member.getId(), ((Number)cols[4]).intValue());
        assertEquals("unexpected link_person_id", person.getId(), ((Number)cols[5]).intValue());
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Re-build the module run the test method of interest, and note the
                    success of our assertions on the schema and the produced values.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniJoinTable
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        member.id member_id,
        member.role member_role,
        link.member_id link_member,
        link.person_id link_person 
    from
        RELATIONEX_MEMBER member 
    join
        RELATIONEX_MEMBER_PERSON link 
            on link.member_id = member.id 
    join
        RELATIONEX_PERSON person      
            on link.person_id = person.id 
    where
        member.id = ?
 -row=[1, Joe Smith, 1, SECONDARY, 1, 1]
]]></programlisting>                        
                
                </listitem>
            
                <listitem><para>Add the following cleanup to the test method.</para>
<programlisting language=""><![CDATA[
        em.remove(member2);
        em.remove(member2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("member not deleted", em.find(Member.class, member.getId()));
]]></programlisting>
                </listitem>
            
                <listitem><para>Re-build, not the successful results of our assertions,
                    and the database output. A row is deleted from the Member and join table
                    when the Member is deleted. Person row is deleted when we finally delete
                    the person.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniJoinTable
...
Hibernate: 
    delete 
    from
        RELATIONEX_MEMBER_PERSON 
    where
        MEMBER_ID=?
Hibernate: 
    delete 
    from
        RELATIONEX_MEMBER 
    where
        id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
...        
]]></programlisting>                        
                </listitem>
            </orderedlist>
            
            <para>We have completed our one-to-one, uni-directional relationship
                implemented through a join table. It required an extra table, and
                some more verbose mappings -- but not any structural change to the
                dependent entity class. 
            </para>
            
        </section>



        <section id="jpa-relationex-o2o-uni-pkj">
            <title>One-to-One Uni-directional Using a Primary Key Join</title>
            <para>Next we will attempt to remove the separate foreign key column
                from the dependent table or the separate join table mapping the dependent
                and parent tables. We will instead map the dependent to the parent using a 
                join of their primary key values. This means that the 
                primary keys of both entities/tables must be the same value. The parent's
                primary key can be automatically generated -- but the dependent's primary
                key value must be based on the parent's value. As you will see, that will cause
                a slight complication in ordering the persists of the two entities. 
            </para>
            <orderedlist>

                <listitem><para>Add the following entity class to your src/main tree to
                    implement a one-to-one, uni-directional, primary key join. In this
                    entity class, we have replaced the @JoinColumn with a @PrimaryKeyJoinColumn
                    specification. This tells the provider not to create a separate foreign
                    key column in the database and to reuse the primary key column to form 
                    the relation to the Person.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.util.Date;

import javax.persistence.*;

/**
 * Provides example of one-to-one unidirectional relationship 
 * using a primary key join.
 */
@Entity
@Table(name="RELATIONEX_EMPLOYEE")
public class Employee {
    @Id //pk value must be assigned, not generated
    private int id;
    
    @OneToOne(optional=false,fetch=FetchType.EAGER)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;

    @Temporal(TemporalType.DATE)
    private Date hireDate;
    
    protected Employee() {}
    public Employee(Person person) {
        this.person = person;
        if (person != null) { id = person.getId(); }
    }

    public int getId() { return person.getId(); }
    public Person getPerson() { return person; }

    public Date getHireDate() { return hireDate; }
    public void setHireDate(Date hireDate) {
        this.hireDate = hireDate;
    }
}
]]></programlisting>
                    <para>Note...</para>
                    <itemizedlist>
                        <listitem><para>The dependent entity has an @Id property compatible with the type in the parent entity @Id</para></listitem>
                        <listitem><para>The dependent entity @Id is not generated -- it must be assigned</para></listitem>
                        <listitem><para>The relationship to the parent entity is defined as being realized through the
                            value in the primary key</para></listitem>
                        <listitem><para>The dependent entity class requires the parent be provided in the constructor and
                            provides no setters for the relation. JPA has no requirement for this but is an appropriate
                            class design since the person is a required relation, the source of the primary key, and 
                            it is illegal to change the value of a primary key in the database.</para></listitem>
                    </itemizedlist>
                        
                </listitem>

                <listitem><para>Add the new entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Employee</class>
]]></programlisting>                        
                </listitem>

                <listitem><para>Build the module and observe the database schema generated.
                    Notice the Employee table does not have a separate foreign key column
                    and its primary key is assigned the duties of the foreign key.</para>
<programlisting language=""><![CDATA[
    create table RELATIONEX_EMPLOYEE (
        id integer not null,
        hireDate date,
        primary key (id)
    );

    create table RELATIONEX_PERSON (
        id integer generated by default as identity,
        name varchar(255),
        primary key (id)
    );

    alter table RELATIONEX_EMPLOYEE 
        add constraint FK813A593E1907563C 
        foreign key (id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>

                <listitem><para>Add the following test method to your existing one-to-one 
                    test case. It is incomplete at this point and will cause an error.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniPKJ() {
        log.info("*** testOne2OneUniPKJ ***");
        Person person = new Person();
        person.setName("Ozzie Newsome");
        //em.persist(person);
        //em.flush(); //generate the PK for the person
        
        Employee employee = new Employee(person);//set PK/FK -- provider will not auto propagate
        employee.setHireDate(new GregorianCalendar(1996, Calendar.JANUARY, 1).getTime());
        em.persist(person);
        em.persist(employee);
        
        //clear the persistence context and get new instances
        em.flush(); em.clear();
        Employee employee2 = em.find(Employee.class, employee.getPerson().getId());
        log.info("calling person...");
        assertEquals("unexpected name", employee.getPerson().getName(), employee2.getPerson().getName());
    }
]]></programlisting>                        
                </listitem>

                <listitem><para>Attempt to build and execute the new test method and observe
                    the results. The problem is the the primary key is not being set and the 
                    required foreign key is being realized by the unset primary key.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniPKJ
...
 -*** testOne2OneUniPKJ ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_EMPLOYEE
        (hireDate, id) 
    values
        (?, ?)
 -SQL Error: 23506, SQLState: 23506
 -Referential integrity constraint violation: "FK813A593E1907563C: PUBLIC.RELATIONEX_EMPLOYEE FOREIGN KEY(ID) 
 REFERENCES PUBLIC.RELATIONEX_PERSON(ID) (0)"; SQL statement:
insert into RELATIONEX_EMPLOYEE (hireDate, id) values (?, ?) [23506-168]
]]></programlisting>                        
                </listitem>

                <listitem><para>Move the persistence of the parent entity so that it is in place
                    prior to being assigned to the dependent entity. That way the dependent entity
                    will be receiving the primary key value in time for it to be persisted.</para>
<programlisting language="java"><![CDATA[
        em.persist(person);
        em.flush(); //generate the PK for the person
        
        Employee employee = new Employee(person);//set PK/FK -- provider will not auto propagate
        employee.setHireDate(new GregorianCalendar(1996, Calendar.JANUARY, 1).getTime());
        //em.persist(person);
        em.persist(employee);
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and re-run the test method. It should now be 
                    able to persist both entities and successfully pull them back.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniPKJ
...
 -*** testOne2OneUniPKJ ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_EMPLOYEE
        (hireDate, id) 
    values
        (?, ?)
...
]]></programlisting>

                    <para>Notice that -- in the primary key join case -- the query to the 
                        database uses two separate selects rather than a single select with 
                        a join as done with the FK-join case. We can tell the fetch mode is 
                        EAGER by the fact that the select for the parent table occurs
                        prior to making a call to the parent.</para>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_0_,
        employee0_.hireDate as hireDate6_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    where
        employee0_.id=?
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
 -calling person...
...
]]></programlisting>
                    <para>If you change the relationship to optional/EAGER, the select changes
                        to a single outer join.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.EAGER)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;
]]></programlisting>                        

<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_1_,
        employee0_.hireDate as hireDate6_1_,
        person1_.id as id1_0_,
        person1_.name as name1_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    left outer join
        RELATIONEX_PERSON person1_ 
            on employee0_.id=person1_.id 
    where
        employee0_.id=?
 -calling person...
]]></programlisting>

                    <para>If you change the relationship to required/LAZY you will notice
                        by the location of  "calling person..." -- 
                        the second select occurs at the point where the parent is being
                        dereferenced and called.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false,fetch=FetchType.LAZY)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_0_,
        employee0_.hireDate as hireDate6_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    where
        employee0_.id=?
 -calling person...
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
]]></programlisting>                        
        
                    <para>One odd thing of note -- if we change the relationship 
                        to optional/LAZY, the provider performs the same
                        type of query as when it was required/EAGER.</para>                
<programlisting language="java"><![CDATA[
    @OneToOne(optional=true,fetch=FetchType.LAZY)
    @PrimaryKeyJoinColumn //informs provider the FK derived from PK
    private Person person;
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        employee0_.id as id6_0_,
        employee0_.hireDate as hireDate6_0_ 
    from
        RELATIONEX_EMPLOYEE employee0_ 
    where
        employee0_.id=?
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
 -calling person...
]]></programlisting>                        

                </listitem>
                
                <listitem><para>Add the following to your test method to verify the 
                    tables, columns, and values we expect at the raw SQL level.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "employee.id employee_id " +
                "from RELATIONEX_EMPLOYEE employee " +
                "join RELATIONEX_PERSON person on person.id = employee.id " +
                "where employee.id = ?1")
                .setParameter(1, employee.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected employee_id", employee.getId(), ((Number)cols[2]).intValue());
]]></programlisting>                        
                </listitem>

                <listitem><para>Rebuild the module and execute the test method to verify the 
                    assertions about the raw SQL structure and values.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniPKJ
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        employee.id employee_id 
    from
        RELATIONEX_EMPLOYEE employee 
    join
        RELATIONEX_PERSON person 
            on person.id = employee.id 
    where
        employee.id = ?
 -row=[1, Ozzie Newsome, 1]
]]></programlisting>                        
                </listitem>

                <listitem><para>Add the following cleanup logic and to test the ability to delete
                    the entities and their relationships.</para>
<programlisting language="java"><![CDATA[
        em.remove(employee2);
        em.remove(employee2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("employee not deleted", em.find(Employee.class, employee.getId()));
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and verify the ability to delete the dependent 
                    and parent entities.</para>
<programlisting language=""><![CDATA[
Hibernate: 
    delete 
    from
        RELATIONEX_EMPLOYEE 
    where
        id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
]]></programlisting>                        
                </listitem>

            </orderedlist>
            
            <para>You have finished modeling a one-to-one, uni-directional relationship
                using a primary key join. Using this technique saved the dependent of 
                using a separate foreign key column but created the requirement that the
                parent entity be persisted first. We also saw how changing the required and 
                fetch mode could impact the underlying quieries to the database. 
                In the next section we will show how a new feature in JPA 2.0 can ease
                the propagation of the parent primary key to the dependent entity.</para>
            
        </section>

        <section id="jpa-relationex-o2o-uni-mapsid">
            <title>One-to-One Uni-directional Using MapsId</title>
            <para>JPA 2.0 added a new annotation called @MapsId that can ease the propagation
                of the parent primary key to the dependent entity. There are several uses of
                @MapsId. We will first look at its capability to identify the foreign key of
                a dependent entity as being the source of the primary key value. We saw in the 
                FK-join case where the provider automatically propagates FK values to dependent
                entities but not PK-joins. Rather than saying the PK realizes the FK. @MapsId 
                seems to state the FK realizes the PK. Lets take a concrete look... 
                </para>
            <orderedlist>
            
                <listitem><para>Add the following entity class to your src/main tree.
                    It is incomplete at this point in time.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * This class demonstrates a one-to-one, uni-directional relationship
 * where the foreign key is used to define the primary key with the
 * use of @MapsId
 */
@Entity
@Table(name="RELATIONEX_COACH")
public class Coach {
    public enum Type {HEAD, ASSISTANT };
    @Id //provider sets to FK value with help from @MapsId 
    private int id;

    @OneToOne(optional=false, fetch=FetchType.EAGER)
//    @MapsId //informs provider the PK is derived from FK
    private Person person;

    @Enumerated(EnumType.STRING) @Column(length=16)
    private Type type;

    public Coach() {}   
    public Coach(Person person) {
        this.person = person;
    }
    
    public int getId() { return person==null ? 0 : person.getId(); }
    public Person getPerson() { return person; }

    public Type getType() { return type; }
    public void setType(Type type) {
        this.type = type;
    }
}
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Coach</class>
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Rebuild the module and take a look at the generated
                    database schema for what was initially defined above. Notice 
                    how the dependent table has been define to have both a primary 
                    key and a separate foreign key. Lets fix that so there is only
                    a single column to represent the two purposes like what we did
                    for the PK-join case.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_COACH (
        id integer not null,
        type varchar(16),
        person_id integer not null,
        primary key (id),
        unique (person_id)
    );
...
    alter table RELATIONEX_COACH 
        add constraint FK75C513EA4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Update the dependent entity class to inform the provider
                    to derive the primary key value from the assigned foreign key relationship
                    using the @MapsId annotation.</para>
<programlisting language="java"><![CDATA[
    @Id //provider sets to FK value with help from @MapsId 
    private int id;

    @OneToOne(optional=false, fetch=FetchType.EAGER)
    @MapsId //informs provider the PK is derived from FK
    private Person person;
]]></programlisting>
                    <para>If you look back over the entire class design you should
                        notice that the class provides no way to ever assign the @Id
                        except through @MapsId.</para>                        
                </listitem>
            
                <listitem><para>Rebuild the module and review the generated database schema.
                    Notice how the provider is now using the column named after the 
                    foreign key as the primary key and has eliminated the separate 
                    primary key.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
   create table RELATIONEX_COACH (
        type varchar(16),
        person_id integer not null,
        primary key (person_id),
        unique (person_id)
    );
...
    alter table RELATIONEX_COACH 
        add constraint FK75C513EA4BE1E366 
        foreign key (person_id) 
        references RELATIONEX_PERSON;
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following test method to your existing one-to-one test case.
                   Notice the design of the test method persists the parent and dependent class
                   together -- without having to worry about deriving the parent primary key first.
                   That is very convenient.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniMapsId() {
        log.info("*** testOne2OneUniMapsId ***");
        Person person = new Person();
        person.setName("John Harbaugh");
        Coach coach = new Coach(person);
        coach.setType(Coach.Type.HEAD);
        em.persist(person);
        em.persist(coach); //provider auto propagates person.id to coach.FK mapped to coach.PK 
        
        //flush commands to database, clear cache, and pull back new instance
        em.flush(); em.clear();
        Coach coach2 = em.find(Coach.class, coach.getId());
        log.info("calling person...");
        assertEquals("unexpected name", coach.getPerson().getName(), coach2.getPerson().getName());
    }
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Re-build the module and run the the new test method. Notice 
                   the provider issues two separate selects; one select each for the dependent 
                   and parent entity.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniMapsId
...
 -*** testOne2OneUniMapsId ***
Hibernate: 
    insert 
    into
        RELATIONEX_PERSON
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_COACH
        (type, person_id) 
    values
        (?, ?)
Hibernate: 
    select
        coach0_.person_id as person2_5_0_,
        coach0_.type as type5_0_ 
    from
        RELATIONEX_COACH coach0_ 
    where
        coach0_.person_id=?
Hibernate: 
    select
        person0_.id as id1_0_,
        person0_.name as name1_0_ 
    from
        RELATIONEX_PERSON person0_ 
    where
        person0_.id=?
 -calling person...
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add the following assertions about the SQL structure and values.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select person.id person_id, person.name, " +
                       "coach.person_id coach_id " +
                "from RELATIONEX_COACH coach " +
                "join RELATIONEX_PERSON person on person.id = coach.person_id " +
                "where coach.person_id = ?1")
                .setParameter(1, coach.getId())
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected person_id", person.getId(), ((Number)cols[0]).intValue());
        assertEquals("unexpected person_name", person.getName(), (String)cols[1]);
        assertEquals("unexpected coach_id", coach.getId(), ((Number)cols[2]).intValue());]]></programlisting>                        
                </listitem>
            
                <listitem><para>Rebuild the module, re-run the test method, and observe the
                   results of the new assertions.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniMapsId
...
Hibernate: 
    select
        person.id person_id,
        person.name,
        coach.person_id coach_id 
    from
        RELATIONEX_COACH coach 
    join
        RELATIONEX_PERSON person 
            on person.id = coach.person_id 
    where
        coach.person_id = ?
 -row=[1, John Harbaugh, 1]
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Add cleanup logic and assertions of the removal of the 
                   two entity rows.</para>
<programlisting language="java"><![CDATA[
        em.remove(coach2);
        em.remove(coach2.getPerson());
        em.flush();
        assertNull("person not deleted", em.find(Person.class, person.getId()));
        assertNull("coach not deleted", em.find(Coach.class, coach.getId()));
]]></programlisting>                        
                </listitem>
            
                <listitem><para>Re-build the module, re-run the test method, and note the
                    successful deletion of the two entity rows.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniMapsId
...
Hibernate: 
    delete 
    from
        RELATIONEX_COACH 
    where
        person_id=?
Hibernate: 
    delete 
    from
        RELATIONEX_PERSON 
    where
        id=?
]]></programlisting>                        
                </listitem>
            </orderedlist>
            
            <para>You have completed implementing a one-to-one, uni-directional
                relationship using a @MapsId to derive the primary key of the 
                dependent entity from the foreign key to the parent entity.
                This allowed the persist() of the two entities to occur without
                worrying about a sequencing them in separate actions to the database.</para>
        </section>

        <section id="jpa-relationex-o2o-uni-compositepk">
            <title>One-to-One Uni-directional Using Composite Primary/Foreign Keys</title>
            <para>This section will cover cases where one wants to map 
                a one-to-one primary key join to a parent entity that
                uses a composite primary key. The dependent entity may
                use either an @IdClass/@PrimaryKeyJoin or an @EmbeddedId/@MapsId 
                to realize this relationship and identity.</para>

                <section id="jpa-relationex-o2o-uni-compositepk-parent">
                    <title>Setup Parent with Composite Primary Key</title>
                                
                    <orderedlist>
                        <listitem><para>To get started, put the following parent class in place
                            in your src/main tree.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.util.Date;

import javax.persistence.*;

/**
 * This class represents the passive side of a one-to-one
 * uni-directional relationship where the parent uses
 * a composite primary key that must be represented in 
 * the dependent entity's relationship.
 */
@Entity
@Table(name="RELATIONEX_SHOWEVENT")
@IdClass(ShowEventPK.class)
public class ShowEvent {
    @Id
    @Temporal(TemporalType.DATE)
    private Date date;
    @Id
    @Temporal(TemporalType.TIME)
    private Date time;
    @Column(length=20)
    private String name;
    
    public ShowEvent() {}
    public ShowEvent(Date date, Date time) {
        this.date = date;
        this.time = time;
    }
    public Date getDate() { return date; }
    public Date getTime() { return time; }

    public String getName() { return name; }
    public void setName(String name) {
        this.name = name;
    }
}
]]></programlisting>                        
                            <para>The above entity class uses two properties to form its primary key --
                                thus it requires a composite primary key to represent the PK within JPA.</para>
                        </listitem>
     
                        <listitem><para>Put the following composite primary key 
                           in place. It is defined as @Embeddable so that it can be used
                           both as an @IdClass and an @EmbeddableId.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.io.Serializable;
import java.util.Date;
import javax.persistence.Embeddable;

/**
 * This class will be used as an IdClass for the ShowEvent
 * entity.
 */
@Embeddable
public class ShowEventPK implements Serializable {
    private static final long serialVersionUID = 1L;
    private Date date;
    private Date time;
    
    protected ShowEventPK(){}
    public ShowEventPK(Date date, Date time) {
        this.date = date;
        this.time = time;
    }
    
    public Date getDate() { return date; }
    public Date getTime() { return time; }
    
    @Override
    public int hashCode() { return date.hashCode() + time.hashCode(); }
    @Override
    public boolean equals(Object obj) {
        try {
            return date.equals(((ShowEventPK)obj).date) &&
                    time.equals(((ShowEventPK)obj).time);
        } catch (Exception ex) { return false; }
    }
}
]]></programlisting>                        
                        </listitem>

                        <listitem><para>Add the above parent entity to the persistence unit.</para>
    <programlisting language="xml"><![CDATA[
            <class>myorg.relex.one2one.ShowEvent</class>
    ]]></programlisting>                        
                        </listitem>
                </orderedlist>
                
                <para>Continue on with mapping the dependent entity using an @IdClass and 
                    @EmbeddedId. You will find the @IdClass technique acts much like the 
                    @PrimaryKeyJoin we performed earlier. The @EmbeddedId technique acts 
                    much like the @MapsId case as well.</para>
            </section>                
                

            <section id="jpa-relationex-o2o-uni-idclass">
                <title>One-to-One Uni-directional Using @IdClass</title>
                <para>This sub-section will map the dependent class to the parent using an @IdClass.</para>
                
                <orderedlist>
                
                    <listitem><para>Put the following dependent entity class in you src/main tree.
                        It is incomplete at this point and will generate the default mapping for 
                        the relationship to the class using the composite PK. Since we eventually
                        want to derive the primary key(s) for this dependent entity from the parent 
                        entity -- we also model the same properties as @Id and use and @IdClass to 
                        represent the PK within JPA. At this point -- the composite identity of the 
                        dependent entity is independent of the relationship.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.util.Date;

import javax.persistence.*;

/**
 * This class provides an example of a the owning entity of a
 * one-to-one, uni-directional relationship where the dependent's
 * primary key is derived from the parent and the parent uses
 * a composite primary key.
 */
@Entity
@Table(name="RELATIONEX_SHOWTICKETS")
@IdClass(ShowEventPK.class)
public class ShowTickets {
    @Id 
    @Temporal(TemporalType.DATE)
    @Column(name="TICKET_DATE")
    private Date date;
    @Id
    @Temporal(TemporalType.TIME)
    @Column(name="TICKET_TIME")
    private Date time;
    
    @OneToOne(optional=false, fetch=FetchType.EAGER)
    /*
    @PrimaryKeyJoinColumns({
        @PrimaryKeyJoinColumn(name="TICKET_DATE", referencedColumnName="date"),
        @PrimaryKeyJoinColumn(name="TICKET_TIME", referencedColumnName="time"),
    })
    */
    private ShowEvent show;
    
    @Column(name="TICKETS")
    private int ticketsLeft;

    public ShowTickets() {}
    public ShowTickets(ShowEvent show) {
        this.date = show.getDate();
        this.time = show.getTime();
        this.show = show;
    }

    public Date getDate() { return show==null ? null : show.getDate(); }
    public Date getTime() { return show==null ? null : show.getTime(); }
    public ShowEvent getShow() { return show; }

    public int getTicketsLeft() { return ticketsLeft; }
    public void setTicketsLeft(int ticketsLeft) {
        this.ticketsLeft = ticketsLeft;
    }
}
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Add the dependent entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.ShowTickets</class>
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Build the module and observe the database schema generated for 
                       the entity classes involved. Notice how the dependent table has seemingly 
                       duplicate columns. There is a TICKET_DATE/TIME set of columns that represent 
                       the dependent entity's composite primary key. There is also a show_date/time
                       set of columns to reference the parent entity -- which also uses a composite
                       primary key. If the referenced entity of a foreign relationship uses a composite
                       primary key -- then the value of the foreign key also expresses a composite
                       set of properties.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_SHOWEVENT (
        date date not null,
        time time not null,
        name varchar(20),
        primary key (date, time)
    );

    create table RELATIONEX_SHOWTICKETS (
        TICKET_DATE date not null,
        TICKET_TIME time not null,
        TICKETS integer,
        show_date date not null,
        show_time time not null,
        primary key (TICKET_DATE, TICKET_TIME),
        unique (show_date, show_time)
    );
...
    alter table RELATIONEX_SHOWTICKETS 
        add constraint FK93AB7C9AE3196D0 
        foreign key (show_date, show_time) 
        references RELATIONEX_SHOWEVENT;
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Update the relationship with a default mapping for a 
                        @PrimaryKeyJoin.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false, fetch=FetchType.EAGER)
    @PrimaryKeyJoinColumn /*s({
        @PrimaryKeyJoinColumn(name="TICKET_DATE", referencedColumnName="date"),
        @PrimaryKeyJoinColumn(name="TICKET_TIME", referencedColumnName="time"),
    })*/
    private ShowEvent show;
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Re-build the module and observe how the default
                        mapping of the @PrimaryKeyJoin was realized when using the 
                        composite primary key.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
   create table RELATIONEX_SHOWTICKETS (
        TICKET_DATE date not null,
        TICKET_TIME time not null,
        TICKETS integer,
        primary key (TICKET_DATE, TICKET_TIME)
    );
...
    alter table RELATIONEX_SHOWTICKETS 
        add constraint FK93AB7C9A1C31D972 
        foreign key (TICKET_DATE, TICKET_TIME) 
        references RELATIONEX_SHOWEVENT;
]]></programlisting>

                        <para>In this case, the provider was able to generate default mappings
                            that are exactly what we would have created manually. You could have 
                            enabled the following custom mappings to explicitly map primary
                            key column values from the dependent table columns to the parent 
                            table columns.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false, fetch=FetchType.EAGER)
    @PrimaryKeyJoinColumns({
        @PrimaryKeyJoinColumn(name="TICKET_DATE", referencedColumnName="date"),
        @PrimaryKeyJoinColumn(name="TICKET_TIME", referencedColumnName="time"),
    })
    private ShowEvent show;
]]></programlisting>
                        <para>Note there can only be a single @PrimaryKeyJoin annotated 
                            against a method. Multiple @PrimaryKeyJoin columns must be 
                            wrapped within a @PrimaryKeyJoinColumns annotation to work.</para>                        
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
      TICKET_DATE date not null,
        TICKET_TIME time not null,
        TICKETS integer,
        primary key (TICKET_DATE, TICKET_TIME)
    );
...
    alter table RELATIONEX_SHOWTICKETS 
        add constraint FK93AB7C9A1C31D972 
        foreign key (TICKET_DATE, TICKET_TIME) 
        references RELATIONEX_SHOWEVENT;
]]></programlisting>                        
                        
                    </listitem>
                
                    <listitem><para>Add the following test method to your one-to-one test case.
                        Although the @IdClass/@PrimaryKeyJoin is very similar to the @Id/PrimaryKeyJoin
                        covered earlier, this approach is being simplified by the fact the primary
                        key of the parent is not dynamically generated. The relationship assembly can
                        occur as soon as the we derive the natural key values for the parent entity.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniIdClass() {
        log.info("*** testOneToOneUniIdClass ***");
        Date showDate = new GregorianCalendar(1975+new Random().nextInt(100),
                Calendar.JANUARY, 1).getTime();
        Date showTime = new GregorianCalendar(0, 0, 0, 0, 0, 0).getTime();
        ShowEvent show = new ShowEvent(showDate, showTime);
        show.setName("Rocky Horror");
        ShowTickets tickets = new ShowTickets(show); //parent already has natural PK by this point
        tickets.setTicketsLeft(300);
        em.persist(show);
        em.persist(tickets);  
        
        //flush commands to database, clear cache, and pull back new instance
        em.flush(); em.clear();
        ShowTickets tickets2 = em.find(ShowTickets.class, new ShowEventPK(tickets.getDate(), tickets.getTime()));
        log.info("calling parent...");
        assertEquals("unexpected name", tickets.getShow().getName(), tickets2.getShow().getName());
    }
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Re-build the module and note the creation of the parent and 
                        dependent entities.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniIdClass
...
 -*** testOne2OneUniIdClass ***
Hibernate: 
    insert 
    into
        RELATIONEX_SHOWEVENT
        (name, date, time) 
    values
        (?, ?, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_SHOWTICKETS
        (TICKETS, TICKET_DATE, TICKET_TIME) 
    values
        (?, ?, ?)
]]></programlisting>
                        <para>The provider uses a set of selects to fully assemble our object
                            tree for use.</para>                        
<programlisting language=""><![CDATA[
Hibernate: 
    select
        showticket0_.TICKET_DATE as TICKET1_8_0_,
        showticket0_.TICKET_TIME as TICKET2_8_0_,
        showticket0_.TICKETS as TICKETS8_0_ 
    from
        RELATIONEX_SHOWTICKETS showticket0_ 
    where
        showticket0_.TICKET_DATE=? 
        and showticket0_.TICKET_TIME=?
Hibernate: 
    select
        showevent0_.date as date7_0_,
        showevent0_.time as time7_0_,
        showevent0_.name as name7_0_ 
    from
        RELATIONEX_SHOWEVENT showevent0_ 
    where
        showevent0_.date=? 
        and showevent0_.time=?
 -calling parent...
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Add the following to the test method to verify our assertions 
                        about the structure of the database tables and their values related to this 
                        example.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select show.date show_date, show.time show_time, " +
                       "tickets.ticket_date ticket_date, tickets.ticket_time ticket_time, tickets.tickets " +
                "from RELATIONEX_SHOWEVENT show " +
                "join RELATIONEX_SHOWTICKETS tickets on show.date = tickets.ticket_date and show.time = tickets.ticket_time " +
                "where tickets.ticket_date = ?1 and tickets.ticket_time = ?2")
                .setParameter(1, tickets.getShow().getDate(), TemporalType.DATE)
                .setParameter(2, tickets.getShow().getTime(), TemporalType.TIME)
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected show_date", tickets2.getShow().getDate(), (Date)cols[0]);
        assertEquals("unexpected show_time", tickets2.getShow().getTime(), (Date)cols[1]);
        assertEquals("unexpected ticket_date", tickets2.getDate(), (Date)cols[2]);
        assertEquals("unexpected ticket_time", tickets2.getTime(), (Date)cols[3]);
        assertEquals("unexpected ticketsLeft", tickets2.getTicketsLeft(), ((Number)cols[4]).intValue());
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Re-build the module and observe the success of the 
                        SQL portion of the test method.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniIdClass
...
Hibernate: 
    select
        show.date show_date,
        show.time show_time,
        tickets.ticket_date ticket_date,
        tickets.ticket_time ticket_time,
        tickets.tickets 
    from
        RELATIONEX_SHOWEVENT show 
    join
        RELATIONEX_SHOWTICKETS tickets 
            on show.date = tickets.ticket_date 
            and show.time = tickets.ticket_time 
    where
        tickets.ticket_date = ? 
        and tickets.ticket_time = ?
 -row=[2033-01-01, 00:00:00, 2033-01-01, 00:00:00, 300]
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Add the following cleanup logic and assertions to 
                        verify the rows have been deleted for the dependent and parent 
                        entities.</para>
<programlisting language="java"><![CDATA[
        em.remove(tickets2);
        em.remove(tickets2.getShow());
        em.flush();
        assertNull("tickets not deleted", em.find(ShowEvent.class, 
                new ShowEventPK(show.getDate(), show.getTime())));
        assertNull("show not deleted", em.find(ShowTickets.class, 
                new ShowEventPK(tickets.getDate(), tickets.getTime())));
]]></programlisting>                        
                    </listitem>
                
                    <listitem><para>Re-build the module and observe the successful results
                        of the completed test method.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniIdClass
...
Hibernate: 
    delete 
    from
        RELATIONEX_SHOWTICKETS 
    where
        TICKET_DATE=? 
        and TICKET_TIME=?
Hibernate: 
    delete 
    from
        RELATIONEX_SHOWEVENT 
    where
        date=? 
        and time=?
]]></programlisting>                        
                    </listitem>
                </orderedlist>
                
                <para>You have completed mapping a one-to-one uni-directional relationship that
                    is based on a composite primary in the parent and the composite key mapped in
                    the dependent table as an @IdClass.</para>
            </section>

            <section id="jpa-relationex-o2o-uni-embeddedid">
                <title>One-to-One Uni-directional Using @EmbeddedId</title>
                <para>In this second example of @MapsId, we will be informing the provider 
                   that the primary key for the dependent table is realized by the foreign key
                   and, in this case, is a composite primary key. We must use an @EmbeddedId
                   in order for this to work correctly.</para>
                <orderedlist>
                    
                    <listitem><para>Add the following entity class to your src/main tree. It is 
                       not complete at this point and schema generation will show there bring a 
                       separate primary and foreign key.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.util.Date;
import javax.persistence.*;

/**
 * This class provides an example of a the owning entity of a
 * one-to-one, uni-directional relationship where the dependent's
 * primary key is derived from the parent, the parent uses
 * a composite primary key, and the dependent used an @EmeddedId
 * and @MapsId.
 */
@Entity
@Table(name="RELATIONEX_BOXOFFICE")
public class BoxOffice {
    @EmbeddedId 
    private ShowEventPK pk; //will be set by provider with help of @MapsId
    
    @OneToOne(optional=false, fetch=FetchType.EAGER)
//    @MapsId //provider maps this composite FK to @EmbeddedId PK value
    private ShowEvent show;
    
    @Column(name="TICKETS")
    private int ticketsLeft;

    protected BoxOffice() {}
    public BoxOffice(ShowEvent show) {
        this.show = show;
    }

    public Date getDate() { return show==null ? null : show.getDate(); }
    public Date getTime() { return show==null ? null : show.getTime(); }
    public ShowEvent getShow() { return show; }

    public int getTicketsLeft() { return ticketsLeft; }
    public void setTicketsLeft(int ticketsLeft) {
        this.ticketsLeft = ticketsLeft;
    }
}
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Add the dependent entity class to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.BoxOffice</class>
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Build the module and observe the generated schema.
                       Notice the separate use of date/time for the primary key and 
                       show_date/time for the foreign key.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_BOXOFFICE (
        date timestamp not null,
        time timestamp not null,
        TICKETS integer,
        show_date date not null,
        show_time time not null,
        primary key (date, time),
        unique (show_date, show_time)
    );
    alter table RELATIONEX_BOXOFFICE 
        add constraint FK64CED797E3196D0 
        foreign key (show_date, show_time) 
        references RELATIONEX_SHOWEVENT;
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Update the dependent table mapping so that the 
                       foreign key is used to realize the primary key for the entity. Notice also the
                       class provides no way to set the @EmbeddedId exception thru the @MapsId
                       on the foreign key.</para>
<programlisting language="java"><![CDATA[
    @OneToOne(optional=false, fetch=FetchType.EAGER)
    @MapsId //provider maps this composite FK to @EmbeddedId PK value
    private ShowEvent show;
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Re-build the module and observe the generated database schema.
                       Note the primary key has now been mapped to the show_date/time foreign key
                       columns.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl 
...
    create table RELATIONEX_BOXOFFICE (
        TICKETS integer,
        show_date date,
        show_time time not null,
        primary key (show_date, show_time),
        unique (show_date, show_time)
    );
    alter table RELATIONEX_BOXOFFICE 
        add constraint FK64CED797E3196D0 
        foreign key (show_date, show_time) 
        references RELATIONEX_SHOWEVENT;
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Add the following test method to your one-to-one test case.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneUniEmbeddedId() {
        log.info("*** testOne2OneUniEmbedded ***");
        Date showDate = new GregorianCalendar(1975+new Random().nextInt(100),
                Calendar.JANUARY, 1).getTime();
        Date showTime = new GregorianCalendar(0, 0, 0, 0, 0, 0).getTime();
        ShowEvent show = new ShowEvent(showDate, showTime);
        show.setName("Rocky Horror");
        BoxOffice boxOffice = new BoxOffice(show);
        boxOffice.setTicketsLeft(500);
        em.persist(show);
        em.persist(boxOffice); //provider auto propagates parent.cid to dependent.FK mapped to dependent.cid 
        
        //flush commands to database, clear cache, and pull back new instance
        em.flush(); em.clear();
        BoxOffice boxOffice2 = em.find(BoxOffice.class, new ShowEventPK(boxOffice.getDate(), boxOffice.getTime()));
        log.info("calling parent...");
        assertEquals("unexpected name", boxOffice.getShow().getName(), boxOffice2.getShow().getName());
    }
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Re-build the module and run the test method above.</para>
<programlisting language="java"><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneUniEmbeddedId
...
 -*** testOne2OneUniEmbedded ***
Hibernate: 
    insert 
    into
        RELATIONEX_SHOWEVENT
        (name, date, time) 
    values
        (?, ?, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_BOXOFFICE
        (TICKETS, show_date, show_time) 
    values
        (?, ?, ?)
Hibernate: 
    select
        boxoffice0_.show_date as show2_9_0_,
        boxoffice0_.show_time as show3_9_0_,
        boxoffice0_.TICKETS as TICKETS9_0_ 
    from
        RELATIONEX_BOXOFFICE boxoffice0_ 
    where
        boxoffice0_.show_date=? 
        and boxoffice0_.show_time=?
Hibernate: 
    select
        showevent0_.date as date7_0_,
        showevent0_.time as time7_0_,
        showevent0_.name as name7_0_ 
    from
        RELATIONEX_SHOWEVENT showevent0_ 
    where
        showevent0_.date=? 
        and showevent0_.time=?
 -calling parent...
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Add the following to verify our assertions about the SQL structure and 
                        values underlying the JPA abstraction.</para>
<programlisting language="java"><![CDATA[
        Object[] cols = (Object[]) em.createNativeQuery(
                "select show.date show_date, show.time show_time, " +
                       "tickets.show_date ticket_date, tickets.show_time ticket_time, tickets.tickets " +
                "from RELATIONEX_SHOWEVENT show " +
                "join RELATIONEX_BOXOFFICE tickets on show.date = tickets.show_date and show.time = tickets.show_time " +
                "where tickets.show_date = ?1 and tickets.show_time = ?2")
                .setParameter(1, boxOffice.getShow().getDate(), TemporalType.DATE)
                .setParameter(2, boxOffice.getShow().getTime(), TemporalType.TIME)
                .getSingleResult();
        log.info("row=" + Arrays.toString(cols));
        assertEquals("unexpected show_date", boxOffice2.getShow().getDate(), (Date)cols[0]);
        assertEquals("unexpected show_time", boxOffice2.getShow().getTime(), (Date)cols[1]);
        assertEquals("unexpected ticket_date", boxOffice2.getDate(), (Date)cols[2]);
        assertEquals("unexpected ticket_time", boxOffice2.getTime(), (Date)cols[3]);
        assertEquals("unexpected ticketsLeft", boxOffice2.getTicketsLeft(), ((Number)cols[4]).intValue());
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Re-build the module and re-run the test method to verify the underlying
                        SQL structure is how assume it to be.</para>
<programlisting language=""><![CDATA[
Hibernate: 
    select
        show.date show_date,
        show.time show_time,
        tickets.show_date ticket_date,
        tickets.show_time ticket_time,
        tickets.tickets 
    from
        RELATIONEX_SHOWEVENT show 
    join
        RELATIONEX_BOXOFFICE tickets 
            on show.date = tickets.show_date 
            and show.time = tickets.show_time 
    where
        tickets.show_date = ? 
        and tickets.show_time = ?
 -row=[1994-01-01, 00:00:00, 1994-01-01, 00:00:00, 500]
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Add the following removal logic to test that we can remove the 
                        two entities and their associated rows.</para>
<programlisting language="java"><![CDATA[
        em.remove(boxOffice2);
        em.remove(boxOffice2.getShow());
        em.flush();
        assertNull("tickets not deleted", em.find(ShowEvent.class, 
                new ShowEventPK(show.getDate(), show.getTime())));
        assertNull("show not deleted", em.find(BoxOffice.class, 
                new ShowEventPK(boxOffice.getDate(), boxOffice.getTime())));
]]></programlisting>                        
                    </listitem>
                    
                    <listitem><para>Observe the output of the deletes. It is consistent with before.</para>
<programlisting language=""><![CDATA[
Hibernate: 
    delete 
    from
        RELATIONEX_BOXOFFICE 
    where
        show_date=? 
        and show_time=?
Hibernate: 
    delete 
    from
        RELATIONEX_SHOWEVENT 
    where
        date=? 
        and time=?
]]></programlisting>                        
                    </listitem>
                </orderedlist>
                
                <para>You have not completed the mapping of a one-to-one, uni-directional relationship
                   using a composite key and realized through the use of an @EmbeddedId and @MapsId.</para>
            </section>

        </section>

    </section>



    <section id="jpa-relationex-o2o-bi">
        <title>Mapping One-to-One Bi-directional Relationships</title>
        <para>In this chapter, we have so far only addressed uni-directional relationships -- where only one side
            of the relationship was aware of the other at the Java class level. We can also make our relationships 
            bi-directional for easy navigation to/from either side. This requires no change the database and is only 
            a change at the Java and mapping levels.</para>
        
        <para>In bi-directional relationships, it is important to understand there are two sides/types to the relationship; owning side and inverse side.</para>
        <itemizedlist>
            <listitem><para>The owning side of the relation defines the mapping to the database. This is what we did for the uni-directional sections above</para></listitem>
            <listitem><para>The inverse side of the relation must refer to its owning side mapping through the "mappedBy" property of the @XxxToXxx annotation</para></listitem>
            <listitem><para>For OneToOne relationships, the owning side contains the foreign key or defines the join table</para></listitem>
            <listitem><para>The provider will initialize the state of the inverse side during calls like find() and refresh(), but will not
                update its value during application changes to the owning side. This is the application programmer's job to make 
                the two references consistent.</para></listitem>
            <listitem><para>The provider will only trigger persistence changes thru changes to the owning side</para></listitem>
        </itemizedlist>
  
  
        <section id="jpa-relationex-o2o-bi-1">
            <title>One-to-One Bi-directional Joined By Primary Key</title>
            <para>Lets start the discussion of one-to-one bi-directional using a set of entities
                that are pretty much joined at the hip. Their properties have been mapped to 
                separate database tables and Java entity classes, but they will never reference
                a different instance. For this reason we will assign them a common primary key,
                join them by that common primary key value, and propagate the primary key to the
                dependent class using @MapsId.</para>
            <orderedlist>

                <listitem><para>Add the following inverse side entity class to your src/main tree. It is
                    currently incomplete and will soon cause an error. </para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import javax.persistence.*;

/**
 * This class provides an example of the inverse side of a
 * one-to-one bi-directional relationship.
 */
@Entity
@Table(name="RELATIONEX_APPLICANT")
public class Applicant {
    @Id @GeneratedValue
    private int id;
    @Column(length=32)
    private String name;

//  @OneToOne(mappedBy="applicant", //identifies property on owning side
//          fetch=FetchType.LAZY)
//  @Transient
    private Application application;

    public Applicant(){}
    public Applicant(int id) {
        this.id = id;
    }
    
    public int getId() { return id; }

    public String getName() { return name; }
    public void setName(String name) {
        this.name = name;
    }

    public Application getApplication() { return application; }
    public void setApplication(Application application) {
        this.application = application;
    }
}
]]></programlisting>                        
                </listitem>

                <listitem><para>Add the following owning side entity class to your src/main tree. It is currently
                    incomplete and will not yet generate the desired primary key mapping we desire in this case.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2one;

import java.util.Date;

import javax.persistence.*;

/**
 * This class provides an example of the owning side
 * of a one-to-one, bi-directional relationship.
 */
@Entity
@Table(name="RELATIONEX_APPLICATION")
public class Application {
    @Id
    private int id;
//    @MapsId //foreign key realizes primary key
    @OneToOne(//lack of mappedBy identifies this as owning side 
              optional=false, fetch=FetchType.EAGER)
    private Applicant applicant;
    
    @Temporal(TemporalType.DATE)
    private Date desiredStartDate;

    protected Application() {}
    public Application(Applicant applicant) {
        this.applicant = applicant;
        if (applicant != null) { 
            applicant.setApplication(this); //must maintain inverse side 
        }
    }
    
    public int getId() { return id; }
    public Applicant getApplicant() { return applicant; }

    public Date getDesiredStartDate() { return desiredStartDate; }
    public void setDesiredStartDate(Date desiredStartDate) {
        this.desiredStartDate = desiredStartDate;
    }
}
]]></programlisting>
                    <note>
                        <para>It is important to note that -- in the case of a bi-directional
                            relationship -- the application developer is responsible for setting
                            both sides of the relationship even though JPA is only concerned with
                            the inverse side when making changes to the database. We can either
                            make the assignment here ...</para>
<programlisting language="java"><![CDATA[
            applicant.setApplication(this); //must maintain inverse side 
]]></programlisting>                        
                            <para>... or from the code that called the ctor(application)
                            in the first place.</para>
<programlisting language="java"><![CDATA[
        Application application = new Application(applicant);
        applicant.setApplication(application); //must maintain inverse side 
]]></programlisting>                        
                    </note>
                </listitem>

                <listitem><para>Add the two entity classes to your persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2one.Applicant</class>
        <class>myorg.relex.one2one.Application</class>
]]></programlisting>                        
                </listitem>

                <listitem><para>Attempt to build the module and note the error from the provider attempting 
                    to map the Application entity properties. </para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes
...
org.hibernate.MappingException: Could not determine type for: myorg.relex.one2one.Application, at table: 
RELATIONEX_APPLICANT, for columns: [org.hibernate.mapping.Column(application)]
]]></programlisting>
                    <para>The error occurs because...</para>
                    <itemizedlist>
                        <listitem><para>The entity uses FIELD access and an un-annotated field property was 
                            found that has no default mapping</para></listitem>
                        <listitem><para>The referenced Application entity does not implement Serializable
                            and cannot be stuffed into a BLOB column within Applicant (and nor do we want it to)</para></listitem>
                    </itemizedlist>                        
                </listitem>

                <listitem><para>Lets initially get beyond the error by marking the property as @Transient.
                    This will allow the Java attribute to exist in memory but will not have any mapping
                    to the database. That may be what we ultimately want for some cases, but not here.
                    We are only using @Transient to get back to a stable state while we work through 
                    any other mapping issues in front of us.</para>
<programlisting language="java"><![CDATA[
    @Transient
    private Application application;
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and observe the generated database schema so far. Notice 
                    the expected uni-direction behavior has been recreated with our current mapping.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_APPLICANT (
        id integer generated by default as identity,
        name varchar(32),
        primary key (id)
    );

    create table RELATIONEX_APPLICATION (
        id integer not null,
        desiredStartDate date,
        applicant_id integer not null,
        primary key (id),
        unique (applicant_id)
    );
...
    alter table RELATIONEX_APPLICATION 
        add constraint FK8B404CA01EF7E92E 
        foreign key (applicant_id) 
        references RELATIONEX_APPLICANT;
]]></programlisting>
                    <para>Currently we are seeing...</para>
                    <itemizedlist>
                        <listitem><para>The inverse/parent Applicant entity table has no reference to the owning/dependent Application since it is @Transient</para></listitem>
                        <listitem><para>The owning/dependent Application entity table has a foreign key reference to the inverse Applicant entity table.</para></listitem>
                        <listitem><para>The owning/dependent Application entity is realizing the relation through a foreign key join rather than a primary key join.</para></listitem>
                    </itemizedlist>                        
                </listitem>

                <listitem><para>Fix the mapping from the owning/dependent Application to the inverse/parent Applicant entity by adding @MapsId
                   to the owning side definition.</para>
<programlisting language="java"><![CDATA[
    @MapsId //foreign key realizes primary key
    @OneToOne(//lack of mappedBy identifies this as owning side 
              optional=false, fetch=FetchType.EAGER)
    private Applicant applicant;
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and observe the generated database schema so far. Notice the former 
                    ID primary key column for the owning/dependent Application entity table was removed and its role 
                    taken by the APPLICANT_ID foreign key column because of the @MapsId annotation.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_APPLICANT (
        id integer generated by default as identity,
        name varchar(32),
        primary key (id)
    );

    create table RELATIONEX_APPLICATION (
        desiredStartDate date,
        applicant_id integer not null,
        primary key (applicant_id),
        unique (applicant_id)
    );
...
    alter table RELATIONEX_APPLICATION 
        add constraint FK8B404CA01EF7E92E 
        foreign key (applicant_id) 
        references RELATIONEX_APPLICANT;
]]></programlisting>                 
                    <warning>
                        <title>Primary Key Joins are Mandatory Relationships</title>
                        <para>Since primary keys cannot be optional, only mandatory relationships can be 
                            created through primary keys joins. The parent can not be deleted
                            without also removing the dependent entity (first). The inverse side must be in place 
                            with the primary key to be shared. The owning side of primary key join
                            cannot be the entity generating the primary key.</para>
                    </warning>       
                </listitem>

                <listitem><para>Attempt to fix the parent entity by replacing the @Transient specification
                    with a @OneToOne relationship mapping. However, in doing it exactly this way we are 
                    causing an error with the database mapping we will soon see...</para>
<programlisting language="java"><![CDATA[
    @OneToOne(
//          mappedBy="applicant", //identifies property on owning side
            fetch=FetchType.LAZY)
//  @Transient
    private Application application;
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and observe the generated database schema. Notice that
                    our "inverse" Applicant entity table has inherited an unwanted database column
                    ("application_applicant_id") and foreign key to the "owning" Application entity table.
                    That circular reference is not a bi-directional relationship -- it is two, independent
                    uni-directional relationships.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
  create table RELATIONEX_APPLICANT (
        id integer generated by default as identity,
        name varchar(32),
        application_applicant_id integer,
        primary key (id)
    );

    create table RELATIONEX_APPLICATION (
        desiredStartDate date,
        applicant_id integer not null,
        primary key (applicant_id),
        unique (applicant_id)
    );
...
    alter table RELATIONEX_APPLICANT 
        add constraint FK8C43FE52AB28790B 
        foreign key (application_applicant_id) 
        references RELATIONEX_APPLICATION;

    alter table RELATIONEX_APPLICATION 
        add constraint FK8B404CA01EF7E92E 
        foreign key (applicant_id) 
        references RELATIONEX_APPLICANT;
]]></programlisting>                        
                </listitem>

                <listitem><para>Fix the mistaken mapping by making the parent entity the 
                   inverse side of the relationship using the property "mappedBy".</para>
<programlisting language="java"><![CDATA[
    @OneToOne(
            mappedBy="applicant", //identifies property on owning side
            fetch=FetchType.LAZY)
    private Application application;
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and observe the generated database schema. We now have
                    the database schema we need to implement a one-to-one, bi-directional relationship
                    realized through a common, generated primary key value.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_APPLICANT (
        id integer generated by default as identity,
        name varchar(32),
        primary key (id)
    );
   create table RELATIONEX_APPLICATION (
        desiredStartDate date,
        applicant_id integer not null,
        primary key (applicant_id),
        unique (applicant_id)
    );
...
   alter table RELATIONEX_APPLICATION 
        add constraint FK8B404CA01EF7E92E 
        foreign key (applicant_id) 
        references RELATIONEX_APPLICANT;
]]></programlisting>                        
                    <para>We now have...</para>
                    <itemizedlist>
                        <listitem><para>The parent Applicant entity table has a generated PK</para></listitem>
                        <listitem><para>The parent/inverse Applicant entity table has no foreign key reference to the 
                            dependent/owning Application entity table.</para></listitem>
                        <listitem><para>The dependent/owning Application entity table has a foreign key reference
                            to the parent/inverse Applicant entity table. This is used to form the relationship.</para></listitem>
                        <listitem><para>The parent/inverse Applicant with the generated primary key can be 
                           inserted at any time.</para></listitem>
                        <listitem><para>The dependent/owning Application with the non-null foreign key 
                           can only be inserted after the parent/inverse Application entity</para></listitem>
                    </itemizedlist>
                </listitem>

                <listitem><para>Add the following test method to your existing one-to-one test case.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOne2OneBiPKJ() {
        log.info("*** testOne2OneBiPKJ() ***");
        Applicant applicant = new Applicant();
        applicant.setName("Jason Garret");
        Application application = new Application(applicant);
        application.setDesiredStartDate(new GregorianCalendar(2008, Calendar.JANUARY, 1).getTime());
        em.persist(applicant);   //provider will generate a PK
        em.persist(application); //provider will propogate parent.PK to dependent.FK/PK
     }
]]></programlisting>                        
                </listitem>

                <listitem><para>Build the module, run the new test method, and notice the database output
                    shows a good bit of what we expect from our uni-directional experience.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneBiPKJ 
...
 -*** testOne2OneBiPKJ() ***
]]></programlisting>                        
<programlisting language=""><![CDATA[
Hibernate: 
    insert 
    into
        RELATIONEX_APPLICANT
        (id, name) 
    values
        (null, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_APPLICATION
        (desiredStartDate, applicant_id) 
    values
        (?, ?)
]]></programlisting>
                </listitem>                        

                <listitem><para>Add the following to the test method to verify the actions to the 
                    database when the entities are being found from the owning/dependent side of the 
                    relationship. This should be similar to our uni-directional case since we are 
                    using the entity class with the foreign key in the find(). However, our mapping
                    seems to cause some additional database interaction.</para>
<programlisting language="java"><![CDATA[
        em.flush(); em.clear();
        log.info("finding dependent...");
        Application application2 = em.find(Application.class, application.getId());
        log.info("found dependent...");
        assertTrue("unexpected startDate", 
                application.getDesiredStartDate().equals(
                application2.getDesiredStartDate()));
        log.info("calling parent...");
        assertEquals("unexpected name", application.getApplicant().getName(), application2.getApplicant().getName());
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module, run the new test method, and notice the database output 
                   contains three select statements, including an extra select for the owning side after
                   both the owning and inverse sides have been retrieved during the EAGER fetch.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneBiPKJ 
...
-finding dependent...
Hibernate: 
    select
        applicatio0_.applicant_id as applicant2_11_0_,
        applicatio0_.desiredStartDate as desiredS1_11_0_ 
    from
        RELATIONEX_APPLICATION applicatio0_ 
    where
        applicatio0_.applicant_id=?
Hibernate: 
    select
        applicant0_.id as id10_0_,
        applicant0_.name as name10_0_ 
    from
        RELATIONEX_APPLICANT applicant0_ 
    where
        applicant0_.id=?
Hibernate: 
    select
        applicatio0_.applicant_id as applicant2_11_0_,
        applicatio0_.desiredStartDate as desiredS1_11_0_ 
    from
        RELATIONEX_APPLICATION applicatio0_ 
    where
        applicatio0_.applicant_id=?
 -found dependent...
 -calling parent...
]]></programlisting>                        
                </listitem>
                
                <listitem><para>Add the following to the test method to verify the actions to the 
                    database when the entities are being found from the inverse/parent side of the 
                    relationship. This is something we could not do in the uni-directional case since
                    the only one side of the relationship knew about the other.</para>
<programlisting language="java"><![CDATA[
        em.flush(); em.clear();
        log.info("finding parent...");
        Applicant applicant2 = em.find(Applicant.class, applicant.getId());
        log.info("found parent...");
        assertEquals("unexpected name", applicant.getName(), applicant2.getName());
        log.info("calling dependent...");
        assertTrue("unexpected startDate", 
                applicant.getApplication().getDesiredStartDate().equals(
                applicant2.getApplication().getDesiredStartDate()));
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module, run the test method, and notice the database output 
                   shows the inverse/parent being obtained first by primary key and then the owning/dependent
                   entity being obtained through its foreign key/primary key.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneBiPKJ 
...
 -finding parent...
Hibernate: 
    select
        applicant0_.id as id10_0_,
        applicant0_.name as name10_0_ 
    from
        RELATIONEX_APPLICANT applicant0_ 
    where
        applicant0_.id=?
Hibernate: 
    select
        applicatio0_.applicant_id as applicant2_11_0_,
        applicatio0_.desiredStartDate as desiredS1_11_0_ 
    from
        RELATIONEX_APPLICATION applicatio0_ 
    where
        applicatio0_.applicant_id=?
 -found parent...
 -calling dependent...
]]></programlisting>           
                    <note>
                        <para>Hardly scientific, but know that in this mapping case and provider 
                            software version, we end up saving one query to the database when 
                            accessing our primary key joined entities form the inverse/parent 
                            side of the bi-directional relationship.</para>
                    </note>             
                </listitem>                        

                <listitem><para>Add the following to the test method to verify delete actions.</para>
<programlisting language="java"><![CDATA[
        em.remove(applicant2.getApplication());
        em.remove(applicant2);
        em.flush();
        assertNull("applicant not deleted", em.find(Applicant.class, applicant2.getId()));
        assertNull("application not deleted", em.find(Application.class, applicant2.getApplication().getId()));
]]></programlisting>                        
                </listitem>

                <listitem><para>Re-build the module and notice the successful deletion.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2OneTest#testOne2OneBiPKJ 
...
Hibernate: 
    delete 
    from
        RELATIONEX_APPLICATION 
    where
        applicant_id=?
Hibernate: 
    delete 
    from
        RELATIONEX_APPLICANT 
    where
        id=?
]]></programlisting>                        
                </listitem>                        
            </orderedlist>
        </section>

  
        <section id="jpa-relationex-o2o-bi-x">
            <title>One-to-One Bi-directional Relationships X</title>
            <para></para>
            <orderedlist>

                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
        </section>
    </section>


    <section id="jpa-relationex-o2o-actions">
        <title>One-to-One EntityManager Automated Actions</title>
        <para>In this section will will go through some automated actions your EntityManager provider can do for your 
            application behind the scenes that you would otherwise need to do in extra EntityManager calls or additional
            tracking of entity use.</para>

        <section id="jpa-relationex-o2o-orphan">
            <title>One-to-One Using Orphan Removal</title>
            <para>For cases when the parent in a XxxToOne relationship becomes unreferenced by its dependent entity and the parent
               only exists to support that dependent entity -- orphanRemoval can be applied.</para>

            <itemizedlist>
                <listitem><para>Child object removes (nulls in the case of OneToOne) its relationship to the parent</para></listitem>
                <listitem><para>Leaving child was only reference, thus the last reference from the OneToOne relationship</para></listitem>
                <listitem><para>em.remove() on the orphaned parent is applied</para></listitem>
                <listitem><para>Orphaned parent entity must not be reassigned to new child. It exists for the sole use of the referencing child(ren)
                   of that collection.</para></listitem>
                <listitem><para>Not necessary to declare cascade=DELETE for this relationship</para></listitem>
                <listitem><para></para></listitem>
            </itemizedlist>
    
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
        </section>

        <section id="jpa-relationex-o2o-cascade">
            <title>One-to-One Using Cascades</title>
            <para></para>
    
            <itemizedlist>
                <listitem><para>cascade=REMOVE should only be declared for OneToXxx relationships and not ManyToXxx. To do otherwise
                    is not portable.</para></listitem>
                <listitem><para></para></listitem>
                <listitem><para></para></listitem>
                <listitem><para></para></listitem>
            </itemizedlist>
    
            <orderedlist>
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>

        </section>
    </section>

    <section id="jpa-relationex-summary">
       <title>Summary</title>
       <para>In this chapter we
       </para>
    </section>    
</chapter>
