<!DOCTYPE partintro PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"  [ ]>

<chapter id="jpa-relationex-one2many">
    <title>Mapping One-to-Many Relationships</title>
    <para></para>
        
    <section id="jpa-relationex-o2m-setup">
        <title>Setup</title>
        <para>Create a JUnit test class to host tests for the one-to-many mappings.</para>

        <orderedlist>
            <listitem><para>Put the following Junit test case base class in your src/test tree.
                You can delete the sample test method once we add our first real test. JUnit
                will fail a test case if it cannot locate a @Test to run.</para>
<programlisting language="java"><![CDATA[
package myorg.relex;

import static org.junit.Assert.*;

import javax.persistence.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.*;

public class One2ManyTest extends JPATestBase {
    private static Log log = LogFactory.getLog(One2ManyTest.class);
    @Test
    public void testSample() {
        log.info("testSample");
    }
}
]]></programlisting>                        
                </listitem>
 
                <listitem><para>Verify the new JUnit test class builds and executes to completion</para>
<programlisting language=""><![CDATA[
relationEx]$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2ManyTest

...
 -HHH000401: using driver [org.h2.Driver] at URL [jdbc:h2:tcp://localhost:9092/h2db/ejava]
...
[INFO] BUILD SUCCESS                
]]></programlisting>                        
                </listitem>
        
        </orderedlist>
    </section>
        
        
    <section id="jpa-relationex-o2m-uni">
        <title>One-to-Many Uni-directional</title>
        <para>Mapping one-to-many, uni-directional relationships require some 
           help since the owning side is a single item and we must model relationships
           to many entities. To do this we can either use a join table (which forms
           a one-to-one, uni-directional relationship with the many side) or insert
           a foreign key into the table representing the many side. We will take a look
           at the join table approach first.</para>
        
        <section id="jpa-relationex-o2m-uni-jointable">
            <title>One-to-Many Uni-directional with Join Table</title>
            <para>In this section we will demonstrate how to form a one-to-many
                uni-directional relationship using a join table. The join table
                is necessary since the many side is unaware of the relationship
                and "many" cannot be represented by a single row in the owning 
                table.</para>
            <orderedlist>
    
                <listitem><para>Place the following entity class in your src/main tree. This class provides
                    an example of the many side of a one-to-many, uni-directional relation. Because of this,
                    this entity class has no reference to the owning/parent entity class.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2many;

import javax.persistence.*;

/**
 * This class provides an example of an entity class on the many side of a one-to-many, 
 * uni-directional relationship that will be referenced through a JoinTable.
 */
@Entity
@Table(name="RELATIONEX_RIDER")
public class Rider {
    @Id @GeneratedValue
    private int id;
    @Column(length=32)
    private String name;
    
    public Rider() {}   
    public Rider(int id) {
        this.id = id;
    }

    public int getId() { return id; }
    
    public String getName() { return name; }
    public void setName(String name) {
        this.name = name;
    }
}
]]></programlisting>                        
                </listitem>
    
                <listitem><para>Place the following entity class in your src/main tree. This class provides
                    an example of the one side of a one-to-many, uni-directional relation. The implementation
                    is incomplete at the moment and relies on defaults to complete the relation.</para>
<programlisting language="java"><![CDATA[
package myorg.relex.one2many;

import java.util.List;

import javax.persistence.*;

/**
 * This entity class provides an example of the one side of a one-to-many, uni-directional relation
 * that is realized through a JoinTable.
 */
@Entity
@Table(name="RELATIONEX_BUS")
public class Bus {
    @Id
    private int number;

    @OneToMany
//  @JoinTable(
//          name="RELATIONEX_BUS_RIDER",
//          joinColumns={@JoinColumn(name="BUS_NO")},
//          inverseJoinColumns={@JoinColumn(name="RIDER_ID")}
//  )
    private List<Rider> passengers;

    protected Bus() {}
    public Bus(int number) {
        this.number = number;
    }

    public int getNumber() { return number; }

    public List<Rider> getPassengers() {
        if (passengers==null) { passengers = new ArrayList<Rider>(); }
        return passengers; 
    }
    public void setPassengers(List<Rider> passengers) {
        this.passengers = passengers;
    }
}
]]></programlisting>                        
                </listitem>
    
                <listitem><para>Add the two entity classes to the persistence unit.</para>
<programlisting language="xml"><![CDATA[
        <class>myorg.relex.one2many.Rider</class>
        <class>myorg.relex.one2many.Bus</class>
]]></programlisting>                        
                </listitem>
    
                <listitem><para>Build the module and look at the default database schema generated for the 
                    two entities and relationship</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_BUS (
        number integer not null,
        primary key (number)
    );

    create table RELATIONEX_BUS_RELATIONEX_RIDER (
        RELATIONEX_BUS_number integer not null,
        passengers_id integer not null,
        unique (passengers_id)
    );
...
    create table RELATIONEX_RIDER (
        id integer generated by default as identity,
        name varchar(32),
        primary key (id)
    );
...
    alter table RELATIONEX_BUS_RELATIONEX_RIDER 
        add constraint FK3F295C59773EE4ED 
        foreign key (RELATIONEX_BUS_number) 
        references RELATIONEX_BUS;

    alter table RELATIONEX_BUS_RELATIONEX_RIDER 
        add constraint FK3F295C5994D90F30 
        foreign key (passengers_id) 
        references RELATIONEX_RIDER;
]]></programlisting>
                    <para>Note that...</para>
                    <itemizedlist>
                        <listitem><para>The default mapping for a @OneToMany is a @JoinTable</para></listitem>
                        <listitem><para>A default join table name is created using a combination of the one and many table names</para></listitem>
                        <listitem><para>A foreign key to the one table is based on the table name and primary key column name</para></listitem>        
                        <listitem><para>A foreign key to the many table is based on the property name and primary key column name</para></listitem>        
                        <listitem><para>The foreign key to the many side is unique since the child can only be related to 
                            one parent. There can only be a single row in this table linking the child to a parent.</para></listitem>        
                    </itemizedlist>
                        
                </listitem>
    
                <listitem><para>Fill in the relationship mapping with non-default values.</para>
                    <itemizedlist>
                        <listitem><para>Explicitly use a @JoinTable mapping</para></listitem>
                        <listitem><para>Name the join name RELATIONEX_BUS_RIDER</para></listitem>
                        <listitem><para>Name the foreign key to the Bus "BUS_NO"</para></listitem>        
                        <listitem><para>Name the foreign key to the Rider "RIDER_ID</para></listitem>        
                    </itemizedlist>
<programlisting language="java"><![CDATA[
    @OneToMany
    @JoinTable(
            name="RELATIONEX_BUS_RIDER",
            joinColumns={@JoinColumn(name="BUS_NO")},
            inverseJoinColumns={@JoinColumn(name="RIDER_ID")}
    )
    private List<Rider> passengers;
]]></programlisting>                        
                </listitem>
    
                <listitem><para>Rebuild the module and re-generate the database schema for the entities and relationship.
                    Nothing will functionally change with the relationship except that we will be more in control
                    of the database table and column names chosen in case we have to map to a legacy database.</para>
<programlisting language=""><![CDATA[
$ mvn clean process-test-classes; more target/classes/ddl/relationEx-createJPA.ddl
...
    create table RELATIONEX_BUS (
        number integer not null,
        primary key (number)
    );

    create table RELATIONEX_BUS_RIDER (
        BUS_NO integer not null,
        RIDER_ID integer not null,
        unique (RIDER_ID)
    );
...
    create table RELATIONEX_RIDER (
        id integer generated by default as identity,
        name varchar(32),
        primary key (id)
    );
...
    alter table RELATIONEX_BUS_RIDER 
        add constraint FKE78EAB2B869BB455 
        foreign key (BUS_NO) 
        references RELATIONEX_BUS;

    alter table RELATIONEX_BUS_RIDER 
        add constraint FKE78EAB2B3961502F 
        foreign key (RIDER_ID) 
        references RELATIONEX_RIDER;
]]></programlisting>                        
                </listitem>
    
                <listitem><para>Add the following test method to your existing one-to-many JUnit test case to 
                    demonstrate the capabilities of a one-to-many, uni-directional relationship mapped using a 
                    join table.</para>
<programlisting language="java"><![CDATA[
    @Test
    public void testOneToManyUniJoinTable() {
        log.info("*** testOneToManyUniJoinTable ***");
        Bus bus = new Bus(302);
        em.persist(bus);
        List<Rider> riders = new ArrayList<Rider>();
        for (int i=0; i<2; i++) {
            Rider rider = new Rider();
            rider.setName("rider" + i);
            em.persist(rider);
            riders.add(rider);
        }
        log.debug("relating entities");
        bus.getPassengers().addAll(riders);
        em.flush(); em.clear();
        
        log.debug("verify we have expected objects");
        Bus bus2 = em.find(Bus.class, bus.getNumber());
        assertNotNull("bus not found", bus2);
        for (Rider r: bus.getPassengers()) {
            assertNotNull("rider not found", em.find(Rider.class, r.getId()));
        }
        log.debug("verify they are related");
        assertEquals("unexpected number of riders", bus.getPassengers().size(), bus2.getPassengers().size());
    }
]]></programlisting>                        
                </listitem>
    
                <listitem><para>Rebuild the module and run the new test method. All entity instances will be created
                    and then the relationships added.</para>
<programlisting language=""><![CDATA[
$ mvn clean test -P\!h2db -Ph2srv -Dtest=myorg.relex.One2ManyTest#testOneToManyUniJoinTable
...
 -relating entities
Hibernate: 
    insert 
    into
        RELATIONEX_BUS_RIDER
        (BUS_NO, RIDER_ID) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        RELATIONEX_BUS_RIDER
        (BUS_NO, RIDER_ID) 
    values
        (?, ?)

]]></programlisting>                        
                </listitem>
    
                <listitem><para>Notice that since we are not requiring an EAGER fetch, the parent object can be
                    retrieved without a join of the JoinTable and child/many table.</para>
<programlisting language=""><![CDATA[
 -verify we have expected objects
Hibernate: 
    select
        bus0_.number as number23_0_ 
    from
        RELATIONEX_BUS bus0_ 
    where
        bus0_.number=?
]]></programlisting>                        
                </listitem>
    
                <listitem><para>Notice that once we needed the collection a join of the JoinTable and child table
                    was performed to provide the result.</para>
<programlisting language="java"><![CDATA[
        log.debug("verify they are related");
        assertEquals("unexpected number of riders", bus.getPassengers().size(), bus2.getPassengers().size());
]]></programlisting>
<programlisting language=""><![CDATA[
 -verify they are related
Hibernate: 
    select
        passengers0_.BUS_NO as BUS1_23_1_,
        passengers0_.RIDER_ID as RIDER2_1_,
        rider1_.id as id22_0_,
        rider1_.name as name22_0_ 
    from
        RELATIONEX_BUS_RIDER passengers0_ 
    inner join
        RELATIONEX_RIDER rider1_ 
            on passengers0_.RIDER_ID=rider1_.id 
    where
        passengers0_.BUS_NO=?
]]></programlisting>                        
                        
                </listitem>
    
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
    
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
            <para></para>
        </section>
  
        <section id="jpa-relationex-o2m-uni-fk">
            <title>One-to-Many Uni-directional using Foreign Key Join (from Child Table)</title>
            <para>In this section we will demonstrate how to form a one-to-many
                uni-directional relationship without a join table. In this case the 
                @JoinColumn in the owning/one side actually maps the relationship
                to a foreign key in the dependent entity table.</para>
            <orderedlist>
    
                <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
                </listitem>
            </orderedlist>
            <para></para>
        </section>
        
    </section>

    <section id="jpa-relationex-o2m-bi">
        <title>One-to-Many Bi-directional</title>
        <para>JPA requires the many side of a one-to-many, bi-directional relationship to be the 
            owning side of that relationship. There is no choice to be made along those lines.</para>

        <section id="jpa-relationex-o2m-bi-fk">
            <title>One-to-Many Bi-directional using Foreign Key Join</title>
            <para>In this section we will demonstrate the use of a simple foreign key mapping
                from the owning/dependent entity table to the inverse/parent entity table.</para>
        <orderedlist>
            <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
            </listitem>
        </orderedlist>
        <para></para>
        </section>
  
        <section id="jpa-relationex-o2m-bi-composite">
            <title>One-to-Many Bi-directional using Derived Composite Primary</title>
            <para>In this section we will demonstrate a one-to-many, bi-directional relationship
                where the primary key of the owning/dependent entity is derived from the 
                one side.</para>
        <orderedlist>
            <listitem><para></para>
<programlisting language=""><![CDATA[
]]></programlisting>                        
            </listitem>
        </orderedlist>
        <para></para>
        </section>
    </section>


    <section id="jpa-relationex-o2m-summary">
       <title>Summary</title>
       <para>In this chapter we...
       </para>
    </section>    
</chapter>
